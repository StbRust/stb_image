using Hebron;
using Hebron.Rust;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Linq;

namespace StbSharp.StbImage.Generator
{
	class Program
	{
		private static readonly Dictionary<string, string[]> _outputs = new Dictionary<string, string[]>
		{
			["bmp"] = new string[]
			{
				"stbi__bmp",
			},
			["gif"] = new string[]
			{
				"stbi__gif",
				"stbi__load_gif",
				"stbi__process_gif",
			},
			["jpg"] = new string[]
			{
				"stbi__resample",
				"stbi__huffman",
				"STBI__ZFAST_BITS",
				"stbi__bmask",
				"stbi__jbias",
				"stbi__jpeg_dezigzag",
				"stbi__build_huffman",
				"stbi__build_fast_ac",
				"resample_row",
				"stbi__idct",
				"stbi__jpeg",
				"stbi__YCbCr",
			},
			["png"] = new string[]
			{
				"STBI__F",
				"stbi__png",
				"first_row",
				"stbi__depth_scale",
				"png_sig",
				"stbi__check_png",
				"stbi__get_chunk_header",
			},
			["tga"] = new string[]
			{
				"stbi__tga"
			},
			["zlib"] = new string[]
			{
				"stbi__zhuffman",
				"stbi__zlength",
				"stbi__zdist",
				"stbi__zdefault",
				"length_dezigzag",
				"stbi__zbuild",
				"stbi_zlib",
				"stbi__zbuf"
			},
			["psd"] = new string[]
			{
				"stbi__psd_decode_rle",
				"stbi__psd"
			},
			["hdr"] = new string[]
			{
				"stbi__hdr"
			}
		};

		private static void Write(Dictionary<string, string> input, Dictionary<string, string> output)
		{
			var keys = (from string k in input.Keys orderby k select k).ToArray();
			foreach (var key in keys)
			{
				string outputKey = null;
				foreach (var pair2 in _outputs)
				{
					foreach (var prefix in pair2.Value)
					{
						if (key.StartsWith(prefix))
						{
							outputKey = pair2.Key;
							goto found;
						}
					}
				}
			found:

				var value = input[key];

				if (outputKey == null)
				{
					if (value.Contains("(stbi__jpeg "))
					{
						outputKey = "jpg";
					}
					else if (value.Contains("(stbi__zbuf"))
					{
						outputKey = "zlib";
					}
					else if (value.Contains("(stbi__png "))
					{
						outputKey = "png";
					}
					else if (value.Contains("(stbi__gif "))
					{
						outputKey = "gif";
					}
					else if (value.Contains("(stbi__hdr "))
					{
						outputKey = "hdr";
					}
				}

				if (outputKey == null)
				{
					outputKey = "common";
				}

				if (!output.ContainsKey(outputKey))
				{
					output[outputKey] = string.Empty;
				}

				output[outputKey] += value;
				output[outputKey] += Environment.NewLine;
			}
		}

		private static string PostProcess(string data)
		{
			data = data.Replace("stbi__jpeg j = (stbi__jpeg)(stbi__malloc((ulong)(sizeof(stbi__jpeg))))",
				"var j = new stbi__jpeg()");
			return data;
		}

		static void Process()
		{
			var parameters = new RustConversionParameters
			{
				InputPath = @"stb_image.h",
				Defines = new[]
				{
					"STBI_NO_SIMD",
					"STBI_NO_PIC",
					"STBI_NO_PNM",
					"STBI_NO_STDIO",
					"STB_IMAGE_IMPLEMENTATION",
				},
				SkipStructs = new string[]
				{
				},
				SkipGlobalVariables = new[]
				{
					"stbi__g_failure_reason",
					"stbi__vertically_flip_on_load",
					"stbi__parse_png_file_invalid_chunk",
				},
				SkipFunctions = new[]
				{
					"stbi_failure_reason",
					"stbi_image_free",
					"stbi__err",
					"stbi_is_hdr_from_memory",
					"stbi_is_hdr_from_callbacks",
					"stbi__pnm_isspace",
					"stbi__pnm_skip_whitespace",
					"stbi__pic_is4",
					"stbi__start_mem",
					"stbi__start_callbacks",
					"stbi__rewind",
					"stbi_load_16_from_callbacks",
					"stbi_load_from_callbacks",
					"stbi__get8",
					"stbi__refill_buffer",
					"stbi__at_eof",
					"stbi__skip",
					"stbi__getn",
					"stbi_load_16_from_memory",
					"stbi_load_from_memory",
					"stbi_load_gif_from_memory",
					"stbi_info_from_memory",
					"stbi_info_from_callbacks",
					"stbi_is_16_bit_from_memory",
					"stbi_is_16_bit_from_callbacks",
					"stbi_loadf_from_memory",
					"stbi_loadf_from_callbacks"
				}
			};

			//            var result = TextCodeConverter.Convert(parameters.InputPath, parameters.Defines);

			var result = RustCodeConverter.Convert(parameters);

			// Post processing
			Logger.Info("Post processing...");

			var outputFiles = new Dictionary<string, string>();
			Write(result.UnnamedEnumValues, outputFiles);
			Write(result.GlobalVariables, outputFiles);
			Write(result.Structs, outputFiles);
			Write(result.StructDefaults, outputFiles);
			Write(result.Functions, outputFiles);

			foreach (var pair in outputFiles)
			{
				var data = PostProcess(pair.Value);

				var sb = new StringBuilder();
				sb.AppendLine(string.Format("// Generated by Hebron at {0}", DateTime.Now));
				sb.AppendLine();

				sb.AppendLine("use std;");
				sb.AppendLine("use c_runtime;");
				sb.AppendLine("use crate::*;");


				sb.AppendLine();
				sb.Append(data);

				File.WriteAllText(@"..\..\..\..\..\..\stb_image\src\stb_image_" + pair.Key + ".rs", sb.ToString());
			}
		}

		static void Main(string[] args)
		{
			try
			{
				Process();
			}
			catch (Exception ex)
			{
				Console.WriteLine(ex.Message);
				Console.WriteLine(ex.StackTrace);
			}

			Console.WriteLine("Finished. Press any key to quit.");
		}
	}
}