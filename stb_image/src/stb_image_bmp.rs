// Generated by Hebron at 12/26/2021 12:56:14 PM

use std;
use c_runtime;
use crate::*;

#[derive(Debug, Copy, Clone)]
pub struct stbi__bmp_data {
	pub bpp:i32,
	pub offset:i32,
	pub hsz:i32,
	pub mr:u32,
	pub mg:u32,
	pub mb:u32,
	pub ma:u32,
	pub all_a:u32,
	pub extra_read:i32,
}

impl std::default::Default for stbi__bmp_data {
	fn default() -> Self {
		stbi__bmp_data {
			bpp: 0,
			offset: 0,
			hsz: 0,
			mr: 0,
			mg: 0,
			mb: 0,
			ma: 0,
			all_a: 0,
			extra_read: 0,
		}
	}
}

pub unsafe fn stbi__bmp_info(s: *mut stbi__context, x: *mut i32, y: *mut i32, comp: *mut i32) -> i32 {
	let mut p: *mut u8 = std::ptr::null_mut();
	let mut info: stbi__bmp_data = Default::default();
	info.all_a = ((255) as u32);
	p = stbi__bmp_parse_header(s, &mut info);
	if (p) == std::ptr::null_mut() {
stbi__rewind(s);return (0) as i32;}
	if (x) != null {*x = ((s.img_x) as i32);}
	if (y) != null {*y = ((s.img_y) as i32);}
	if (comp) != null {
if ((info.bpp) == (24)) && ((info.ma) == (0xff000000)) {*comp = (3) as i32;} else {*comp = ((info.ma) != 0?4:3) as i32;}}
	return (1) as i32;
}

pub unsafe fn stbi__bmp_load(s: *mut stbi__context, x: *mut i32, y: *mut i32, comp: *mut i32, req_comp: i32, ri: *mut stbi__result_info) -> *mut u8 {
	let mut out: *mut u8 = std::ptr::null_mut();
	let mut mr: u32 = (0) as u32;let mut mg: u32 = (0) as u32;let mut mb: u32 = (0) as u32;let mut ma: u32 = (0) as u32;let mut all_a: u32 = Default::default();
	let mut pal: [[u8;256];4] = 256;
	let mut psize: i32 = 0;let mut i: i32 = Default::default();let mut j: i32 = Default::default();let mut width: i32 = Default::default();
	let mut flip_vertically: i32 = Default::default();let mut pad: i32 = Default::default();let mut target: i32 = Default::default();
	let mut info: stbi__bmp_data = Default::default();
	
	info.all_a = ((255) as u32);
	if (stbi__bmp_parse_header(s, &mut info)) == std::ptr::null_mut() {return std::ptr::null_mut();}
	flip_vertically = (((s.img_y) as i32) > (0)?1:0) as i32;
	s.img_y = ((CRuntime.abs((s.img_y) as i32)) as u32);
	if (s.img_y) > ((1 << 24) as u32) {return ((((stbi__err("too large")) != 0?(0):(0)) as u64) as *mut u8);}
	if (s.img_x) > ((1 << 24) as u32) {return ((((stbi__err("too large")) != 0?(0):(0)) as u64) as *mut u8);}
	mr = (info.mr) as u32;
	mg = (info.mg) as u32;
	mb = (info.mb) as u32;
	ma = (info.ma) as u32;
	all_a = (info.all_a) as u32;
	if (info.hsz) == (12) {
if (info.bpp) < (24) {psize = ((info.offset - info.extra_read - 24) / 3) as i32;}} else {
if (info.bpp) < (16) {psize = ((info.offset - info.extra_read - info.hsz) >> 2) as i32;}}
	if (psize) == (0) {
if (info.offset) as i64 != (s.callback_already_read) as i64 + ((s.img_buffer).offset(-((s.img_buffer_original) as isize))) {
return ((((stbi__err("bad offset")) != 0?(0):(0)) as u64) as *mut u8);}}
	if ((info.bpp) == (24)) && ((ma) == (0xff000000)) {s.img_n = (3) as i32;} else {s.img_n = ((ma) != 0?4:3) as i32;}
	if ((req_comp) != 0) && ((req_comp) >= (3)) {target = (req_comp) as i32;} else {target = (s.img_n) as i32;}
	if stbi__mad3sizes_valid((target) as i32, (s.img_x) as i32, (s.img_y) as i32, (0) as i32)== 0 {return ((((stbi__err("too large")) != 0?(0):(0)) as u64) as *mut u8);}
	out = stbi__malloc_mad3((target) as i32, (s.img_x) as i32, (s.img_y) as i32, (0) as i32);
	if out== null {return ((((stbi__err("outofmem")) != 0?(0):(0)) as u64) as *mut u8);}
	if (info.bpp) < (16) {
let mut z: i32 = 0;if ((psize) == (0)) || ((psize) > (256)) {
CRuntime.free(out);return ((((stbi__err("invalid")) != 0?(0):(0)) as u64) as *mut u8);}for (i = (0) as i32;(i) < (psize);i += 1) {
pal[i][2] = (stbi__get8(s)) as u8;pal[i][1] = (stbi__get8(s)) as u8;pal[i][0] = (stbi__get8(s)) as u8;if info.hsz != 12 {stbi__get8(s);}pal[i][3] = ((255) as u8);}stbi__skip(s, (info.offset - info.extra_read - info.hsz - psize * ((info.hsz) == (12)?3:4)) as i32);if (info.bpp) == (1) {width = (((s.img_x + (7) as u32) >> 3) as i32);} else {if (info.bpp) == (4) {width = (((s.img_x + (1) as u32) >> 1) as i32);} else {if (info.bpp) == (8) {width = ((s.img_x) as i32);} else {
CRuntime.free(out);return ((((stbi__err("bad bpp")) != 0?(0):(0)) as u64) as *mut u8);}}}pad = ((-width) & 3) as i32;if (info.bpp) == (1) {
for (j = (0) as i32;(j) < ((s.img_y) as i32);j += 1) {
let mut bit_offset: i32 = 7;let mut v: i32 = (stbi__get8(s)) as i32;for (i = (0) as i32;(i) < ((s.img_x) as i32);i += 1) {
let mut color: i32 = (v >> bit_offset) & 0x1;out[z += 1] = (pal[color][0]) as u8;out[z += 1] = (pal[color][1]) as u8;out[z += 1] = (pal[color][2]) as u8;if (target) == (4) {out[z += 1] = ((255) as u8);}if (i + 1) == ((s.img_x) as i32) {break;}if (bit_offset -= 1) < (0) {
bit_offset = (7) as i32;v = ((stbi__get8(s)) as i32);}}stbi__skip(s, (pad) as i32);}} else {
for (j = (0) as i32;(j) < ((s.img_y) as i32);j += 1) {
for (i = (0) as i32;(i) < ((s.img_x) as i32);i += (2) as i32) {
let mut v: i32 = (stbi__get8(s)) as i32;let mut v2: i32 = 0;if (info.bpp) == (4) {
v2 = (v & 15) as i32;v >>= 4;}out[z += 1] = (pal[v][0]) as u8;out[z += 1] = (pal[v][1]) as u8;out[z += 1] = (pal[v][2]) as u8;if (target) == (4) {out[z += 1] = ((255) as u8);}if (i + 1) == ((s.img_x) as i32) {break;}v = (((info.bpp) == (8))?(stbi__get8(s)) as i32:v2) as i32;out[z += 1] = (pal[v][0]) as u8;out[z += 1] = (pal[v][1]) as u8;out[z += 1] = (pal[v][2]) as u8;if (target) == (4) {out[z += 1] = ((255) as u8);}}stbi__skip(s, (pad) as i32);}}} else {
let mut rshift: i32 = 0;let mut gshift: i32 = 0;let mut bshift: i32 = 0;let mut ashift: i32 = 0;let mut rcount: i32 = 0;let mut gcount: i32 = 0;let mut bcount: i32 = 0;let mut acount: i32 = 0;let mut z: i32 = 0;let mut easy: i32 = 0;stbi__skip(s, (info.offset - info.extra_read - info.hsz) as i32);if (info.bpp) == (24) {width = (((3) as u32 * s.img_x) as i32);} else {if (info.bpp) == (16) {width = (((2) as u32 * s.img_x) as i32);} else {width = (0) as i32;}}pad = ((-width) & 3) as i32;if (info.bpp) == (24) {
easy = (1) as i32;} else {if (info.bpp) == (32) {
if ((((mb) == ((0xff) as u32)) && ((mg) == ((0xff00) as u32))) && ((mr) == ((0x00ff0000) as u32))) && ((ma) == (0xff000000)) {easy = (2) as i32;}}}if easy== 0 {
if ((mr== 0) || (mg== 0)) || (mb== 0) {
CRuntime.free(out);return ((((stbi__err("bad masks")) != 0?(0):(0)) as u64) as *mut u8);}rshift = (stbi__high_bit((mr) as u32) - 7) as i32;rcount = (stbi__bitcount((mr) as u32)) as i32;gshift = (stbi__high_bit((mg) as u32) - 7) as i32;gcount = (stbi__bitcount((mg) as u32)) as i32;bshift = (stbi__high_bit((mb) as u32) - 7) as i32;bcount = (stbi__bitcount((mb) as u32)) as i32;ashift = (stbi__high_bit((ma) as u32) - 7) as i32;acount = (stbi__bitcount((ma) as u32)) as i32;if ((((rcount) > (8)) || ((gcount) > (8))) || ((bcount) > (8))) || ((acount) > (8)) {
CRuntime.free(out);return ((((stbi__err("bad masks")) != 0?(0):(0)) as u64) as *mut u8);}}for (j = (0) as i32;(j) < ((s.img_y) as i32);j += 1) {
if (easy) != 0 {
for (i = (0) as i32;(i) < ((s.img_x) as i32);i += 1) {
let mut a: u8 = Default::default();out[z + 2] = (stbi__get8(s)) as u8;out[z + 1] = (stbi__get8(s)) as u8;out[z + 0] = (stbi__get8(s)) as u8;z += (3) as i32;a = (((easy) == (2)?(stbi__get8(s)) as i32:255) as u8);all_a |= ((a) as u32);if (target) == (4) {out[z += 1] = (a) as u8;}}} else {
let mut bpp: i32 = info.bpp;for (i = (0) as i32;(i) < ((s.img_x) as i32);i += 1) {
let mut v: u32 = ((bpp) == (16)?(stbi__get16le(s)) as u32:stbi__get32le(s));let mut a: u32 = Default::default();out[z += 1] = (((stbi__shiftsigned((v & mr) as u32, (rshift) as i32, (rcount) as i32)) & 255) as u8);out[z += 1] = (((stbi__shiftsigned((v & mg) as u32, (gshift) as i32, (gcount) as i32)) & 255) as u8);out[z += 1] = (((stbi__shiftsigned((v & mb) as u32, (bshift) as i32, (bcount) as i32)) & 255) as u8);a = (((ma) != 0?stbi__shiftsigned((v & ma) as u32, (ashift) as i32, (acount) as i32):255) as u32);all_a |= (a) as u32;if (target) == (4) {out[z += 1] = (((a) & (255) as u32) as u8);}}}stbi__skip(s, (pad) as i32);}}
	if ((target) == (4)) && ((all_a) == ((0) as u32)) {for (i = (((4) as u32 * s.img_x * s.img_y - (1) as u32) as i32);(i) >= (0);i -= (4) as i32) {out[i] = ((255) as u8);}}
	if (flip_vertically) != 0 {
let mut t: u8 = Default::default();for (j = (0) as i32;(j) < ((s.img_y) as i32 >> 1);j += 1) {
let mut p1: *mut u8 = (out).offset(((j) as u32 * s.img_x * (target) as u32) as isize);let mut p2: *mut u8 = (out).offset(((s.img_y - (1) as u32 - (j) as u32) * s.img_x * (target) as u32) as isize);for (i = (0) as i32;(i) < ((s.img_x) as i32 * target);i += 1) {
t = (p1[i]) as u8;p1[i] = (p2[i]) as u8;p2[i] = (t) as u8;}}}
	if ((req_comp) != 0) && (req_comp != target) {
out = stbi__convert_format(out, (target) as i32, (req_comp) as i32, (s.img_x) as u32, (s.img_y) as u32);if (out) == (null) {return out;}}
	*x = ((s.img_x) as i32);
	*y = ((s.img_y) as i32);
	if (comp) != null {*comp = (s.img_n) as i32;}
	return out;
}

pub unsafe fn stbi__bmp_parse_header(s: *mut stbi__context, info: *mut stbi__bmp_data) -> *mut u8 {
	let mut hsz: i32 = Default::default();
	if ((stbi__get8(s)) as i32 != 66) || ((stbi__get8(s)) as i32 != 77) {return ((((stbi__err("not BMP")) != 0?(0):(0)) as u64) as *mut u8);}
	stbi__get32le(s);
	stbi__get16le(s);
	stbi__get16le(s);
	info.offset = ((stbi__get32le(s)) as i32);
	info.hsz = (hsz = ((stbi__get32le(s)) as i32)) as i32;
	info.mr = (info.mg = (info.mb = (info.ma = ((0) as u32)) as u32)) as u32;
	info.extra_read = (14) as i32;
	if (info.offset) < (0) {return ((((stbi__err("bad BMP")) != 0?(0):(0)) as u64) as *mut u8);}
	if ((((hsz != 12) && (hsz != 40)) && (hsz != 56)) && (hsz != 108)) && (hsz != 124) {return ((((stbi__err("unknown BMP")) != 0?(0):(0)) as u64) as *mut u8);}
	if (hsz) == (12) {
s.img_x = ((stbi__get16le(s)) as u32);s.img_y = ((stbi__get16le(s)) as u32);} else {
s.img_x = (stbi__get32le(s)) as u32;s.img_y = (stbi__get32le(s)) as u32;}
	if stbi__get16le(s) != 1 {return ((((stbi__err("bad BMP")) != 0?(0):(0)) as u64) as *mut u8);}
	info.bpp = (stbi__get16le(s)) as i32;
	if hsz != 12 {
let mut compress: i32 = (stbi__get32le(s)) as i32;if ((compress) == (1)) || ((compress) == (2)) {return ((((stbi__err("BMP RLE")) != 0?(0):(0)) as u64) as *mut u8);}if (compress) >= (4) {return ((((stbi__err("BMP JPEG/PNG")) != 0?(0):(0)) as u64) as *mut u8);}if (((compress) == (3)) && (info.bpp != 16)) && (info.bpp != 32) {return ((((stbi__err("bad BMP")) != 0?(0):(0)) as u64) as *mut u8);}stbi__get32le(s);stbi__get32le(s);stbi__get32le(s);stbi__get32le(s);stbi__get32le(s);if ((hsz) == (40)) || ((hsz) == (56)) {
if (hsz) == (56) {
stbi__get32le(s);stbi__get32le(s);stbi__get32le(s);stbi__get32le(s);}if ((info.bpp) == (16)) || ((info.bpp) == (32)) {
if (compress) == (0) {
stbi__bmp_set_mask_defaults(info, (compress) as i32);} else {if (compress) == (3) {
info.mr = (stbi__get32le(s)) as u32;info.mg = (stbi__get32le(s)) as u32;info.mb = (stbi__get32le(s)) as u32;info.extra_read += (12) as i32;if ((info.mr) == (info.mg)) && ((info.mg) == (info.mb)) {
return ((((stbi__err("bad BMP")) != 0?(0):(0)) as u64) as *mut u8);}} else {return ((((stbi__err("bad BMP")) != 0?(0):(0)) as u64) as *mut u8);}}}} else {
let mut i: i32 = Default::default();if (hsz != 108) && (hsz != 124) {return ((((stbi__err("bad BMP")) != 0?(0):(0)) as u64) as *mut u8);}info.mr = (stbi__get32le(s)) as u32;info.mg = (stbi__get32le(s)) as u32;info.mb = (stbi__get32le(s)) as u32;info.ma = (stbi__get32le(s)) as u32;if compress != 3 {stbi__bmp_set_mask_defaults(info, (compress) as i32);}stbi__get32le(s);for (i = (0) as i32;(i) < (12);i += 1) {stbi__get32le(s);}if (hsz) == (124) {
stbi__get32le(s);stbi__get32le(s);stbi__get32le(s);stbi__get32le(s);}}}
	return (1) as *mut u8;
}

pub unsafe fn stbi__bmp_set_mask_defaults(info: *mut stbi__bmp_data, compress: i32) -> i32 {
	if (compress) == (3) {return (1) as i32;}
	if (compress) == (0) {
if (info.bpp) == (16) {
info.mr = (31u << 10) as u32;info.mg = (31u << 5) as u32;info.mb = (31u << 0) as u32;} else {if (info.bpp) == (32) {
info.mr = (0xffu << 16) as u32;info.mg = (0xffu << 8) as u32;info.mb = (0xffu << 0) as u32;info.ma = (0xffu << 24) as u32;info.all_a = ((0) as u32);} else {
info.mr = (info.mg = (info.mb = (info.ma = ((0) as u32)) as u32)) as u32;}}return (1) as i32;}
	return (0) as i32;
}

pub unsafe fn stbi__bmp_test(s: *mut stbi__context) -> i32 {
	let mut r: i32 = stbi__bmp_test_raw(s);
	stbi__rewind(s);
	return (r) as i32;
}

pub unsafe fn stbi__bmp_test_raw(s: *mut stbi__context) -> i32 {
	let mut r: i32 = Default::default();
	let mut sz: i32 = Default::default();
	if (stbi__get8(s)) as i32 != 66 {return (0) as i32;}
	if (stbi__get8(s)) as i32 != 77 {return (0) as i32;}
	stbi__get32le(s);
	stbi__get16le(s);
	stbi__get16le(s);
	stbi__get32le(s);
	sz = ((stbi__get32le(s)) as i32);
	r = ((((((sz) == (12)) || ((sz) == (40))) || ((sz) == (56))) || ((sz) == (108))) || ((sz) == (124))?1:0) as i32;
	return (r) as i32;
}

