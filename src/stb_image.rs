// Generated by Ur at 09.08.2018 7:56:13

const STBI_default:i32 = 0;
const STBI_grey:i32 = 1;
const STBI_grey_alpha:i32 = 2;
const STBI_rgb:i32 = 3;
const STBI_rgb_alpha:i32 = 4;
const STBI_ORDER_RGB:i32 = 0;
const STBI_ORDER_BGR:i32 = 1;
const STBI__SCAN_load:i32 = 0;
const STBI__SCAN_type:i32 = 1;
const STBI__SCAN_header:i32 = 2;
const STBI__F_none:i32 = 0;
const STBI__F_sub:i32 = 1;
const STBI__F_up:i32 = 2;
const STBI__F_avg:i32 = 3;
const STBI__F_paeth:i32 = 4;
const STBI__F_avg_first:i32 = 5;
const STBI__F_paeth_first:i32 = 6;
const stbi__h2l_gamma_i:f32 = (f32)(1.0f32 / 2.2f32);
const stbi__h2l_scale_i:f32 = (f32)(1.0f32);
const stbi__bmask:[u32;17] = [ 0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535 ];
const stbi__jbias:[i32;16] = [ 0, -1, -3, -7, -15, -31, -63, -127, -255, -511, -1023, -2047, -4095, -8191, -16383, -32767 ];
const stbi__jpeg_dezigzag:[byte;79] = [ 0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63 ];
const stbi__zlength_base:[i32;31] = [ 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0 ];
const stbi__zlength_extra:[i32;31] = [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0 ];
const stbi__zdist_base:[i32;32] = [ 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0 ];
const stbi__zdist_extra:[i32;32] = [ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ];
const length_dezigzag:[byte;19] = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];
const stbi__zdefault_length:[byte;288] = [ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8 ];
const stbi__zdefault_distance:[byte;32] = [ 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 ];
const png_sig:[byte;8] = [ 137, 80, 78, 71, 13, 10, 26, 10 ];
const first_row_filter:[byte;5] = [ STBI__F_none, STBI__F_sub, STBI__F_none, STBI__F_avg_first, STBI__F_paeth_first ];
const stbi__depth_scale_table:[byte;9] = [ 0, 0xff, 0x55, 0, 0x11, 0, 0, 0, 0x01 ];
const stbi__unpremultiply_on_load:i32 = (i32)(0);
const stbi__de_iphone_flag:i32 = (i32)(0);
struct stbi__context {
	img_x: u32,
	img_y: u32,
	img_n: i32,
	img_out_n: i32,
	io: stbi_io_callbacks,
	io_user_data: void *,
	read_from_callbacks: i32,
	buflen: i32,
	buffer_start: byte[],
	img_buffer: byte*,
	img_buffer_end: byte*,
	img_buffer_original: byte*,
	img_buffer_original_end: byte*,
}

struct stbi__result_info {
bits_per_channel: i32,
num_channels: i32,
channel_order: i32,
}

struct stbi__huffman {
fast: byte[],
code: ushort[],
values: byte[],
size: byte[],
maxcode: u32[],
delta: i32[],
}

struct stbi__zhuffman {
fast: ushort[],
firstcode: ushort[],
maxcode: i32[],
firstsymbol: ushort[],
size: byte[],
value: ushort[],
}

struct stbi__zbuf {
zbuffer: byte*,
zbuffer_end: byte*,
num_bits: i32,
code_buffer: u32,
zout: sbyte*,
zout_start: sbyte*,
zout_end: sbyte*,
z_expandable: i32,
z_length: stbi__zhuffman,
z_distance: stbi__zhuffman,
}

struct stbi__pngchunk {
length: u32,
type: u32,
}

struct stbi__png {
s: stbi__context*,
idata: byte*,
expanded: byte*,
_out_: byte*,
depth: i32,
}

struct stbi__bmp_data {
bpp: i32,
offset: i32,
hsz: i32,
mr: u32,
mg: u32,
mb: u32,
ma: u32,
all_a: u32,
}

public static void stbi__start_mem(stbi__context* s, byte* buffer, i32 len)
{
	s->read_from_callbacks = (i32)(0);
	s->img_buffer = s->img_buffer_original = buffer;
	s->img_buffer_end = s->img_buffer_original_end = buffer[len];
}

public static void stbi__start_callbacks(stbi__context* s, stbi_io_callbacks* c, void * user)
{
	s->io = (stbi_io_callbacks)(c);
	s->io_user_data = user;
	s->buflen = (i32)(sizeof((s->buffer_start)));
	s->read_from_callbacks = (i32)(1);
	s->img_buffer_original = s->buffer_start;
	stbi__refill_buffer(s);
	s->img_buffer_original_end = s->img_buffer_end;
}

public static void stbi__rewind(stbi__context* s)
{
	s->img_buffer = s->img_buffer_original;
	s->img_buffer_end = s->img_buffer_original_end;
}

public static i32 stbi__addsizes_valid(i32 a, i32 b)
{
	if ((b) < (0)) return (i32)(0);
}

public static i32 stbi__mul2sizes_valid(i32 a, i32 b)
{
	if (((a) < (0)) || ((b) < (0))) return (i32)(0);
	if ((b) == (0)) return (i32)(1);
}

public static i32 stbi__mad2sizes_valid(i32 a, i32 b, i32 add)
{
	return (i32)(((stbi__mul2sizes_valid((i32)(a), (i32)(b))) != 0) && ((stbi__addsizes_valid((i32)(a * b), (i32)(add))) != 0)?1:0);
}

public static i32 stbi__mad3sizes_valid(i32 a, i32 b, i32 c, i32 add)
{
	return (i32)((((stbi__mul2sizes_valid((i32)(a), (i32)(b))) != 0) && ((stbi__mul2sizes_valid((i32)(a * b), (i32)(c))) != 0)) && ((stbi__addsizes_valid((i32)(a * b * c), (i32)(add))) != 0)?1:0);
}

public static i32 stbi__mad4sizes_valid(i32 a, i32 b, i32 c, i32 d, i32 add)
{
	return (i32)(((((stbi__mul2sizes_valid((i32)(a), (i32)(b))) != 0) && ((stbi__mul2sizes_valid((i32)(a * b), (i32)(c))) != 0)) && ((stbi__mul2sizes_valid((i32)(a * b * c), (i32)(d))) != 0)) && ((stbi__addsizes_valid((i32)(a * b * c * d), (i32)(add))) != 0)?1:0);
}

public static void * stbi__malloc_mad2(i32 a, i32 b, i32 add)
{
	return stbi__malloc((ulong)(a * b + add));
}

public static void * stbi__malloc_mad3(i32 a, i32 b, i32 c, i32 add)
{
	return stbi__malloc((ulong)(a * b * c + add));
}

public static void * stbi__malloc_mad4(i32 a, i32 b, i32 c, i32 d, i32 add)
{
	return stbi__malloc((ulong)(a * b * c * d + add));
}

public static void stbi_set_flip_vertically_on_load(i32 flag_true_if_should_flip)
{
	stbi__vertically_flip_on_load = (i32)(flag_true_if_should_flip);
}

public static void * stbi__load_main(stbi__context* s, i32* x, i32* y, i32* comp, i32 req_comp, stbi__result_info* ri, i32 bpc)
{
	ri->bits_per_channel = (i32)(8);
	ri->channel_order = (i32)(STBI_ORDER_RGB);
	ri->num_channels = (i32)(0);
	if ((stbi__jpeg_test(s)) != 0) return stbi__jpeg_load(s, x, y, comp, (i32)(req_comp), ri);
	if ((stbi__png_test(s)) != 0) return stbi__png_load(s, x, y, comp, (i32)(req_comp), ri);
	if ((stbi__bmp_test(s)) != 0) return stbi__bmp_load(s, x, y, comp, (i32)(req_comp), ri);
	if ((stbi__gif_test(s)) != 0) return stbi__gif_load(s, x, y, comp, (i32)(req_comp), ri);
	if ((stbi__psd_test(s)) != 0) return stbi__psd_load(s, x, y, comp, (i32)(req_comp), ri, (i32)(bpc));
	if ((stbi__tga_test(s)) != 0) return stbi__tga_load(s, x, y, comp, (i32)(req_comp), ri);
}

public static byte* stbi__convert_16_to_8(ushort* orig, i32 w, i32 h, i32 channels)
{
	i:i32 =  new i32();
	img_len:i32 = (i32)(w * h * channels);
	reduced:byte*;
	reduced = (byte*)(stbi__malloc((ulong)(img_len)));
	for (i = (i32)(0); (i) < (img_len); ++i) {reduced[i] = ((byte)((orig[i] >> 8) & 0xFF));}
	CRuntime.free(orig);
	return reduced;
}

public static ushort* stbi__convert_8_to_16(byte* orig, i32 w, i32 h, i32 channels)
{
	i:i32 =  new i32();
	img_len:i32 = (i32)(w * h * channels);
	enlarged:ushort*;
	enlarged = (ushort*)(stbi__malloc((ulong)(img_len * 2)));
	for (i = (i32)(0); (i) < (img_len); ++i) {enlarged[i] = ((ushort)((orig[i] << 8) + orig[i]));}
	CRuntime.free(orig);
	return enlarged;
}

public static void stbi__vertical_flip(void * image, i32 w, i32 h, i32 bytes_per_pixel)
{
	row:i32 =  new i32();
	bytes_per_row:ulong = (ulong)(w * bytes_per_pixel);
	temp:[byte;2048] = stackalloc byte[2048];
	bytes:byte* = (byte*)(image);
	for (row = (i32)(0); (row) < (h >> 1); row++) {
row0:byte* = bytes[row * bytes_per_row];row1:byte* = bytes[(h - row - 1) * bytes_per_row];bytes_left:ulong = (ulong)(bytes_per_row);while ((bytes_left) != 0) {
bytes_copy:ulong = (ulong)(((bytes_left) < (2048))?bytes_left:2048);CRuntime.memcpy(temp, row0, (ulong)(bytes_copy));CRuntime.memcpy(row0, row1, (ulong)(bytes_copy));CRuntime.memcpy(row1, temp, (ulong)(bytes_copy));row0 += bytes_copy;row1 += bytes_copy;bytes_left -= (ulong)(bytes_copy);}}
}

public static byte* stbi__load_and_postprocess_8bit(stbi__context* s, i32* x, i32* y, i32* comp, i32 req_comp)
{
	ri:stbi__result_info =  new stbi__result_info();
	result:void * = stbi__load_main(s, x, y, comp, (i32)(req_comp), ri, (i32)(8));
	if (ri.bits_per_channel != 8) {
result = stbi__convert_16_to_8((ushort*)(result), (i32)(x), (i32)(y), (i32)((req_comp) == (0)?comp:req_comp));ri.bits_per_channel = (i32)(8);}

	if ((stbi__vertically_flip_on_load) != 0) {
channels:i32 = (i32)((req_comp) != 0?req_comp:comp);stbi__vertical_flip(result, (i32)(x), (i32)(y), (i32)(channels));}

	return (byte*)(result);
}

public static ushort* stbi__load_and_postprocess_16bit(stbi__context* s, i32* x, i32* y, i32* comp, i32 req_comp)
{
	ri:stbi__result_info =  new stbi__result_info();
	result:void * = stbi__load_main(s, x, y, comp, (i32)(req_comp), ri, (i32)(16));
	if (ri.bits_per_channel != 16) {
result = stbi__convert_8_to_16((byte*)(result), (i32)(x), (i32)(y), (i32)((req_comp) == (0)?comp:req_comp));ri.bits_per_channel = (i32)(16);}

	if ((stbi__vertically_flip_on_load) != 0) {
channels:i32 = (i32)((req_comp) != 0?req_comp:comp);stbi__vertical_flip(result, (i32)(x), (i32)(y), (i32)(channels * 2));}

	return (ushort*)(result);
}

public static ushort* stbi_load_16_from_memory(byte* buffer, i32 len, i32* x, i32* y, i32* channels_in_file, i32 desired_channels)
{
	s:stbi__context =  new stbi__context();
	stbi__start_mem(s, buffer, (i32)(len));
	return stbi__load_and_postprocess_16bit(s, x, y, channels_in_file, (i32)(desired_channels));
}

public static ushort* stbi_load_16_from_callbacks(stbi_io_callbacks* clbk, void * user, i32* x, i32* y, i32* channels_in_file, i32 desired_channels)
{
	s:stbi__context =  new stbi__context();
	stbi__start_callbacks(s, clbk, user);
	return stbi__load_and_postprocess_16bit(s, x, y, channels_in_file, (i32)(desired_channels));
}

public static byte* stbi_load_from_memory(byte* buffer, i32 len, i32* x, i32* y, i32* comp, i32 req_comp)
{
	s:stbi__context =  new stbi__context();
	stbi__start_mem(s, buffer, (i32)(len));
	return stbi__load_and_postprocess_8bit(s, x, y, comp, (i32)(req_comp));
}

public static byte* stbi_load_from_callbacks(stbi_io_callbacks* clbk, void * user, i32* x, i32* y, i32* comp, i32 req_comp)
{
	s:stbi__context =  new stbi__context();
	stbi__start_callbacks(s, clbk, user);
	return stbi__load_and_postprocess_8bit(s, x, y, comp, (i32)(req_comp));
}

public static void stbi_hdr_to_ldr_gamma(f32 gamma)
{
	stbi__h2l_gamma_i = (f32)(1 / gamma);
}

public static void stbi_hdr_to_ldr_scale(f32 scale)
{
	stbi__h2l_scale_i = (f32)(1 / scale);
}

public static void stbi__refill_buffer(stbi__context* s)
{
	n:i32 = (i32)(s->io.read(s->io_user_data, (sbyte*)(s->buffer_start), (i32)(s->buflen)));
	if ((n) == (0)) {
s->read_from_callbacks = (i32)(0);s->img_buffer = s->buffer_start;s->img_buffer_end = s->buffer_start[1];s->img_buffer = (byte)(0);}
 else {
s->img_buffer = s->buffer_start;s->img_buffer_end = s->buffer_start[n];}

}

public static byte stbi__get8(stbi__context* s)
{
	if ((s->img_buffer) < (s->img_buffer_end)) return (byte)(s->img_buffer++);
	if ((s->read_from_callbacks) != 0) {
stbi__refill_buffer(s);return (byte)(s->img_buffer++);}

	return (byte)(0);
}

public static i32 stbi__at_eof(stbi__context* s)
{
	if ((s->io.read) != null) {
if (s->io.eof(s->io_user_data)== 0) return (i32)(0);if ((s->read_from_callbacks) == (0)) return (i32)(1);}

	return (i32)((s->img_buffer) >= (s->img_buffer_end)?1:0);
}

public static void stbi__skip(stbi__context* s, i32 n)
{
	if ((n) < (0)) {
s->img_buffer = s->img_buffer_end;return;}

	if ((s->io.read) != null) {
blen:i32 = (i32)(s->img_buffer_end - s->img_buffer);if ((blen) < (n)) {
s->img_buffer = s->img_buffer_end;s->io.skip(s->io_user_data, (i32)(n - blen));return;}
}

	s->img_buffer += n;
}

public static i32 stbi__getn(stbi__context* s, byte* buffer, i32 n)
{
	if ((s->io.read) != null) {
blen:i32 = (i32)(s->img_buffer_end - s->img_buffer);if ((blen) < (n)) {
res:i32 =  new i32();count:i32 =  new i32();CRuntime.memcpy(buffer, s->img_buffer, (ulong)(blen));count = (i32)(s->io.read(s->io_user_data, (sbyte*)(buffer)[blen], (i32)(n - blen)));res = (i32)((count) == (n - blen)?1:0);s->img_buffer = s->img_buffer_end;return (i32)(res);}
}

	if (s->img_buffer[n] <= s->img_buffer_end) {
CRuntime.memcpy(buffer, s->img_buffer, (ulong)(n));s->img_buffer += n;return (i32)(1);}
 else return (i32)(0);
}

public static i32 stbi__get16be(stbi__context* s)
{
	z:i32 = (i32)(stbi__get8(s));
	return (i32)((z << 8) + stbi__get8(s));
}

public static u32 stbi__get32be(stbi__context* s)
{
	z:u32 = (u32)(stbi__get16be(s));
	return (u32)((z << 16) + stbi__get16be(s));
}

public static i32 stbi__get16le(stbi__context* s)
{
	z:i32 = (i32)(stbi__get8(s));
	return (i32)(z + (stbi__get8(s) << 8));
}

public static u32 stbi__get32le(stbi__context* s)
{
	z:u32 = (u32)(stbi__get16le(s));
	return (u32)(z + (stbi__get16le(s) << 16));
}

public static byte stbi__compute_y(i32 r, i32 g, i32 b)
{
	return (byte)(((r * 77) + (g * 150) + (29 * b)) >> 8);
}

public static byte* stbi__convert_format(byte* data, i32 img_n, i32 req_comp, u32 x, u32 y)
{
	i:i32 =  new i32();j:i32 =  new i32();
	good:byte*;
	if ((req_comp) == (img_n)) return data;
	good = (byte*)(stbi__malloc_mad3((i32)(req_comp), (i32)(x), (i32)(y), (i32)(0)));
	if (() != 0) {
CRuntime.free(data);}

	for (j = (i32)(0); (j) < ((i32)(y)); ++j) {
src:byte* = data[j * x * img_n];dest:byte* = good[j * x * req_comp];switch (((img_n) * 8 + (req_comp))){
case ((1) * 8 + (2)):for (i = (i32)(x - 1); (i) >= (0); --i , src += 1 , dest += 2) {
dest[0] = (byte)(src[0]);dest[1] = (byte)(255);}break;case ((1) * 8 + (3)):for (i = (i32)(x - 1); (i) >= (0); --i , src += 1 , dest += 3) {
dest[0] = (byte)(dest[1] = (byte)(dest[2] = (byte)(src[0])));}break;case ((1) * 8 + (4)):for (i = (i32)(x - 1); (i) >= (0); --i , src += 1 , dest += 4) {
dest[0] = (byte)(dest[1] = (byte)(dest[2] = (byte)(src[0])));dest[3] = (byte)(255);}break;case ((2) * 8 + (1)):for (i = (i32)(x - 1); (i) >= (0); --i , src += 2 , dest += 1) {
dest[0] = (byte)(src[0]);}break;case ((2) * 8 + (3)):for (i = (i32)(x - 1); (i) >= (0); --i , src += 2 , dest += 3) {
dest[0] = (byte)(dest[1] = (byte)(dest[2] = (byte)(src[0])));}break;case ((2) * 8 + (4)):for (i = (i32)(x - 1); (i) >= (0); --i , src += 2 , dest += 4) {
dest[0] = (byte)(dest[1] = (byte)(dest[2] = (byte)(src[0])));dest[3] = (byte)(src[1]);}break;case ((3) * 8 + (4)):for (i = (i32)(x - 1); (i) >= (0); --i , src += 3 , dest += 4) {
dest[0] = (byte)(src[0]);dest[1] = (byte)(src[1]);dest[2] = (byte)(src[2]);dest[3] = (byte)(255);}break;case ((3) * 8 + (1)):for (i = (i32)(x - 1); (i) >= (0); --i , src += 3 , dest += 1) {
dest[0] = (byte)(stbi__compute_y((i32)(src[0]), (i32)(src[1]), (i32)(src[2])));}break;case ((3) * 8 + (2)):for (i = (i32)(x - 1); (i) >= (0); --i , src += 3 , dest += 2) {
dest[0] = (byte)(stbi__compute_y((i32)(src[0]), (i32)(src[1]), (i32)(src[2])));dest[1] = (byte)(255);}break;case ((4) * 8 + (1)):for (i = (i32)(x - 1); (i) >= (0); --i , src += 4 , dest += 1) {
dest[0] = (byte)(stbi__compute_y((i32)(src[0]), (i32)(src[1]), (i32)(src[2])));}break;case ((4) * 8 + (2)):for (i = (i32)(x - 1); (i) >= (0); --i , src += 4 , dest += 2) {
dest[0] = (byte)(stbi__compute_y((i32)(src[0]), (i32)(src[1]), (i32)(src[2])));dest[1] = (byte)(src[3]);}break;case ((4) * 8 + (3)):for (i = (i32)(x - 1); (i) >= (0); --i , src += 4 , dest += 3) {
dest[0] = (byte)(src[0]);dest[1] = (byte)(src[1]);dest[2] = (byte)(src[2]);}break;default: ;}
}
	CRuntime.free(data);
	return good;
}

public static ushort stbi__compute_y_16(i32 r, i32 g, i32 b)
{
	return (ushort)(((r * 77) + (g * 150) + (29 * b)) >> 8);
}

public static ushort* stbi__convert_format16(ushort* data, i32 img_n, i32 req_comp, u32 x, u32 y)
{
	i:i32 =  new i32();j:i32 =  new i32();
	good:ushort*;
	if ((req_comp) == (img_n)) return data;
	good = (ushort*)(stbi__malloc((ulong)(req_comp * x * y * 2)));
	if (() != 0) {
CRuntime.free(data);}

	for (j = (i32)(0); (j) < ((i32)(y)); ++j) {
src:ushort* = data[j * x * img_n];dest:ushort* = good[j * x * req_comp];switch (((img_n) * 8 + (req_comp))){
case ((1) * 8 + (2)):for (i = (i32)(x - 1); (i) >= (0); --i , src += 1 , dest += 2) {
dest[0] = (ushort)(src[0]);dest[1] = (ushort)(0xffff);}break;case ((1) * 8 + (3)):for (i = (i32)(x - 1); (i) >= (0); --i , src += 1 , dest += 3) {
dest[0] = (ushort)(dest[1] = (ushort)(dest[2] = (ushort)(src[0])));}break;case ((1) * 8 + (4)):for (i = (i32)(x - 1); (i) >= (0); --i , src += 1 , dest += 4) {
dest[0] = (ushort)(dest[1] = (ushort)(dest[2] = (ushort)(src[0])));dest[3] = (ushort)(0xffff);}break;case ((2) * 8 + (1)):for (i = (i32)(x - 1); (i) >= (0); --i , src += 2 , dest += 1) {
dest[0] = (ushort)(src[0]);}break;case ((2) * 8 + (3)):for (i = (i32)(x - 1); (i) >= (0); --i , src += 2 , dest += 3) {
dest[0] = (ushort)(dest[1] = (ushort)(dest[2] = (ushort)(src[0])));}break;case ((2) * 8 + (4)):for (i = (i32)(x - 1); (i) >= (0); --i , src += 2 , dest += 4) {
dest[0] = (ushort)(dest[1] = (ushort)(dest[2] = (ushort)(src[0])));dest[3] = (ushort)(src[1]);}break;case ((3) * 8 + (4)):for (i = (i32)(x - 1); (i) >= (0); --i , src += 3 , dest += 4) {
dest[0] = (ushort)(src[0]);dest[1] = (ushort)(src[1]);dest[2] = (ushort)(src[2]);dest[3] = (ushort)(0xffff);}break;case ((3) * 8 + (1)):for (i = (i32)(x - 1); (i) >= (0); --i , src += 3 , dest += 1) {
dest[0] = (ushort)(stbi__compute_y_16((i32)(src[0]), (i32)(src[1]), (i32)(src[2])));}break;case ((3) * 8 + (2)):for (i = (i32)(x - 1); (i) >= (0); --i , src += 3 , dest += 2) {
dest[0] = (ushort)(stbi__compute_y_16((i32)(src[0]), (i32)(src[1]), (i32)(src[2])));dest[1] = (ushort)(0xffff);}break;case ((4) * 8 + (1)):for (i = (i32)(x - 1); (i) >= (0); --i , src += 4 , dest += 1) {
dest[0] = (ushort)(stbi__compute_y_16((i32)(src[0]), (i32)(src[1]), (i32)(src[2])));}break;case ((4) * 8 + (2)):for (i = (i32)(x - 1); (i) >= (0); --i , src += 4 , dest += 2) {
dest[0] = (ushort)(stbi__compute_y_16((i32)(src[0]), (i32)(src[1]), (i32)(src[2])));dest[1] = (ushort)(src[3]);}break;case ((4) * 8 + (3)):for (i = (i32)(x - 1); (i) >= (0); --i , src += 4 , dest += 3) {
dest[0] = (ushort)(src[0]);dest[1] = (ushort)(src[1]);dest[2] = (ushort)(src[2]);}break;default: ;}
}
	CRuntime.free(data);
	return good;
}

public static i32 stbi__build_huffman(stbi__huffman* h, i32* count)
{
	i:i32 =  new i32();j:i32 =  new i32();k:i32 = (i32)(0);code:i32 =  new i32();
	for (i = (i32)(0); (i) < (16); ++i) {for (j = (i32)(0); (j) < (count[i]); ++j) {h->size[k++] = ((byte)(i + 1));}}
	h->size[k] = (byte)(0);
	code = (i32)(0);
	k = (i32)(0);
	for (j = (i32)(1); j <= 16; ++j) {
h->delta[j] = (i32)(k - code);if ((h->size[k]) == (j)) {
while ((h->size[k]) == (j)) {h->code[k++] = ((ushort)(code++));}if ((code - 1) >= (1 << j)) return (i32)(stbi__err("bad code lengths"));}
h->maxcode[j] = (u32)(code << (16 - j));code <<= 1;}
	h->maxcode[j] = (u32)(0xffffffff);
	CRuntime.memset(h->fast, (i32)(255), (ulong)(1 << 9));
	for (i = (i32)(0); (i) < (k); ++i) {
s:i32 = (i32)(h->size[i]);if (s <= 9) {
c:i32 = (i32)(h->code[i] << (9 - s));m:i32 = (i32)(1 << (9 - s));for (j = (i32)(0); (j) < (m); ++j) {
h->fast[c + j] = ((byte)(i));}}
}
	return (i32)(1);
}

public static void stbi__build_fast_ac(short* fast_ac, stbi__huffman* h)
{
	i:i32 =  new i32();
	for (i = (i32)(0); (i) < (1 << 9); ++i) {
fast:byte = (byte)(h->fast[i]);fast_ac[i] = (short)(0);if ((fast) < (255)) {
rs:i32 = (i32)(h->values[fast]);run:i32 = (i32)((rs >> 4) & 15);magbits:i32 = (i32)(rs & 15);len:i32 = (i32)(h->size[fast]);if (((magbits) != 0) && (len + magbits <= 9)) {
k:i32 = (i32)(((i << len) & ((1 << 9) - 1)) >> (9 - magbits));m:i32 = (i32)(1 << (magbits - 1));if ((k) < (m)) k += (i32)((~0U << magbits) + 1);if (((k) >= (-128)) && (k <= 127)) fast_ac[i] = ((short)((k << 8) + (run << 4) + (len + magbits)));}
}
}
}

public static void stbi__grow_buffer_unsafe(stbi__jpeg* j)
{
	do {
b:i32 = (i32)((j->nomore) != 0?0:stbi__get8(j->s));if ((b) == (0xff)) {
c:i32 = (i32)(stbi__get8(j->s));while ((c) == (0xff)) {c = (i32)(stbi__get8(j->s));}if (c != 0) {
j->marker = ((byte)(c));j->nomore = (i32)(1);return;}
}
j->code_buffer |= (u32)(b << (24 - j->code_bits));j->code_bits += (i32)(8);}
 while (j->code_bits <= 24);
}

public static i32 stbi__jpeg_huff_decode(stbi__jpeg* j, stbi__huffman* h)
{
	temp:u32 =  new u32();
	c:i32 =  new i32();k:i32 =  new i32();
	if ((j->code_bits) < (16)) stbi__grow_buffer_unsafe(j);
	c = (i32)((j->code_buffer >> (32 - 9)) & ((1 << 9) - 1));
	k = (i32)(h->fast[c]);
	if ((k) < (255)) {
s:i32 = (i32)(h->size[k]);if ((s) > (j->code_bits)) return (i32)(-1);j->code_buffer <<= s;j->code_bits -= (i32)(s);return (i32)(h->values[k]);}

	temp = (u32)(j->code_buffer >> 16);
	for (k = (i32)(9 + 1); ; ++k) {if ((temp) < (h->maxcode[k])) break;}
	if ((k) == (17)) {
j->code_bits -= (i32)(16);return (i32)(-1);}

	if ((k) > (j->code_bits)) return (i32)(-1);
	c = (i32)(((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k]);
	j->code_bits -= (i32)(k);
	j->code_buffer <<= k;
	return (i32)(h->values[c]);
}

public static i32 stbi__extend_receive(stbi__jpeg* j, i32 n)
{
	k:u32 =  new u32();
	sgn:i32 =  new i32();
	if ((j->code_bits) < (n)) stbi__grow_buffer_unsafe(j);
	sgn = (i32)((i32)(j->code_buffer) >> 31);
	k = (u32)(CRuntime._lrotl((u32)(j->code_buffer), (i32)(n)));
	j->code_buffer = (u32)(k & ~stbi__bmask[n]);
	k &= (u32)(stbi__bmask[n]);
	j->code_bits -= (i32)(n);
	return (i32)(k + (stbi__jbias[n] & ~sgn));
}

public static i32 stbi__jpeg_get_bits(stbi__jpeg* j, i32 n)
{
	k:u32 =  new u32();
	if ((j->code_bits) < (n)) stbi__grow_buffer_unsafe(j);
	k = (u32)(CRuntime._lrotl((u32)(j->code_buffer), (i32)(n)));
	j->code_buffer = (u32)(k & ~stbi__bmask[n]);
	k &= (u32)(stbi__bmask[n]);
	j->code_bits -= (i32)(n);
	return (i32)(k);
}

public static i32 stbi__jpeg_get_bit(stbi__jpeg* j)
{
	k:u32 =  new u32();
	if ((j->code_bits) < (1)) stbi__grow_buffer_unsafe(j);
	k = (u32)(j->code_buffer);
	j->code_buffer <<= 1;
	--j->code_bits;
	return (i32)(k & 0x80000000);
}

public static i32 stbi__jpeg_decode_block(stbi__jpeg* j, short* data, stbi__huffman* hdc, stbi__huffman* hac, short* fac, i32 b, ushort* dequant)
{
	diff:i32 =  new i32();dc:i32 =  new i32();k:i32 =  new i32();
	t:i32 =  new i32();
	if ((j->code_bits) < (16)) stbi__grow_buffer_unsafe(j);
	t = (i32)(stbi__jpeg_huff_decode(j, hdc));
	if ((t) < (0)) return (i32)(stbi__err("bad huffman code"));
	CRuntime.memset(data, (i32)(0), (ulong)(64 * sizeof(short)));
	diff = (i32)((t) != 0?stbi__extend_receive(j, (i32)(t)):0);
	dc = (i32)(j->img_comp[b].dc_pred + diff);
	j->img_comp[b].dc_pred = (i32)(dc);
	data[0] = ((short)(dc * dequant[0]));
	k = (i32)(1);
	do {
zig:u32 =  new u32();c:i32 =  new i32();r:i32 =  new i32();s:i32 =  new i32();if ((j->code_bits) < (16)) stbi__grow_buffer_unsafe(j);c = (i32)((j->code_buffer >> (32 - 9)) & ((1 << 9) - 1));r = (i32)(fac[c]);if ((r) != 0) {
k += (i32)((r >> 4) & 15);s = (i32)(r & 15);j->code_buffer <<= s;j->code_bits -= (i32)(s);zig = (u32)(stbi__jpeg_dezigzag[k++]);data[zig] = ((short)((r >> 8) * dequant[zig]));}
 else {
rs:i32 = (i32)(stbi__jpeg_huff_decode(j, hac));if ((rs) < (0)) return (i32)(stbi__err("bad huffman code"));s = (i32)(rs & 15);r = (i32)(rs >> 4);if ((s) == (0)) {
if (rs != 0xf0) break;k += (i32)(16);}
 else {
k += (i32)(r);zig = (u32)(stbi__jpeg_dezigzag[k++]);data[zig] = ((short)(stbi__extend_receive(j, (i32)(s)) * dequant[zig]));}
}
}
 while ((k) < (64));
	return (i32)(1);
}

public static i32 stbi__jpeg_decode_block_prog_dc(stbi__jpeg* j, short* data, stbi__huffman* hdc, i32 b)
{
	diff:i32 =  new i32();dc:i32 =  new i32();
	t:i32 =  new i32();
	if (j->spec_end != 0) return (i32)(stbi__err("can't merge dc and ac"));
	if ((j->code_bits) < (16)) stbi__grow_buffer_unsafe(j);
	if ((j->succ_high) == (0)) {
CRuntime.memset(data, (i32)(0), (ulong)(64 * sizeof(short)));t = (i32)(stbi__jpeg_huff_decode(j, hdc));diff = (i32)((t) != 0?stbi__extend_receive(j, (i32)(t)):0);dc = (i32)(j->img_comp[b].dc_pred + diff);j->img_comp[b].dc_pred = (i32)(dc);data[0] = ((short)(dc << j->succ_low));}
 else {
if ((stbi__jpeg_get_bit(j)) != 0) data[0] += ((short)(1 << j->succ_low));}

	return (i32)(1);
}

public static i32 stbi__jpeg_decode_block_prog_ac(stbi__jpeg* j, short* data, stbi__huffman* hac, short* fac)
{
	k:i32 =  new i32();
	if ((j->spec_start) == (0)) return (i32)(stbi__err("can't merge dc and ac"));
	if ((j->succ_high) == (0)) {
shift:i32 = (i32)(j->succ_low);if ((j->eob_run) != 0) {
--j->eob_run;return (i32)(1);}
k = (i32)(j->spec_start);do {
zig:u32 =  new u32();c:i32 =  new i32();r:i32 =  new i32();s:i32 =  new i32();if ((j->code_bits) < (16)) stbi__grow_buffer_unsafe(j);c = (i32)((j->code_buffer >> (32 - 9)) & ((1 << 9) - 1));r = (i32)(fac[c]);if ((r) != 0) {
k += (i32)((r >> 4) & 15);s = (i32)(r & 15);j->code_buffer <<= s;j->code_bits -= (i32)(s);zig = (u32)(stbi__jpeg_dezigzag[k++]);data[zig] = ((short)((r >> 8) << shift));}
 else {
rs:i32 = (i32)(stbi__jpeg_huff_decode(j, hac));if ((rs) < (0)) return (i32)(stbi__err("bad huffman code"));s = (i32)(rs & 15);r = (i32)(rs >> 4);if ((s) == (0)) {
if ((r) < (15)) {
j->eob_run = (i32)(1 << r);if ((r) != 0) j->eob_run += (i32)(stbi__jpeg_get_bits(j, (i32)(r)));--j->eob_run;break;}
k += (i32)(16);}
 else {
k += (i32)(r);zig = (u32)(stbi__jpeg_dezigzag[k++]);data[zig] = ((short)(stbi__extend_receive(j, (i32)(s)) << shift));}
}
}
 while (k <= j->spec_end);}
 else {
bit:short = (short)(1 << j->succ_low);if ((j->eob_run) != 0) {
--j->eob_run;for (k = (i32)(j->spec_start); k <= j->spec_end; ++k) {
p:short* = data[stbi__jpeg_dezigzag[k]];if (p != 0) if ((stbi__jpeg_get_bit(j)) != 0) if ((p & bit) == (0)) {
if ((p) > (0)) p += (short)(bit); else p -= (short)(bit);}
}}
 else {
k = (i32)(j->spec_start);do {
r:i32 =  new i32();s:i32 =  new i32();rs:i32 = (i32)(stbi__jpeg_huff_decode(j, hac));if ((rs) < (0)) return (i32)(stbi__err("bad huffman code"));s = (i32)(rs & 15);r = (i32)(rs >> 4);if ((s) == (0)) {
if ((r) < (15)) {
j->eob_run = (i32)((1 << r) - 1);if ((r) != 0) j->eob_run += (i32)(stbi__jpeg_get_bits(j, (i32)(r)));r = (i32)(64);}
 else {
}
}
 else {
if (s != 1) return (i32)(stbi__err("bad huffman code"));if ((stbi__jpeg_get_bit(j)) != 0) s = (i32)(bit); else s = (i32)(-bit);}
while (k <= j->spec_end) {
p:short* = data[stbi__jpeg_dezigzag[k++]];if (p != 0) {
if ((stbi__jpeg_get_bit(j)) != 0) if ((p & bit) == (0)) {
if ((p) > (0)) p += (short)(bit); else p -= (short)(bit);}
}
 else {
if ((r) == (0)) {
p = ((short)(s));break;}
--r;}
}}
 while (k <= j->spec_end);}
}

	return (i32)(1);
}

public static byte stbi__clamp(i32 x)
{
	if (((u32)(x)) > (255)) {
if ((x) < (0)) return (byte)(0);if ((x) > (255)) return (byte)(255);}

	return (byte)(x);
}

public static void stbi__idct_block(byte* _out_, i32 out_stride, short* data)
{
	i:i32 =  new i32();val:[i32;64] = stackalloc i32[64];v:i32* = val;
	o:byte*;
	d:short* = ((short*)data);
	for (i = (i32)(0); (i) < (8); ++i , ++d , ++v) {
if ((((((((d[8]) == (0)) && ((d[16]) == (0))) && ((d[24]) == (0))) && ((d[32]) == (0))) && ((d[40]) == (0))) && ((d[48]) == (0))) && ((d[56]) == (0))) {
dcterm:i32 = (i32)(d[0] << 2);v[0] = (i32)(v[8] = (i32)(v[16] = (i32)(v[24] = (i32)(v[32] = (i32)(v[40] = (i32)(v[48] = (i32)(v[56] = (i32)(dcterm))))))));}
 else {
t0:i32 =  new i32();t1:i32 =  new i32();t2:i32 =  new i32();t3:i32 =  new i32();p1:i32 =  new i32();p2:i32 =  new i32();p3:i32 =  new i32();p4:i32 =  new i32();p5:i32 =  new i32();x0:i32 =  new i32();x1:i32 =  new i32();x2:i32 =  new i32();x3:i32 =  new i32();p2 = (i32)(d[16]);p3 = (i32)(d[48]);p1 = (i32)((p2 + p3) * ((i32)((0.5411961f32) * 4096 + 0.5)));t2 = (i32)(p1 + p3 * ((i32)((-1.847759065f32) * 4096 + 0.5)));t3 = (i32)(p1 + p2 * ((i32)((0.765366865f32) * 4096 + 0.5)));p2 = (i32)(d[0]);p3 = (i32)(d[32]);t0 = (i32)((p2 + p3) << 12);t1 = (i32)((p2 - p3) << 12);x0 = (i32)(t0 + t3);x3 = (i32)(t0 - t3);x1 = (i32)(t1 + t2);x2 = (i32)(t1 - t2);t0 = (i32)(d[56]);t1 = (i32)(d[40]);t2 = (i32)(d[24]);t3 = (i32)(d[8]);p3 = (i32)(t0 + t2);p4 = (i32)(t1 + t3);p1 = (i32)(t0 + t3);p2 = (i32)(t1 + t2);p5 = (i32)((p3 + p4) * ((i32)((1.175875602f32) * 4096 + 0.5)));t0 = (i32)(t0 * ((i32)((0.298631336f32) * 4096 + 0.5)));t1 = (i32)(t1 * ((i32)((2.053119869f32) * 4096 + 0.5)));t2 = (i32)(t2 * ((i32)((3.072711026f32) * 4096 + 0.5)));t3 = (i32)(t3 * ((i32)((1.501321110f32) * 4096 + 0.5)));p1 = (i32)(p5 + p1 * ((i32)((-0.899976223f32) * 4096 + 0.5)));p2 = (i32)(p5 + p2 * ((i32)((-2.562915447f32) * 4096 + 0.5)));p3 = (i32)(p3 * ((i32)((-1.961570560f32) * 4096 + 0.5)));p4 = (i32)(p4 * ((i32)((-0.390180644f32) * 4096 + 0.5)));t3 += (i32)(p1 + p4);t2 += (i32)(p2 + p3);t1 += (i32)(p2 + p4);t0 += (i32)(p1 + p3);x0 += (i32)(512);x1 += (i32)(512);x2 += (i32)(512);x3 += (i32)(512);v[0] = (i32)((x0 + t3) >> 10);v[56] = (i32)((x0 - t3) >> 10);v[8] = (i32)((x1 + t2) >> 10);v[48] = (i32)((x1 - t2) >> 10);v[16] = (i32)((x2 + t1) >> 10);v[40] = (i32)((x2 - t1) >> 10);v[24] = (i32)((x3 + t0) >> 10);v[32] = (i32)((x3 - t0) >> 10);}
}
	for (i = (i32)(0) , v = val , o = _out_; (i) < (8); ++i , v += 8 , o += out_stride) {
t0:i32 =  new i32();t1:i32 =  new i32();t2:i32 =  new i32();t3:i32 =  new i32();p1:i32 =  new i32();p2:i32 =  new i32();p3:i32 =  new i32();p4:i32 =  new i32();p5:i32 =  new i32();x0:i32 =  new i32();x1:i32 =  new i32();x2:i32 =  new i32();x3:i32 =  new i32();p2 = (i32)(v[2]);p3 = (i32)(v[6]);p1 = (i32)((p2 + p3) * ((i32)((0.5411961f32) * 4096 + 0.5)));t2 = (i32)(p1 + p3 * ((i32)((-1.847759065f32) * 4096 + 0.5)));t3 = (i32)(p1 + p2 * ((i32)((0.765366865f32) * 4096 + 0.5)));p2 = (i32)(v[0]);p3 = (i32)(v[4]);t0 = (i32)((p2 + p3) << 12);t1 = (i32)((p2 - p3) << 12);x0 = (i32)(t0 + t3);x3 = (i32)(t0 - t3);x1 = (i32)(t1 + t2);x2 = (i32)(t1 - t2);t0 = (i32)(v[7]);t1 = (i32)(v[5]);t2 = (i32)(v[3]);t3 = (i32)(v[1]);p3 = (i32)(t0 + t2);p4 = (i32)(t1 + t3);p1 = (i32)(t0 + t3);p2 = (i32)(t1 + t2);p5 = (i32)((p3 + p4) * ((i32)((1.175875602f32) * 4096 + 0.5)));t0 = (i32)(t0 * ((i32)((0.298631336f32) * 4096 + 0.5)));t1 = (i32)(t1 * ((i32)((2.053119869f32) * 4096 + 0.5)));t2 = (i32)(t2 * ((i32)((3.072711026f32) * 4096 + 0.5)));t3 = (i32)(t3 * ((i32)((1.501321110f32) * 4096 + 0.5)));p1 = (i32)(p5 + p1 * ((i32)((-0.899976223f32) * 4096 + 0.5)));p2 = (i32)(p5 + p2 * ((i32)((-2.562915447f32) * 4096 + 0.5)));p3 = (i32)(p3 * ((i32)((-1.961570560f32) * 4096 + 0.5)));p4 = (i32)(p4 * ((i32)((-0.390180644f32) * 4096 + 0.5)));t3 += (i32)(p1 + p4);t2 += (i32)(p2 + p3);t1 += (i32)(p2 + p4);t0 += (i32)(p1 + p3);x0 += (i32)(65536 + (128 << 17));x1 += (i32)(65536 + (128 << 17));x2 += (i32)(65536 + (128 << 17));x3 += (i32)(65536 + (128 << 17));o[0] = (byte)(stbi__clamp((i32)((x0 + t3) >> 17)));o[7] = (byte)(stbi__clamp((i32)((x0 - t3) >> 17)));o[1] = (byte)(stbi__clamp((i32)((x1 + t2) >> 17)));o[6] = (byte)(stbi__clamp((i32)((x1 - t2) >> 17)));o[2] = (byte)(stbi__clamp((i32)((x2 + t1) >> 17)));o[5] = (byte)(stbi__clamp((i32)((x2 - t1) >> 17)));o[3] = (byte)(stbi__clamp((i32)((x3 + t0) >> 17)));o[4] = (byte)(stbi__clamp((i32)((x3 - t0) >> 17)));}
}

public static byte stbi__get_marker(stbi__jpeg* j)
{
	x:byte =  new byte();
	if (j->marker != 0xff) {
x = (byte)(j->marker);j->marker = (byte)(0xff);return (byte)(x);}

	x = (byte)(stbi__get8(j->s));
	if (x != 0xff) return (byte)(0xff);
	while ((x) == (0xff)) {x = (byte)(stbi__get8(j->s));}
	return (byte)(x);
}

public static void stbi__jpeg_reset(stbi__jpeg* j)
{
	j->code_bits = (i32)(0);
	j->code_buffer = (u32)(0);
	j->nomore = (i32)(0);
	j->img_comp[0].dc_pred = (i32)(j->img_comp[1].dc_pred = (i32)(j->img_comp[2].dc_pred = (i32)(j->img_comp[3].dc_pred = (i32)(0))));
	j->marker = (byte)(0xff);
	j->todo = (i32)((j->restart_interval) != 0?j->restart_interval:0x7fffffff);
	j->eob_run = (i32)(0);
}

public static i32 stbi__parse_entropy_coded_data(stbi__jpeg* z)
{
	stbi__jpeg_reset(z);
	if (z->progressive== 0) {
if ((z->scan_n) == (1)) {
i:i32 =  new i32();j:i32 =  new i32();data:[short;64] = stackalloc short[64];n:i32 = (i32)(z->order[0]);w:i32 = (i32)((z->img_comp[n].x + 7) >> 3);h:i32 = (i32)((z->img_comp[n].y + 7) >> 3);for (j = (i32)(0); (j) < (h); ++j) {
for (i = (i32)(0); (i) < (w); ++i) {
ha:i32 = (i32)(z->img_comp[n].ha);if (stbi__jpeg_decode_block(z, data, z->huff_dc[z->img_comp[n].hd], z->huff_ac[ha], z->fast_ac[ha], (i32)(n), z->dequant[z->img_comp[n].tq])== 0) return (i32)(0);z->idct_block_kernel(z->img_comp[n].data[z->img_comp[n].w2 * j * 8][i * 8], (i32)(z->img_comp[n].w2), data);if (--z->todo <= 0) {
if ((z->code_bits) < (24)) stbi__grow_buffer_unsafe(z);if (!(((z->marker) >= (0xd0)) && ((z->marker) <= 0xd7))) return (i32)(1);stbi__jpeg_reset(z);}
}}return (i32)(1);}
 else {
i:i32 =  new i32();j:i32 =  new i32();k:i32 =  new i32();x:i32 =  new i32();y:i32 =  new i32();data:[short;64] = stackalloc short[64];for (j = (i32)(0); (j) < (z->img_mcu_y); ++j) {
for (i = (i32)(0); (i) < (z->img_mcu_x); ++i) {
for (k = (i32)(0); (k) < (z->scan_n); ++k) {
n:i32 = (i32)(z->order[k]);for (y = (i32)(0); (y) < (z->img_comp[n].v); ++y) {
for (x = (i32)(0); (x) < (z->img_comp[n].h); ++x) {
x2:i32 = (i32)((i * z->img_comp[n].h + x) * 8);y2:i32 = (i32)((j * z->img_comp[n].v + y) * 8);ha:i32 = (i32)(z->img_comp[n].ha);if (stbi__jpeg_decode_block(z, data, z->huff_dc[z->img_comp[n].hd], z->huff_ac[ha], z->fast_ac[ha], (i32)(n), z->dequant[z->img_comp[n].tq])== 0) return (i32)(0);z->idct_block_kernel(z->img_comp[n].data[z->img_comp[n].w2 * y2][x2], (i32)(z->img_comp[n].w2), data);}}}if (--z->todo <= 0) {
if ((z->code_bits) < (24)) stbi__grow_buffer_unsafe(z);if (!(((z->marker) >= (0xd0)) && ((z->marker) <= 0xd7))) return (i32)(1);stbi__jpeg_reset(z);}
}}return (i32)(1);}
}
 else {
if ((z->scan_n) == (1)) {
i:i32 =  new i32();j:i32 =  new i32();n:i32 = (i32)(z->order[0]);w:i32 = (i32)((z->img_comp[n].x + 7) >> 3);h:i32 = (i32)((z->img_comp[n].y + 7) >> 3);for (j = (i32)(0); (j) < (h); ++j) {
for (i = (i32)(0); (i) < (w); ++i) {
data:short* = z->img_comp[n].coeff[64 * (i + j * z->img_comp[n].coeff_w)];if ((z->spec_start) == (0)) {
if (stbi__jpeg_decode_block_prog_dc(z, data, z->huff_dc[z->img_comp[n].hd], (i32)(n))== 0) return (i32)(0);}
 else {
ha:i32 = (i32)(z->img_comp[n].ha);if (stbi__jpeg_decode_block_prog_ac(z, data, z->huff_ac[ha], z->fast_ac[ha])== 0) return (i32)(0);}
if (--z->todo <= 0) {
if ((z->code_bits) < (24)) stbi__grow_buffer_unsafe(z);if (!(((z->marker) >= (0xd0)) && ((z->marker) <= 0xd7))) return (i32)(1);stbi__jpeg_reset(z);}
}}return (i32)(1);}
 else {
i:i32 =  new i32();j:i32 =  new i32();k:i32 =  new i32();x:i32 =  new i32();y:i32 =  new i32();for (j = (i32)(0); (j) < (z->img_mcu_y); ++j) {
for (i = (i32)(0); (i) < (z->img_mcu_x); ++i) {
for (k = (i32)(0); (k) < (z->scan_n); ++k) {
n:i32 = (i32)(z->order[k]);for (y = (i32)(0); (y) < (z->img_comp[n].v); ++y) {
for (x = (i32)(0); (x) < (z->img_comp[n].h); ++x) {
x2:i32 = (i32)(i * z->img_comp[n].h + x);y2:i32 = (i32)(j * z->img_comp[n].v + y);data:short* = z->img_comp[n].coeff[64 * (x2 + y2 * z->img_comp[n].coeff_w)];if (stbi__jpeg_decode_block_prog_dc(z, data, z->huff_dc[z->img_comp[n].hd], (i32)(n))== 0) return (i32)(0);}}}if (--z->todo <= 0) {
if ((z->code_bits) < (24)) stbi__grow_buffer_unsafe(z);if (!(((z->marker) >= (0xd0)) && ((z->marker) <= 0xd7))) return (i32)(1);stbi__jpeg_reset(z);}
}}return (i32)(1);}
}

}

public static void stbi__jpeg_dequantize(short* data, ushort* dequant)
{
	i:i32 =  new i32();
	for (i = (i32)(0); (i) < (64); ++i) {data[i] *= (short)(dequant[i]);}
}

public static void stbi__jpeg_finish(stbi__jpeg* z)
{
	if ((z->progressive) != 0) {
i:i32 =  new i32();j:i32 =  new i32();n:i32 =  new i32();for (n = (i32)(0); (n) < (z->s->img_n); ++n) {
w:i32 = (i32)((z->img_comp[n].x + 7) >> 3);h:i32 = (i32)((z->img_comp[n].y + 7) >> 3);for (j = (i32)(0); (j) < (h); ++j) {
for (i = (i32)(0); (i) < (w); ++i) {
data:short* = z->img_comp[n].coeff[64 * (i + j * z->img_comp[n].coeff_w)];stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);z->idct_block_kernel(z->img_comp[n].data[z->img_comp[n].w2 * j * 8][i * 8], (i32)(z->img_comp[n].w2), data);}}}}

}

public static i32 stbi__process_marker(stbi__jpeg* z, i32 m)
{
	L:i32 =  new i32();
	switch (m){
case 0xff:return (i32)(stbi__err("expected marker"));case 0xDD:if (stbi__get16be(z->s) != 4) return (i32)(stbi__err("bad DRI len"));z->restart_interval = (i32)(stbi__get16be(z->s));return (i32)(1);case 0xDB:L = (i32)(stbi__get16be(z->s) - 2);while ((L) > (0)) {
q:i32 = (i32)(stbi__get8(z->s));p:i32 = (i32)(q >> 4);sixteen:i32 = (i32)(p != 0);t:i32 = (i32)(q & 15);i:i32 =  new i32();if ((p != 0) && (p != 1)) return (i32)(stbi__err("bad DQT type"));if ((t) > (3)) return (i32)(stbi__err("bad DQT table"));for (i = (i32)(0); (i) < (64); ++i) {z->dequant[t][stbi__jpeg_dezigzag[i]] = ((ushort)((sixteen) != 0?stbi__get16be(z->s):stbi__get8(z->s)));}L -= (i32)((sixteen) != 0?129:65);}return (i32)((L) == (0)?1:0);case 0xC4:L = (i32)(stbi__get16be(z->s) - 2);while ((L) > (0)) {
v:byte*;sizes:[i32;16] = stackalloc i32[16];i:i32 =  new i32();n:i32 = (i32)(0);q:i32 = (i32)(stbi__get8(z->s));tc:i32 = (i32)(q >> 4);th:i32 = (i32)(q & 15);if (((tc) > (1)) || ((th) > (3))) return (i32)(stbi__err("bad DHT header"));for (i = (i32)(0); (i) < (16); ++i) {
sizes[i] = (i32)(stbi__get8(z->s));n += (i32)(sizes[i]);}L -= (i32)(17);if ((tc) == (0)) {
if (stbi__build_huffman(z->huff_dc[th], sizes)== 0) return (i32)(0);v = z->huff_dc[th].values;}
 else {
if (stbi__build_huffman(z->huff_ac[th], sizes)== 0) return (i32)(0);v = z->huff_ac[th].values;}
for (i = (i32)(0); (i) < (n); ++i) {v[i] = (byte)(stbi__get8(z->s));}if (tc != 0) stbi__build_fast_ac(z->fast_ac[th], z->huff_ac[th]);L -= (i32)(n);}return (i32)((L) == (0)?1:0);}

	if ((((m) >= (0xE0)) && (m <= 0xEF)) || ((m) == (0xFE))) {
L = (i32)(stbi__get16be(z->s));if ((L) < (2)) {
if ((m) == (0xFE)) return (i32)(stbi__err("bad COM len")); else return (i32)(stbi__err("bad APP len"));}
L -= (i32)(2);if (((m) == (0xE0)) && ((L) >= (5))) {
tag:[byte;5] = stackalloc byte[5];
tag[0] = (byte)('J');
tag[1] = (byte)('F');
tag[2] = (byte)('I');
tag[3] = (byte)('F');
tag[4] = (byte)('\0');
ok:i32 = (i32)(1);i:i32 =  new i32();for (i = (i32)(0); (i) < (5); ++i) {if (stbi__get8(z->s) != tag[i]) ok = (i32)(0);}L -= (i32)(5);if ((ok) != 0) z->jfif = (i32)(1);}
 else if (((m) == (0xEE)) && ((L) >= (12))) {
tag:[byte;6] = stackalloc byte[6];
tag[0] = (byte)('A');
tag[1] = (byte)('d');
tag[2] = (byte)('o');
tag[3] = (byte)('b');
tag[4] = (byte)('e');
tag[5] = (byte)('\0');
ok:i32 = (i32)(1);i:i32 =  new i32();for (i = (i32)(0); (i) < (6); ++i) {if (stbi__get8(z->s) != tag[i]) ok = (i32)(0);}L -= (i32)(6);if ((ok) != 0) {
stbi__get8(z->s);stbi__get16be(z->s);stbi__get16be(z->s);z->app14_color_transform = (i32)(stbi__get8(z->s));L -= (i32)(6);}
}
stbi__skip(z->s, (i32)(L));return (i32)(1);}

	return (i32)(stbi__err("unknown marker"));
}

public static i32 stbi__process_scan_header(stbi__jpeg* z)
{
	i:i32 =  new i32();
	Ls:i32 = (i32)(stbi__get16be(z->s));
	z->scan_n = (i32)(stbi__get8(z->s));
	if ((((z->scan_n) < (1)) || ((z->scan_n) > (4))) || ((z->scan_n) > (z->s->img_n))) return (i32)(stbi__err("bad SOS component count"));
	if (Ls != 6 + 2 * z->scan_n) return (i32)(stbi__err("bad SOS len"));
	for (i = (i32)(0); (i) < (z->scan_n); ++i) {
id:i32 = (i32)(stbi__get8(z->s));which:i32 =  new i32();q:i32 = (i32)(stbi__get8(z->s));for (which = (i32)(0); (which) < (z->s->img_n); ++which) {if ((z->img_comp[which].id) == (id)) break;}if ((which) == (z->s->img_n)) return (i32)(0);z->img_comp[which].hd = (i32)(q >> 4);if ((z->img_comp[which].hd) > (3)) return (i32)(stbi__err("bad DC huff"));z->img_comp[which].ha = (i32)(q & 15);if ((z->img_comp[which].ha) > (3)) return (i32)(stbi__err("bad AC huff"));z->order[i] = (i32)(which);}
	{
aa:i32 =  new i32();z->spec_start = (i32)(stbi__get8(z->s));z->spec_end = (i32)(stbi__get8(z->s));aa = (i32)(stbi__get8(z->s));z->succ_high = (i32)(aa >> 4);z->succ_low = (i32)(aa & 15);if ((z->progressive) != 0) {
if ((((((z->spec_start) > (63)) || ((z->spec_end) > (63))) || ((z->spec_start) > (z->spec_end))) || ((z->succ_high) > (13))) || ((z->succ_low) > (13))) return (i32)(stbi__err("bad SOS"));}
 else {
if (z->spec_start != 0) return (i32)(stbi__err("bad SOS"));if ((z->succ_high != 0) || (z->succ_low != 0)) return (i32)(stbi__err("bad SOS"));z->spec_end = (i32)(63);}
}

	return (i32)(1);
}

public static i32 stbi__free_jpeg_components(stbi__jpeg* z, i32 ncomp, i32 why)
{
	i:i32 =  new i32();
	for (i = (i32)(0); (i) < (ncomp); ++i) {
if ((z->img_comp[i].raw_data) != null) {
CRuntime.free(z->img_comp[i].raw_data);}
if ((z->img_comp[i].raw_coeff) != null) {
CRuntime.free(z->img_comp[i].raw_coeff);z->img_comp[i].raw_coeff = null;z->img_comp[i].coeff = null;}
if ((z->img_comp[i].linebuf) != null) {
CRuntime.free(z->img_comp[i].linebuf);}
}
	return (i32)(why);
}

public static i32 stbi__process_frame_header(stbi__jpeg* z, i32 scan)
{
	s:stbi__context* = z->s;
	Lf:i32 =  new i32();p:i32 =  new i32();i:i32 =  new i32();q:i32 =  new i32();h_max:i32 = (i32)(1);v_max:i32 = (i32)(1);c:i32 =  new i32();
	Lf = (i32)(stbi__get16be(s));
	if ((Lf) < (11)) return (i32)(stbi__err("bad SOF len"));
	p = (i32)(stbi__get8(s));
	if (p != 8) return (i32)(stbi__err("only 8-bit"));
	s->img_y = (u32)(stbi__get16be(s));
	if ((s->img_y) == (0)) return (i32)(stbi__err("no header height"));
	s->img_x = (u32)(stbi__get16be(s));
	if ((s->img_x) == (0)) return (i32)(stbi__err("0 width"));
	c = (i32)(stbi__get8(s));
	if (((c != 3) && (c != 1)) && (c != 4)) return (i32)(stbi__err("bad component count"));
	s->img_n = (i32)(c);
	for (i = (i32)(0); (i) < (c); ++i) {
}
	if (Lf != 8 + 3 * s->img_n) return (i32)(stbi__err("bad SOF len"));
	z->rgb = (i32)(0);
	for (i = (i32)(0); (i) < (s->img_n); ++i) {
rgb:[byte;3] = stackalloc byte[3];
rgb[0] = (byte)('R');
rgb[1] = (byte)('G');
rgb[2] = (byte)('B');
z->img_comp[i].id = (i32)(stbi__get8(s));if (((s->img_n) == (3)) && ((z->img_comp[i].id) == (rgb[i]))) ++z->rgb;q = (i32)(stbi__get8(s));z->img_comp[i].h = (i32)(q >> 4);if ((z->img_comp[i].h== 0) || ((z->img_comp[i].h) > (4))) return (i32)(stbi__err("bad H"));z->img_comp[i].v = (i32)(q & 15);if ((z->img_comp[i].v== 0) || ((z->img_comp[i].v) > (4))) return (i32)(stbi__err("bad V"));z->img_comp[i].tq = (i32)(stbi__get8(s));if ((z->img_comp[i].tq) > (3)) return (i32)(stbi__err("bad TQ"));}
	if (scan != STBI__SCAN_load) return (i32)(1);
	if (stbi__mad3sizes_valid((i32)(s->img_x), (i32)(s->img_y), (i32)(s->img_n), (i32)(0))== 0) return (i32)(stbi__err("too large"));
	for (i = (i32)(0); (i) < (s->img_n); ++i) {
if ((z->img_comp[i].h) > (h_max)) h_max = (i32)(z->img_comp[i].h);if ((z->img_comp[i].v) > (v_max)) v_max = (i32)(z->img_comp[i].v);}
	z->img_h_max = (i32)(h_max);
	z->img_v_max = (i32)(v_max);
	z->img_mcu_w = (i32)(h_max * 8);
	z->img_mcu_h = (i32)(v_max * 8);
	z->img_mcu_x = (i32)((s->img_x + z->img_mcu_w - 1) / z->img_mcu_w);
	z->img_mcu_y = (i32)((s->img_y + z->img_mcu_h - 1) / z->img_mcu_h);
	for (i = (i32)(0); (i) < (s->img_n); ++i) {
z->img_comp[i].x = (i32)((s->img_x * z->img_comp[i].h + h_max - 1) / h_max);z->img_comp[i].y = (i32)((s->img_y * z->img_comp[i].v + v_max - 1) / v_max);z->img_comp[i].w2 = (i32)(z->img_mcu_x * z->img_comp[i].h * 8);z->img_comp[i].h2 = (i32)(z->img_mcu_y * z->img_comp[i].v * 8);z->img_comp[i].coeff = null;z->img_comp[i].raw_coeff = null;z->img_comp[i].raw_data = stbi__malloc_mad2((i32)(z->img_comp[i].w2), (i32)(z->img_comp[i].h2), (i32)(15));if (() != 0) return (i32)(stbi__free_jpeg_components(z, (i32)(i + 1), (i32)(stbi__err("outofmem"))));z->img_comp[i].data = (byte*)(((ulong)(z->img_comp[i].raw_data) + 15) & ~15);if ((z->progressive) != 0) {
z->img_comp[i].coeff_w = (i32)(z->img_comp[i].w2 / 8);z->img_comp[i].coeff_h = (i32)(z->img_comp[i].h2 / 8);z->img_comp[i].raw_coeff = stbi__malloc_mad3((i32)(z->img_comp[i].w2), (i32)(z->img_comp[i].h2), (i32)(2), (i32)(15));if (() != 0) return (i32)(stbi__free_jpeg_components(z, (i32)(i + 1), (i32)(stbi__err("outofmem"))));z->img_comp[i].coeff = (short*)(((ulong)(z->img_comp[i].raw_coeff) + 15) & ~15);}
}
	return (i32)(1);
}

public static i32 stbi__decode_jpeg_header(stbi__jpeg* z, i32 scan)
{
	m:i32 =  new i32();
	z->jfif = (i32)(0);
	z->app14_color_transform = (i32)(-1);
	z->marker = (byte)(0xff);
	m = (i32)(stbi__get_marker(z));
	if (!((m) == (0xd8))) return (i32)(stbi__err("no SOI"));
	if ((scan) == (STBI__SCAN_type)) return (i32)(1);
	m = (i32)(stbi__get_marker(z));
	while (!((((m) == (0xc0)) || ((m) == (0xc1))) || ((m) == (0xc2)))) {
if (stbi__process_marker(z, (i32)(m))== 0) return (i32)(0);m = (i32)(stbi__get_marker(z));while ((m) == (0xff)) {
if ((stbi__at_eof(z->s)) != 0) return (i32)(stbi__err("no SOF"));m = (i32)(stbi__get_marker(z));}}
	z->progressive = (i32)((m) == (0xc2)?1:0);
	if (stbi__process_frame_header(z, (i32)(scan))== 0) return (i32)(0);
	return (i32)(1);
}

public static i32 stbi__decode_jpeg_image(stbi__jpeg* j)
{
	m:i32 =  new i32();
	for (m = (i32)(0); (m) < (4); m++) {
}
	j->restart_interval = (i32)(0);
	if (stbi__decode_jpeg_header(j, (i32)(STBI__SCAN_load))== 0) return (i32)(0);
	m = (i32)(stbi__get_marker(j));
	while (!((m) == (0xd9))) {
if (((m) == (0xda))) {
if (stbi__process_scan_header(j)== 0) return (i32)(0);if (stbi__parse_entropy_coded_data(j)== 0) return (i32)(0);if ((j->marker) == (0xff)) {
while (stbi__at_eof(j->s)== 0) {
x:i32 = (i32)(stbi__get8(j->s));if ((x) == (255)) {
j->marker = (byte)(stbi__get8(j->s));break;}
}}
}
 else if (((m) == (0xdc))) {
Ld:i32 = (i32)(stbi__get16be(j->s));NL:u32 = (u32)(stbi__get16be(j->s));if (Ld != 4) stbi__err("bad DNL len");if (NL != j->s->img_y) stbi__err("bad DNL height");}
 else {
if (stbi__process_marker(j, (i32)(m))== 0) return (i32)(0);}
m = (i32)(stbi__get_marker(j));}
	if ((j->progressive) != 0) stbi__jpeg_finish(j);
	return (i32)(1);
}

public static byte* resample_row_1(byte* _out_, byte* in_near, byte* in_far, i32 w, i32 hs)
{
	return in_near;
}

public static byte* stbi__resample_row_v_2(byte* _out_, byte* in_near, byte* in_far, i32 w, i32 hs)
{
	i:i32 =  new i32();
	for (i = (i32)(0); (i) < (w); ++i) {_out_[i] = ((byte)((3 * in_near[i] + in_far[i] + 2) >> 2));}
	return _out_;
}

public static byte* stbi__resample_row_h_2(byte* _out_, byte* in_near, byte* in_far, i32 w, i32 hs)
{
	i:i32 =  new i32();
	input:byte* = in_near;
	if ((w) == (1)) {
_out_[0] = (byte)(_out_[1] = (byte)(input[0]));return _out_;}

	_out_[0] = (byte)(input[0]);
	_out_[1] = ((byte)((input[0] * 3 + input[1] + 2) >> 2));
	for (i = (i32)(1); (i) < (w - 1); ++i) {
n:i32 = (i32)(3 * input[i] + 2);_out_[i * 2 + 0] = ((byte)((n + input[i - 1]) >> 2));_out_[i * 2 + 1] = ((byte)((n + input[i + 1]) >> 2));}
	_out_[i * 2 + 0] = ((byte)((input[w - 2] * 3 + input[w - 1] + 2) >> 2));
	_out_[i * 2 + 1] = (byte)(input[w - 1]);
	return _out_;
}

public static byte* stbi__resample_row_hv_2(byte* _out_, byte* in_near, byte* in_far, i32 w, i32 hs)
{
	i:i32 =  new i32();t0:i32 =  new i32();t1:i32 =  new i32();
	if ((w) == (1)) {
_out_[0] = (byte)(_out_[1] = ((byte)((3 * in_near[0] + in_far[0] + 2) >> 2)));return _out_;}

	t1 = (i32)(3 * in_near[0] + in_far[0]);
	_out_[0] = ((byte)((t1 + 2) >> 2));
	for (i = (i32)(1); (i) < (w); ++i) {
t0 = (i32)(t1);t1 = (i32)(3 * in_near[i] + in_far[i]);_out_[i * 2 - 1] = ((byte)((3 * t0 + t1 + 8) >> 4));_out_[i * 2] = ((byte)((3 * t1 + t0 + 8) >> 4));}
	_out_[w * 2 - 1] = ((byte)((t1 + 2) >> 2));
	return _out_;
}

public static byte* stbi__resample_row_generic(byte* _out_, byte* in_near, byte* in_far, i32 w, i32 hs)
{
	i:i32 =  new i32();j:i32 =  new i32();
	for (i = (i32)(0); (i) < (w); ++i) {for (j = (i32)(0); (j) < (hs); ++j) {_out_[i * hs + j] = (byte)(in_near[i]);}}
	return _out_;
}

public static void stbi__YCbCr_to_RGB_row(byte* _out_, byte* y, byte* pcb, byte* pcr, i32 count, i32 step)
{
	i:i32 =  new i32();
	for (i = (i32)(0); (i) < (count); ++i) {
y_fixed:i32 = (i32)((y[i] << 20) + (1 << 19));r:i32 =  new i32();g:i32 =  new i32();b:i32 =  new i32();cr:i32 = (i32)(pcr[i] - 128);cb:i32 = (i32)(pcb[i] - 128);r = (i32)(y_fixed + cr * (((i32)((1.40200f32) * 4096.0f32 + 0.5f32)) << 8));g = (i32)(y_fixed + (cr * -(((i32)((0.71414f32) * 4096.0f32 + 0.5f32)) << 8)) + ((cb * -(((i32)((0.34414f32) * 4096.0f32 + 0.5f32)) << 8)) & 0xffff0000));b = (i32)(y_fixed + cb * (((i32)((1.77200f32) * 4096.0f32 + 0.5f32)) << 8));r >>= 20;g >>= 20;b >>= 20;if (((u32)(r)) > (255)) {
if ((r) < (0)) r = (i32)(0); else r = (i32)(255);}
if (((u32)(g)) > (255)) {
if ((g) < (0)) g = (i32)(0); else g = (i32)(255);}
if (((u32)(b)) > (255)) {
if ((b) < (0)) b = (i32)(0); else b = (i32)(255);}
_out_[0] = ((byte)(r));_out_[1] = ((byte)(g));_out_[2] = ((byte)(b));_out_[3] = (byte)(255);_out_ += step;}
}

public static void stbi__setup_jpeg(stbi__jpeg* j)
{
	j->idct_block_kernel = stbi__idct_block;
	j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;
	j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;
}

public static void stbi__cleanup_jpeg(stbi__jpeg* j)
{
	stbi__free_jpeg_components(j, (i32)(j->s->img_n), (i32)(0));
}

public static byte stbi__blinn_8x8(byte x, byte y)
{
	t:u32 = (u32)(x * y + 128);
	return (byte)((t + (t >> 8)) >> 8);
}

public static byte* load_jpeg_image(stbi__jpeg* z, i32* out_x, i32* out_y, i32* comp, i32 req_comp)
{
	n:i32 =  new i32();decode_n:i32 =  new i32();is_rgb:i32 =  new i32();
	z->s->img_n = (i32)(0);
	if (stbi__decode_jpeg_image(z)== 0) {
stbi__cleanup_jpeg(z);}

	n = (i32)((req_comp) != 0?req_comp:(z->s->img_n) >= (3)?3:1);
	is_rgb = (i32)(((z->s->img_n) == (3)) && (((z->rgb) == (3)) || (((z->app14_color_transform) == (0)) && (z->jfif== 0)))?1:0);
	if ((((z->s->img_n) == (3)) && ((n) < (3))) && (is_rgb== 0)) decode_n = (i32)(1); else decode_n = (i32)(z->s->img_n);
	{
k:i32 =  new i32();i:u32 =  new u32();j:u32 =  new u32();output:byte*;coutput:[byte;4] = stackalloc byte[4];res_comp:[stbi__resample;4] = stackalloc stbi__resample[4];for (k = (i32)(0); (k) < (decode_n); ++k) {
r:stbi__resample* = res_comp[k];z->img_comp[k].linebuf = (byte*)(stbi__malloc((ulong)(z->s->img_x + 3)));if (z->img_comp[k].linebuf== null) {
stbi__cleanup_jpeg(z);}
r->hs = (i32)(z->img_h_max / z->img_comp[k].h);r->vs = (i32)(z->img_v_max / z->img_comp[k].v);r->ystep = (i32)(r->vs >> 1);r->w_lores = (i32)((z->s->img_x + r->hs - 1) / r->hs);r->ypos = (i32)(0);r->line0 = r->line1 = z->img_comp[k].data;if (((r->hs) == (1)) && ((r->vs) == (1))) r->resample = resample_row_1; else if (((r->hs) == (1)) && ((r->vs) == (2))) r->resample = stbi__resample_row_v_2; else if (((r->hs) == (2)) && ((r->vs) == (1))) r->resample = stbi__resample_row_h_2; else if (((r->hs) == (2)) && ((r->vs) == (2))) r->resample = z->resample_row_hv_2_kernel; else r->resample = stbi__resample_row_generic;}output = (byte*)(stbi__malloc_mad3((i32)(n), (i32)(z->s->img_x), (i32)(z->s->img_y), (i32)(1)));if (output== null) {
stbi__cleanup_jpeg(z);}
for (j = (u32)(0); (j) < (z->s->img_y); ++j) {
_out_:byte* = output[n * z->s->img_x * j];for (k = (i32)(0); (k) < (decode_n); ++k) {
r:stbi__resample* = res_comp[k];y_bot:i32 = (i32)((r->ystep) >= (r->vs >> 1)?1:0);coutput[k] = r->resample(z->img_comp[k].linebuf, (y_bot) != 0?r->line1:r->line0, (y_bot) != 0?r->line0:r->line1, (i32)(r->w_lores), (i32)(r->hs));if ((++r->ystep) >= (r->vs)) {
r->ystep = (i32)(0);r->line0 = r->line1;if ((++r->ypos) < (z->img_comp[k].y)) r->line1 += z->img_comp[k].w2;}
}if ((n) >= (3)) {
y:byte* = coutput[0];if ((z->s->img_n) == (3)) {
if ((is_rgb) != 0) {
for (i = (u32)(0); (i) < (z->s->img_x); ++i) {
_out_[0] = (byte)(y[i]);_out_[1] = (byte)(coutput[1][i]);_out_[2] = (byte)(coutput[2][i]);_out_[3] = (byte)(255);_out_ += n;}}
 else {
z->YCbCr_to_RGB_kernel(_out_, y, coutput[1], coutput[2], (i32)(z->s->img_x), (i32)(n));}
}
 else if ((z->s->img_n) == (4)) {
if ((z->app14_color_transform) == (0)) {
for (i = (u32)(0); (i) < (z->s->img_x); ++i) {
m:byte = (byte)(coutput[3][i]);_out_[0] = (byte)(stbi__blinn_8x8((byte)(coutput[0][i]), (byte)(m)));_out_[1] = (byte)(stbi__blinn_8x8((byte)(coutput[1][i]), (byte)(m)));_out_[2] = (byte)(stbi__blinn_8x8((byte)(coutput[2][i]), (byte)(m)));_out_[3] = (byte)(255);_out_ += n;}}
 else if ((z->app14_color_transform) == (2)) {
z->YCbCr_to_RGB_kernel(_out_, y, coutput[1], coutput[2], (i32)(z->s->img_x), (i32)(n));for (i = (u32)(0); (i) < (z->s->img_x); ++i) {
m:byte = (byte)(coutput[3][i]);_out_[0] = (byte)(stbi__blinn_8x8((byte)(255 - _out_[0]), (byte)(m)));_out_[1] = (byte)(stbi__blinn_8x8((byte)(255 - _out_[1]), (byte)(m)));_out_[2] = (byte)(stbi__blinn_8x8((byte)(255 - _out_[2]), (byte)(m)));_out_ += n;}}
 else {
z->YCbCr_to_RGB_kernel(_out_, y, coutput[1], coutput[2], (i32)(z->s->img_x), (i32)(n));}
}
 else for (i = (u32)(0); (i) < (z->s->img_x); ++i) {
_out_[0] = (byte)(_out_[1] = (byte)(_out_[2] = (byte)(y[i])));_out_[3] = (byte)(255);_out_ += n;}}
 else {
if ((is_rgb) != 0) {
if ((n) == (1)) for (i = (u32)(0); (i) < (z->s->img_x); ++i) {_out_++ = (byte)(stbi__compute_y((i32)(coutput[0][i]), (i32)(coutput[1][i]), (i32)(coutput[2][i])));} else {
for (i = (u32)(0); (i) < (z->s->img_x); ++i , _out_ += 2) {
_out_[0] = (byte)(stbi__compute_y((i32)(coutput[0][i]), (i32)(coutput[1][i]), (i32)(coutput[2][i])));_out_[1] = (byte)(255);}}
}
 else if (((z->s->img_n) == (4)) && ((z->app14_color_transform) == (0))) {
for (i = (u32)(0); (i) < (z->s->img_x); ++i) {
m:byte = (byte)(coutput[3][i]);r:byte = (byte)(stbi__blinn_8x8((byte)(coutput[0][i]), (byte)(m)));g:byte = (byte)(stbi__blinn_8x8((byte)(coutput[1][i]), (byte)(m)));b:byte = (byte)(stbi__blinn_8x8((byte)(coutput[2][i]), (byte)(m)));_out_[0] = (byte)(stbi__compute_y((i32)(r), (i32)(g), (i32)(b)));_out_[1] = (byte)(255);_out_ += n;}}
 else if (((z->s->img_n) == (4)) && ((z->app14_color_transform) == (2))) {
for (i = (u32)(0); (i) < (z->s->img_x); ++i) {
_out_[0] = (byte)(stbi__blinn_8x8((byte)(255 - coutput[0][i]), (byte)(coutput[3][i])));_out_[1] = (byte)(255);_out_ += n;}}
 else {
y:byte* = coutput[0];if ((n) == (1)) for (i = (u32)(0); (i) < (z->s->img_x); ++i) {_out_[i] = (byte)(y[i]);} else for (i = (u32)(0); (i) < (z->s->img_x); ++i) {_out_++ = (byte)(y[i]);_out_++ = (byte)(255);}}
}
}stbi__cleanup_jpeg(z);out_x = (i32)(z->s->img_x);out_y = (i32)(z->s->img_y);if ((comp) != null) comp = (i32)((z->s->img_n) >= (3)?3:1);return output;}

}

public static void * stbi__jpeg_load(stbi__context* s, i32* x, i32* y, i32* comp, i32 req_comp, stbi__result_info* ri)
{
	result:byte*;
	j:stbi__jpeg* = (stbi__jpeg*)(stbi__malloc((ulong)(sizeof(stbi__jpeg))));
	j->s = s;
	stbi__setup_jpeg(j);
	result = load_jpeg_image(j, x, y, comp, (i32)(req_comp));
	
	return result;
}

public static i32 stbi__jpeg_test(stbi__context* s)
{
	r:i32 =  new i32();
	j:stbi__jpeg* = (stbi__jpeg*)(stbi__malloc((ulong)(sizeof(stbi__jpeg))));
	j->s = s;
	stbi__setup_jpeg(j);
	r = (i32)(stbi__decode_jpeg_header(j, (i32)(STBI__SCAN_type)));
	stbi__rewind(s);
	
	return (i32)(r);
}

public static i32 stbi__jpeg_info_raw(stbi__jpeg* j, i32* x, i32* y, i32* comp)
{
	if (stbi__decode_jpeg_header(j, (i32)(STBI__SCAN_header))== 0) {
stbi__rewind(j->s);return (i32)(0);}

	if ((x) != null) x = (i32)(j->s->img_x);
	if ((y) != null) y = (i32)(j->s->img_y);
	if ((comp) != null) comp = (i32)((j->s->img_n) >= (3)?3:1);
	return (i32)(1);
}

public static i32 stbi__jpeg_info(stbi__context* s, i32* x, i32* y, i32* comp)
{
	result:i32 =  new i32();
	j:stbi__jpeg* = (stbi__jpeg*)(stbi__malloc((ulong)(sizeof(stbi__jpeg))));
	j->s = s;
	result = (i32)(stbi__jpeg_info_raw(j, x, y, comp));
	
	return (i32)(result);
}

public static i32 stbi__bitreverse16(i32 n)
{
	n = (i32)(((n & 0xAAAA) >> 1) | ((n & 0x5555) << 1));
	n = (i32)(((n & 0xCCCC) >> 2) | ((n & 0x3333) << 2));
	n = (i32)(((n & 0xF0F0) >> 4) | ((n & 0x0F0F) << 4));
	n = (i32)(((n & 0xFF00) >> 8) | ((n & 0x00FF) << 8));
	return (i32)(n);
}

public static i32 stbi__bit_reverse(i32 v, i32 bits)
{
	return (i32)(stbi__bitreverse16((i32)(v)) >> (16 - bits));
}

public static i32 stbi__zbuild_huffman(stbi__zhuffman* z, byte* sizelist, i32 num)
{
	i:i32 =  new i32();k:i32 = (i32)(0);
	code:i32 =  new i32();next_code:[i32;16] = stackalloc i32[16];sizes:[i32;17] = stackalloc i32[17];
	CRuntime.memset(sizes, (i32)(0), (ulong)(sizeof(int)));
	CRuntime.memset(z->fast, (i32)(0), (ulong)(sizeof((z->fast))));
	for (i = (i32)(0); (i) < (num); ++i) {++sizes[sizelist[i]];}
	sizes[0] = (i32)(0);
	for (i = (i32)(1); (i) < (16); ++i) {if ((sizes[i]) > (1 << i)) return (i32)(stbi__err("bad sizes"));}
	code = (i32)(0);
	for (i = (i32)(1); (i) < (16); ++i) {
next_code[i] = (i32)(code);z->firstcode[i] = ((ushort)(code));z->firstsymbol[i] = ((ushort)(k));code = (i32)(code + sizes[i]);if ((sizes[i]) != 0) if ((code - 1) >= (1 << i)) return (i32)(stbi__err("bad codelengths"));z->maxcode[i] = (i32)(code << (16 - i));code <<= 1;k += (i32)(sizes[i]);}
	z->maxcode[16] = (i32)(0x10000);
	for (i = (i32)(0); (i) < (num); ++i) {
s:i32 = (i32)(sizelist[i]);if ((s) != 0) {
c:i32 = (i32)(next_code[s] - z->firstcode[s] + z->firstsymbol[s]);fastv:ushort = (ushort)((s << 9) | i);z->size[c] = ((byte)(s));z->value[c] = ((ushort)(i));if (s <= 9) {
j:i32 = (i32)(stbi__bit_reverse((i32)(next_code[s]), (i32)(s)));while ((j) < (1 << 9)) {
z->fast[j] = (ushort)(fastv);j += (i32)(1 << s);}}
++next_code[s];}
}
	return (i32)(1);
}

public static byte stbi__zget8(stbi__zbuf* z)
{
	if ((z->zbuffer) >= (z->zbuffer_end)) return (byte)(0);
	return (byte)(z->zbuffer++);
}

public static void stbi__fill_bits(stbi__zbuf* z)
{
	do {
z->code_buffer |= (u32)((u32)(stbi__zget8(z)) << z->num_bits);z->num_bits += (i32)(8);}
 while (z->num_bits <= 24);
}

public static u32 stbi__zreceive(stbi__zbuf* z, i32 n)
{
	k:u32 =  new u32();
	if ((z->num_bits) < (n)) stbi__fill_bits(z);
	k = (u32)(z->code_buffer & ((1 << n) - 1));
	z->code_buffer >>= n;
	z->num_bits -= (i32)(n);
	return (u32)(k);
}

public static i32 stbi__zhuffman_decode_slowpath(stbi__zbuf* a, stbi__zhuffman* z)
{
	b:i32 =  new i32();s:i32 =  new i32();k:i32 =  new i32();
	k = (i32)(stbi__bit_reverse((i32)(a->code_buffer), (i32)(16)));
	for (s = (i32)(9 + 1); ; ++s) {if ((k) < (z->maxcode[s])) break;}
	if ((s) == (16)) return (i32)(-1);
	b = (i32)((k >> (16 - s)) - z->firstcode[s] + z->firstsymbol[s]);
	a->code_buffer >>= s;
	a->num_bits -= (i32)(s);
	return (i32)(z->value[b]);
}

public static i32 stbi__zhuffman_decode(stbi__zbuf* a, stbi__zhuffman* z)
{
	b:i32 =  new i32();s:i32 =  new i32();
	if ((a->num_bits) < (16)) stbi__fill_bits(a);
	b = (i32)(z->fast[a->code_buffer & ((1 << 9) - 1)]);
	if ((b) != 0) {
s = (i32)(b >> 9);a->code_buffer >>= s;a->num_bits -= (i32)(s);return (i32)(b & 511);}

	return (i32)(stbi__zhuffman_decode_slowpath(a, z));
}

public static i32 stbi__zexpand(stbi__zbuf* z, sbyte* zout, i32 n)
{
	q:sbyte*;
	cur:i32 =  new i32();limit:i32 =  new i32();old_limit:i32 =  new i32();
	z->zout = zout;
	if (z->z_expandable== 0) return (i32)(stbi__err("output buffer limit"));
	cur = ((i32)(z->zout - z->zout_start));
	limit = (i32)(old_limit = ((i32)(z->zout_end - z->zout_start)));
	while ((cur + n) > (limit)) {limit *= (i32)(2);}
	q = (sbyte*)(CRuntime.realloc(z->zout_start, (ulong)(limit)));
	if (() != 0) return (i32)(stbi__err("outofmem"));
	z->zout_start = q;
	z->zout = q[cur];
	z->zout_end = q[limit];
	return (i32)(1);
}

public static i32 stbi__parse_huffman_block(stbi__zbuf* a)
{
	zout:sbyte* = a->zout;
	for (; ; ) {
z:i32 = (i32)(stbi__zhuffman_decode(a, a->z_length));if ((z) < (256)) {
if ((z) < (0)) return (i32)(stbi__err("bad huffman code"));if ((zout) >= (a->zout_end)) {
if (stbi__zexpand(a, zout, (i32)(1))== 0) return (i32)(0);zout = a->zout;}
zout++ = ((sbyte)(z));}
 else {
p:byte*;len:i32 =  new i32();dist:i32 =  new i32();if ((z) == (256)) {
a->zout = zout;return (i32)(1);}
z -= (i32)(257);len = (i32)(stbi__zlength_base[z]);if ((stbi__zlength_extra[z]) != 0) len += (i32)(stbi__zreceive(a, (i32)(stbi__zlength_extra[z])));z = (i32)(stbi__zhuffman_decode(a, a->z_distance));if ((z) < (0)) return (i32)(stbi__err("bad huffman code"));dist = (i32)(stbi__zdist_base[z]);if ((stbi__zdist_extra[z]) != 0) dist += (i32)(stbi__zreceive(a, (i32)(stbi__zdist_extra[z])));if ((zout - a->zout_start) < (dist)) return (i32)(stbi__err("bad dist"));if ((zout[len]) > (a->zout_end)) {
if (stbi__zexpand(a, zout, (i32)(len))== 0) return (i32)(0);zout = a->zout;}
p = (byte*)(zout - dist);if ((dist) == (1)) {
v:byte = (byte)(p);if ((len) != 0) {
do zout++ = (sbyte)(v); while ((--len) != 0);}
}
 else {
if ((len) != 0) {
do zout++ = (sbyte)(p++); while ((--len) != 0);}
}
}
}
}

public static i32 stbi__compute_huffman_codes(stbi__zbuf* a)
{
	z_codelength:stbi__zhuffman =  new stbi__zhuffman();
	lencodes:[byte;455] = stackalloc byte[286 + 32 + 137];
	codelength_sizes:[byte;19] = stackalloc byte[19];
	i:i32 =  new i32();n:i32 =  new i32();
	hlit:i32 = (i32)(stbi__zreceive(a, (i32)(5)) + 257);
	hdist:i32 = (i32)(stbi__zreceive(a, (i32)(5)) + 1);
	hclen:i32 = (i32)(stbi__zreceive(a, (i32)(4)) + 4);
	ntot:i32 = (i32)(hlit + hdist);
	CRuntime.memset(codelength_sizes, (i32)(0), (ulong)(sizeof((codelength_sizes))));
	for (i = (i32)(0); (i) < (hclen); ++i) {
s:i32 = (i32)(stbi__zreceive(a, (i32)(3)));codelength_sizes[length_dezigzag[i]] = ((byte)(s));}
	if (stbi__zbuild_huffman(z_codelength, codelength_sizes, (i32)(19))== 0) return (i32)(0);
	n = (i32)(0);
	while ((n) < (ntot)) {
c:i32 = (i32)(stbi__zhuffman_decode(a, z_codelength));if (((c) < (0)) || ((c) >= (19))) return (i32)(stbi__err("bad codelengths"));if ((c) < (16)) lencodes[n++] = ((byte)(c)); else {
fill:byte = (byte)(0);if ((c) == (16)) {
c = (i32)(stbi__zreceive(a, (i32)(2)) + 3);if ((n) == (0)) return (i32)(stbi__err("bad codelengths"));fill = (byte)(lencodes[n - 1]);}
 else if ((c) == (17)) c = (i32)(stbi__zreceive(a, (i32)(3)) + 3); else {
c = (i32)(stbi__zreceive(a, (i32)(7)) + 11);}
if ((ntot - n) < (c)) return (i32)(stbi__err("bad codelengths"));CRuntime.memset(lencodes[n], (i32)(fill), (ulong)(c));n += (i32)(c);}
}
	if (n != ntot) return (i32)(stbi__err("bad codelengths"));
	if (stbi__zbuild_huffman(a->z_length, lencodes, (i32)(hlit))== 0) return (i32)(0);
	if (stbi__zbuild_huffman(a->z_distance, lencodes[hlit], (i32)(hdist))== 0) return (i32)(0);
	return (i32)(1);
}

public static i32 stbi__parse_uncompressed_block(stbi__zbuf* a)
{
	header:[byte;4] = stackalloc byte[4];
	len:i32 =  new i32();nlen:i32 =  new i32();k:i32 =  new i32();
	if ((a->num_bits & 7) != 0) stbi__zreceive(a, (i32)(a->num_bits & 7));
	k = (i32)(0);
	while ((a->num_bits) > (0)) {
header[k++] = ((byte)(a->code_buffer & 255));a->code_buffer >>= 8;a->num_bits -= (i32)(8);}
	while ((k) < (4)) {header[k++] = (byte)(stbi__zget8(a));}
	len = (i32)(header[1] * 256 + header[0]);
	nlen = (i32)(header[3] * 256 + header[2]);
	if (nlen != (len ^ 0xffff)) return (i32)(stbi__err("zlib corrupt"));
	if ((a->zbuffer[len]) > (a->zbuffer_end)) return (i32)(stbi__err("read past buffer"));
	if ((a->zout[len]) > (a->zout_end)) if (stbi__zexpand(a, a->zout, (i32)(len))== 0) return (i32)(0);
	CRuntime.memcpy(a->zout, a->zbuffer, (ulong)(len));
	a->zbuffer += len;
	a->zout += len;
	return (i32)(1);
}

public static i32 stbi__parse_zlib_header(stbi__zbuf* a)
{
	cmf:i32 = (i32)(stbi__zget8(a));
	cm:i32 = (i32)(cmf & 15);
	flg:i32 = (i32)(stbi__zget8(a));
	if ((cmf * 256 + flg) % 31 != 0) return (i32)(stbi__err("bad zlib header"));
	if ((flg & 32) != 0) return (i32)(stbi__err("no preset dict"));
	if (cm != 8) return (i32)(stbi__err("bad compression"));
	return (i32)(1);
}

public static i32 stbi__parse_zlib(stbi__zbuf* a, i32 parse_header)
{
	final:i32 =  new i32();type:i32 =  new i32();
	if ((parse_header) != 0) if (stbi__parse_zlib_header(a)== 0) return (i32)(0);
	a->num_bits = (i32)(0);
	a->code_buffer = (u32)(0);
	do {
final = (i32)(stbi__zreceive(a, (i32)(1)));type = (i32)(stbi__zreceive(a, (i32)(2)));if ((type) == (0)) {
if (stbi__parse_uncompressed_block(a)== 0) return (i32)(0);}
 else if ((type) == (3)) {
return (i32)(0);}
 else {
if ((type) == (1)) {
if (stbi__zbuild_huffman(a->z_length, stbi__zdefault_length, (i32)(288))== 0) return (i32)(0);if (stbi__zbuild_huffman(a->z_distance, stbi__zdefault_distance, (i32)(32))== 0) return (i32)(0);}
 else {
if (stbi__compute_huffman_codes(a)== 0) return (i32)(0);}
if (stbi__parse_huffman_block(a)== 0) return (i32)(0);}
}
 while (final== 0);
	return (i32)(1);
}

public static i32 stbi__do_zlib(stbi__zbuf* a, sbyte* obuf, i32 olen, i32 exp, i32 parse_header)
{
	a->zout_start = obuf;
	a->zout = obuf;
	a->zout_end = obuf[olen];
	a->z_expandable = (i32)(exp);
	return (i32)(stbi__parse_zlib(a, (i32)(parse_header)));
}

public static sbyte* stbi_zlib_decode_malloc_guesssize(sbyte* buffer, i32 len, i32 initial_size, i32* outlen)
{
	a:stbi__zbuf =  new stbi__zbuf();
	p:sbyte* = (sbyte*)(stbi__malloc((ulong)(initial_size)));
	a.zbuffer = (byte*)(buffer);
	a.zbuffer_end = (byte*)(buffer)[len];
	if ((stbi__do_zlib(a, p, (i32)(initial_size), (i32)(1), (i32)(1))) != 0) {
if ((outlen) != null) outlen = ((i32)(a.zout - a.zout_start));return a.zout_start;}
 else {
CRuntime.free(a.zout_start);}

}

public static sbyte* stbi_zlib_decode_malloc(sbyte* buffer, i32 len, i32* outlen)
{
	return stbi_zlib_decode_malloc_guesssize(buffer, (i32)(len), (i32)(16384), outlen);
}

public static sbyte* stbi_zlib_decode_malloc_guesssize_headerflag(sbyte* buffer, i32 len, i32 initial_size, i32* outlen, i32 parse_header)
{
	a:stbi__zbuf =  new stbi__zbuf();
	p:sbyte* = (sbyte*)(stbi__malloc((ulong)(initial_size)));
	a.zbuffer = (byte*)(buffer);
	a.zbuffer_end = (byte*)(buffer)[len];
	if ((stbi__do_zlib(a, p, (i32)(initial_size), (i32)(1), (i32)(parse_header))) != 0) {
if ((outlen) != null) outlen = ((i32)(a.zout - a.zout_start));return a.zout_start;}
 else {
CRuntime.free(a.zout_start);}

}

public static i32 stbi_zlib_decode_buffer(sbyte* obuffer, i32 olen, sbyte* ibuffer, i32 ilen)
{
	a:stbi__zbuf =  new stbi__zbuf();
	a.zbuffer = (byte*)(ibuffer);
	a.zbuffer_end = (byte*)(ibuffer)[ilen];
	if ((stbi__do_zlib(a, obuffer, (i32)(olen), (i32)(0), (i32)(1))) != 0) return (i32)(a.zout - a.zout_start); else return (i32)(-1);
}

public static sbyte* stbi_zlib_decode_noheader_malloc(sbyte* buffer, i32 len, i32* outlen)
{
	a:stbi__zbuf =  new stbi__zbuf();
	p:sbyte* = (sbyte*)(stbi__malloc((ulong)(16384)));
	a.zbuffer = (byte*)(buffer);
	a.zbuffer_end = (byte*)(buffer)[len];
	if ((stbi__do_zlib(a, p, (i32)(16384), (i32)(1), (i32)(0))) != 0) {
if ((outlen) != null) outlen = ((i32)(a.zout - a.zout_start));return a.zout_start;}
 else {
CRuntime.free(a.zout_start);}

}

public static i32 stbi_zlib_decode_noheader_buffer(sbyte* obuffer, i32 olen, sbyte* ibuffer, i32 ilen)
{
	a:stbi__zbuf =  new stbi__zbuf();
	a.zbuffer = (byte*)(ibuffer);
	a.zbuffer_end = (byte*)(ibuffer)[ilen];
	if ((stbi__do_zlib(a, obuffer, (i32)(olen), (i32)(0), (i32)(0))) != 0) return (i32)(a.zout - a.zout_start); else return (i32)(-1);
}

public static stbi__pngchunk stbi__get_chunk_header(stbi__context* s)
{
	c:stbi__pngchunk =  new stbi__pngchunk();
	c.length = (u32)(stbi__get32be(s));
	c.type = (u32)(stbi__get32be(s));
	return (stbi__pngchunk)(c);
}

public static i32 stbi__check_png_header(stbi__context* s)
{
	i:i32 =  new i32();
	for (i = (i32)(0); (i) < (8); ++i) {if (stbi__get8(s) != png_sig[i]) return (i32)(stbi__err("bad png sig"));}
	return (i32)(1);
}

public static i32 stbi__paeth(i32 a, i32 b, i32 c)
{
	p:i32 = (i32)(a + b - c);
	pa:i32 = (i32)(CRuntime.abs((i32)(p - a)));
	pb:i32 = (i32)(CRuntime.abs((i32)(p - b)));
	pc:i32 = (i32)(CRuntime.abs((i32)(p - c)));
	if ((pa <= pb) && (pa <= pc)) return (i32)(a);
	if (pb <= pc) return (i32)(b);
	return (i32)(c);
}

public static i32 stbi__create_png_image_raw(stbi__png* a, byte* raw, u32 raw_len, i32 out_n, u32 x, u32 y, i32 depth, i32 color)
{
	bytes:i32 = (i32)((depth) == (16)?2:1);
	s:stbi__context* = a->s;
	i:u32 =  new u32();j:u32 =  new u32();stride:u32 = (u32)(x * out_n * bytes);
	img_len:u32 =  new u32();img_width_bytes:u32 =  new u32();
	k:i32 =  new i32();
	img_n:i32 = (i32)(s->img_n);
	output_bytes:i32 = (i32)(out_n * bytes);
	filter_bytes:i32 = (i32)(img_n * bytes);
	width:i32 = (i32)(x);
	a->_out_ = (byte*)(stbi__malloc_mad3((i32)(x), (i32)(y), (i32)(output_bytes), (i32)(0)));
	if (a->_out_== null) return (i32)(stbi__err("outofmem"));
	img_width_bytes = (u32)(((img_n * x * depth) + 7) >> 3);
	img_len = (u32)((img_width_bytes + 1) * y);
	if ((raw_len) < (img_len)) return (i32)(stbi__err("not enough pixels"));
	for (j = (u32)(0); (j) < (y); ++j) {
cur:byte* = a->_out_[stride * j];prior:byte*;filter:i32 = (i32)(raw++);if ((filter) > (4)) return (i32)(stbi__err("invalid filter"));if ((depth) < (8)) {
cur += x * out_n - img_width_bytes;filter_bytes = (i32)(1);width = (i32)(img_width_bytes);}
prior = cur - stride;if ((j) == (0)) filter = (i32)(first_row_filter[filter]);for (k = (i32)(0); (k) < (filter_bytes); ++k) {
switch (filter){
case STBI__F_none:cur[k] = (byte)(raw[k]);break;case STBI__F_sub:cur[k] = (byte)(raw[k]);break;case STBI__F_up:cur[k] = ((byte)((raw[k] + prior[k]) & 255));break;case STBI__F_avg:cur[k] = ((byte)((raw[k] + (prior[k] >> 1)) & 255));break;case STBI__F_paeth:cur[k] = ((byte)((raw[k] + stbi__paeth((i32)(0), (i32)(prior[k]), (i32)(0))) & 255));break;case STBI__F_avg_first:cur[k] = (byte)(raw[k]);break;case STBI__F_paeth_first:cur[k] = (byte)(raw[k]);break;}
}if ((depth) == (8)) {
if (img_n != out_n) cur[img_n] = (byte)(255);raw += img_n;cur += out_n;prior += out_n;}
 else if ((depth) == (16)) {
if (img_n != out_n) {
cur[filter_bytes] = (byte)(255);cur[filter_bytes + 1] = (byte)(255);}
raw += filter_bytes;cur += output_bytes;prior += output_bytes;}
 else {
raw += 1;cur += 1;prior += 1;}
if (((depth) < (8)) || ((img_n) == (out_n))) {
nk:i32 = (i32)((width - 1) * filter_bytes);switch (filter){
case STBI__F_none:CRuntime.memcpy(cur, raw, (ulong)(nk));break;case STBI__F_sub:for (k = (i32)(0); (k) < (nk); ++k) {
cur[k] = ((byte)((raw[k] + cur[k - filter_bytes]) & 255));}break;case STBI__F_up:for (k = (i32)(0); (k) < (nk); ++k) {
cur[k] = ((byte)((raw[k] + prior[k]) & 255));}break;case STBI__F_avg:for (k = (i32)(0); (k) < (nk); ++k) {
cur[k] = ((byte)((raw[k] + ((prior[k] + cur[k - filter_bytes]) >> 1)) & 255));}break;case STBI__F_paeth:for (k = (i32)(0); (k) < (nk); ++k) {
cur[k] = ((byte)((raw[k] + stbi__paeth((i32)(cur[k - filter_bytes]), (i32)(prior[k]), (i32)(prior[k - filter_bytes]))) & 255));}break;case STBI__F_avg_first:for (k = (i32)(0); (k) < (nk); ++k) {
cur[k] = ((byte)((raw[k] + (cur[k - filter_bytes] >> 1)) & 255));}break;case STBI__F_paeth_first:for (k = (i32)(0); (k) < (nk); ++k) {
cur[k] = ((byte)((raw[k] + stbi__paeth((i32)(cur[k - filter_bytes]), (i32)(0), (i32)(0))) & 255));}break;}
raw += nk;}
 else {
switch (filter){
case STBI__F_none:for (i = (u32)(x - 1); (i) >= (1); --i , cur[filter_bytes] = (byte)(255) , raw += filter_bytes , cur += output_bytes , prior += output_bytes) {for (k = (i32)(0); (k) < (filter_bytes); ++k) {
cur[k] = (byte)(raw[k]);}}break;case STBI__F_sub:for (i = (u32)(x - 1); (i) >= (1); --i , cur[filter_bytes] = (byte)(255) , raw += filter_bytes , cur += output_bytes , prior += output_bytes) {for (k = (i32)(0); (k) < (filter_bytes); ++k) {
cur[k] = ((byte)((raw[k] + cur[k - output_bytes]) & 255));}}break;case STBI__F_up:for (i = (u32)(x - 1); (i) >= (1); --i , cur[filter_bytes] = (byte)(255) , raw += filter_bytes , cur += output_bytes , prior += output_bytes) {for (k = (i32)(0); (k) < (filter_bytes); ++k) {
cur[k] = ((byte)((raw[k] + prior[k]) & 255));}}break;case STBI__F_avg:for (i = (u32)(x - 1); (i) >= (1); --i , cur[filter_bytes] = (byte)(255) , raw += filter_bytes , cur += output_bytes , prior += output_bytes) {for (k = (i32)(0); (k) < (filter_bytes); ++k) {
cur[k] = ((byte)((raw[k] + ((prior[k] + cur[k - output_bytes]) >> 1)) & 255));}}break;case STBI__F_paeth:for (i = (u32)(x - 1); (i) >= (1); --i , cur[filter_bytes] = (byte)(255) , raw += filter_bytes , cur += output_bytes , prior += output_bytes) {for (k = (i32)(0); (k) < (filter_bytes); ++k) {
cur[k] = ((byte)((raw[k] + stbi__paeth((i32)(cur[k - output_bytes]), (i32)(prior[k]), (i32)(prior[k - output_bytes]))) & 255));}}break;case STBI__F_avg_first:for (i = (u32)(x - 1); (i) >= (1); --i , cur[filter_bytes] = (byte)(255) , raw += filter_bytes , cur += output_bytes , prior += output_bytes) {for (k = (i32)(0); (k) < (filter_bytes); ++k) {
cur[k] = ((byte)((raw[k] + (cur[k - output_bytes] >> 1)) & 255));}}break;case STBI__F_paeth_first:for (i = (u32)(x - 1); (i) >= (1); --i , cur[filter_bytes] = (byte)(255) , raw += filter_bytes , cur += output_bytes , prior += output_bytes) {for (k = (i32)(0); (k) < (filter_bytes); ++k) {
cur[k] = ((byte)((raw[k] + stbi__paeth((i32)(cur[k - output_bytes]), (i32)(0), (i32)(0))) & 255));}}break;}
if ((depth) == (16)) {
cur = a->_out_[stride * j];for (i = (u32)(0); (i) < (x); ++i , cur += output_bytes) {
cur[filter_bytes + 1] = (byte)(255);}}
}
}
	if ((depth) < (8)) {
for (j = (u32)(0); (j) < (y); ++j) {
cur:byte* = a->_out_[stride * j];_in_:byte* = a->_out_[stride * j][x * out_n] - img_width_bytes;scale:byte = (byte)(((color) == (0))?stbi__depth_scale_table[depth]:1);if ((depth) == (4)) {
for (k = (i32)(x * img_n); (k) >= (2); k -= (i32)(2) , ++_in_) {
cur++ = (byte)(scale * (_in_ >> 4));cur++ = (byte)(scale * ((_in_) & 0x0f));}if ((k) > (0)) cur++ = (byte)(scale * (_in_ >> 4));}
 else if ((depth) == (2)) {
for (k = (i32)(x * img_n); (k) >= (4); k -= (i32)(4) , ++_in_) {
cur++ = (byte)(scale * (_in_ >> 6));cur++ = (byte)(scale * ((_in_ >> 4) & 0x03));cur++ = (byte)(scale * ((_in_ >> 2) & 0x03));cur++ = (byte)(scale * ((_in_) & 0x03));}if ((k) > (0)) cur++ = (byte)(scale * (_in_ >> 6));if ((k) > (1)) cur++ = (byte)(scale * ((_in_ >> 4) & 0x03));if ((k) > (2)) cur++ = (byte)(scale * ((_in_ >> 2) & 0x03));}
 else if ((depth) == (1)) {
for (k = (i32)(x * img_n); (k) >= (8); k -= (i32)(8) , ++_in_) {
cur++ = (byte)(scale * (_in_ >> 7));cur++ = (byte)(scale * ((_in_ >> 6) & 0x01));cur++ = (byte)(scale * ((_in_ >> 5) & 0x01));cur++ = (byte)(scale * ((_in_ >> 4) & 0x01));cur++ = (byte)(scale * ((_in_ >> 3) & 0x01));cur++ = (byte)(scale * ((_in_ >> 2) & 0x01));cur++ = (byte)(scale * ((_in_ >> 1) & 0x01));cur++ = (byte)(scale * ((_in_) & 0x01));}if ((k) > (0)) cur++ = (byte)(scale * (_in_ >> 7));if ((k) > (1)) cur++ = (byte)(scale * ((_in_ >> 6) & 0x01));if ((k) > (2)) cur++ = (byte)(scale * ((_in_ >> 5) & 0x01));if ((k) > (3)) cur++ = (byte)(scale * ((_in_ >> 4) & 0x01));if ((k) > (4)) cur++ = (byte)(scale * ((_in_ >> 3) & 0x01));if ((k) > (5)) cur++ = (byte)(scale * ((_in_ >> 2) & 0x01));if ((k) > (6)) cur++ = (byte)(scale * ((_in_ >> 1) & 0x01));}
if (img_n != out_n) {
q:i32 =  new i32();cur = a->_out_[stride * j];if ((img_n) == (1)) {
for (q = (i32)(x - 1); (q) >= (0); --q) {
cur[q * 2 + 1] = (byte)(255);cur[q * 2 + 0] = (byte)(cur[q]);}}
 else {
for (q = (i32)(x - 1); (q) >= (0); --q) {
cur[q * 4 + 3] = (byte)(255);cur[q * 4 + 2] = (byte)(cur[q * 3 + 2]);cur[q * 4 + 1] = (byte)(cur[q * 3 + 1]);cur[q * 4 + 0] = (byte)(cur[q * 3 + 0]);}}
}
}}
 else if ((depth) == (16)) {
cur:byte* = a->_out_;cur16:ushort* = (ushort*)(cur);for (i = (u32)(0); (i) < (x * y * out_n); ++i , cur16++ , cur += 2) {
cur16 = (ushort)((cur[0] << 8) | cur[1]);}}

	return (i32)(1);
}

public static i32 stbi__create_png_image(stbi__png* a, byte* image_data, u32 image_data_len, i32 out_n, i32 depth, i32 color, i32 interlaced)
{
	bytes:i32 = (i32)((depth) == (16)?2:1);
	out_bytes:i32 = (i32)(out_n * bytes);
	final:byte*;
	p:i32 =  new i32();
	if (interlaced== 0) return (i32)(stbi__create_png_image_raw(a, image_data, (u32)(image_data_len), (i32)(out_n), (u32)(a->s->img_x), (u32)(a->s->img_y), (i32)(depth), (i32)(color)));
	final = (byte*)(stbi__malloc_mad3((i32)(a->s->img_x), (i32)(a->s->img_y), (i32)(out_bytes), (i32)(0)));
	for (p = (i32)(0); (p) < (7); ++p) {
xorig:[i32;7] = stackalloc i32[7];
xorig[0] = (i32)(0);
xorig[1] = (i32)(4);
xorig[2] = (i32)(0);
xorig[3] = (i32)(2);
xorig[4] = (i32)(0);
xorig[5] = (i32)(1);
xorig[6] = (i32)(0);
yorig:[i32;7] = stackalloc i32[7];
yorig[0] = (i32)(0);
yorig[1] = (i32)(0);
yorig[2] = (i32)(4);
yorig[3] = (i32)(0);
yorig[4] = (i32)(2);
yorig[5] = (i32)(0);
yorig[6] = (i32)(1);
xspc:[i32;7] = stackalloc i32[7];
xspc[0] = (i32)(8);
xspc[1] = (i32)(8);
xspc[2] = (i32)(4);
xspc[3] = (i32)(4);
xspc[4] = (i32)(2);
xspc[5] = (i32)(2);
xspc[6] = (i32)(1);
yspc:[i32;7] = stackalloc i32[7];
yspc[0] = (i32)(8);
yspc[1] = (i32)(8);
yspc[2] = (i32)(8);
yspc[3] = (i32)(4);
yspc[4] = (i32)(4);
yspc[5] = (i32)(2);
yspc[6] = (i32)(2);
i:i32 =  new i32();j:i32 =  new i32();x:i32 =  new i32();y:i32 =  new i32();x = (i32)((a->s->img_x - xorig[p] + xspc[p] - 1) / xspc[p]);y = (i32)((a->s->img_y - yorig[p] + yspc[p] - 1) / yspc[p]);if (((x) != 0) && ((y) != 0)) {
img_len:u32 = (u32)(((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y);if (stbi__create_png_image_raw(a, image_data, (u32)(image_data_len), (i32)(out_n), (u32)(x), (u32)(y), (i32)(depth), (i32)(color))== 0) {
CRuntime.free(final);return (i32)(0);}
for (j = (i32)(0); (j) < (y); ++j) {
for (i = (i32)(0); (i) < (x); ++i) {
out_y:i32 = (i32)(j * yspc[p] + yorig[p]);out_x:i32 = (i32)(i * xspc[p] + xorig[p]);CRuntime.memcpy(final[out_y * a->s->img_x * out_bytes][out_x * out_bytes], a->_out_[(j * x + i) * out_bytes], (ulong)(out_bytes));}}CRuntime.free(a->_out_);image_data += img_len;image_data_len -= (u32)(img_len);}
}
	a->_out_ = final;
	return (i32)(1);
}

public static i32 stbi__compute_transparency(stbi__png* z, byte* tc, i32 out_n)
{
	s:stbi__context* = z->s;
	i:u32 =  new u32();pixel_count:u32 = (u32)(s->img_x * s->img_y);
	p:byte* = z->_out_;
	if ((out_n) == (2)) {
for (i = (u32)(0); (i) < (pixel_count); ++i) {
p[1] = (byte)((p[0]) == (tc[0])?0:255);p += 2;}}
 else {
for (i = (u32)(0); (i) < (pixel_count); ++i) {
if ((((p[0]) == (tc[0])) && ((p[1]) == (tc[1]))) && ((p[2]) == (tc[2]))) p[3] = (byte)(0);p += 4;}}

	return (i32)(1);
}

public static i32 stbi__compute_transparency16(stbi__png* z, ushort* tc, i32 out_n)
{
	s:stbi__context* = z->s;
	i:u32 =  new u32();pixel_count:u32 = (u32)(s->img_x * s->img_y);
	p:ushort* = (ushort*)(z->_out_);
	if ((out_n) == (2)) {
for (i = (u32)(0); (i) < (pixel_count); ++i) {
p[1] = (ushort)((p[0]) == (tc[0])?0:65535);p += 2;}}
 else {
for (i = (u32)(0); (i) < (pixel_count); ++i) {
if ((((p[0]) == (tc[0])) && ((p[1]) == (tc[1]))) && ((p[2]) == (tc[2]))) p[3] = (ushort)(0);p += 4;}}

	return (i32)(1);
}

public static i32 stbi__expand_png_palette(stbi__png* a, byte* palette, i32 len, i32 pal_img_n)
{
	i:u32 =  new u32();pixel_count:u32 = (u32)(a->s->img_x * a->s->img_y);
	p:byte*;temp_out:byte*;orig:byte* = a->_out_;
	p = (byte*)(stbi__malloc_mad2((i32)(pixel_count), (i32)(pal_img_n), (i32)(0)));
	if (() != 0) return (i32)(stbi__err("outofmem"));
	temp_out = p;
	if ((pal_img_n) == (3)) {
for (i = (u32)(0); (i) < (pixel_count); ++i) {
n:i32 = (i32)(orig[i] * 4);p[0] = (byte)(palette[n]);p[1] = (byte)(palette[n + 1]);p[2] = (byte)(palette[n + 2]);p += 3;}}
 else {
for (i = (u32)(0); (i) < (pixel_count); ++i) {
n:i32 = (i32)(orig[i] * 4);p[0] = (byte)(palette[n]);p[1] = (byte)(palette[n + 1]);p[2] = (byte)(palette[n + 2]);p[3] = (byte)(palette[n + 3]);p += 4;}}

	CRuntime.free(a->_out_);
	a->_out_ = temp_out;
	return (i32)(1);
}

public static void stbi_set_unpremultiply_on_load(i32 flag_true_if_should_unpremultiply)
{
	stbi__unpremultiply_on_load = (i32)(flag_true_if_should_unpremultiply);
}

public static void stbi_convert_iphone_png_to_rgb(i32 flag_true_if_should_convert)
{
	stbi__de_iphone_flag = (i32)(flag_true_if_should_convert);
}

public static void stbi__de_iphone(stbi__png* z)
{
	s:stbi__context* = z->s;
	i:u32 =  new u32();pixel_count:u32 = (u32)(s->img_x * s->img_y);
	p:byte* = z->_out_;
	if ((s->img_out_n) == (3)) {
for (i = (u32)(0); (i) < (pixel_count); ++i) {
t:byte = (byte)(p[0]);p[0] = (byte)(p[2]);p[2] = (byte)(t);p += 3;}}
 else {
if ((stbi__unpremultiply_on_load) != 0) {
for (i = (u32)(0); (i) < (pixel_count); ++i) {
a:byte = (byte)(p[3]);t:byte = (byte)(p[0]);if ((a) != 0) {
half:byte = (byte)(a / 2);p[0] = (byte)((p[2] * 255 + half) / a);p[1] = (byte)((p[1] * 255 + half) / a);p[2] = (byte)((t * 255 + half) / a);}
 else {
p[0] = (byte)(p[2]);p[2] = (byte)(t);}
p += 4;}}
 else {
for (i = (u32)(0); (i) < (pixel_count); ++i) {
t:byte = (byte)(p[0]);p[0] = (byte)(p[2]);p[2] = (byte)(t);p += 4;}}
}

}

public static i32 stbi__parse_png_file(stbi__png* z, i32 scan, i32 req_comp)
{
	palette:[byte;1024] = stackalloc byte[1024];pal_img_n:byte = (byte)(0);
	has_trans:byte = (byte)(0);tc:[byte;3] = stackalloc byte[3];
	tc16:[ushort;3] = stackalloc ushort[3];
	ioff:u32 = (u32)(0);idata_limit:u32 = (u32)(0);i:u32 =  new u32();pal_len:u32 = (u32)(0);
	first:i32 = (i32)(1);k:i32 =  new i32();interlace:i32 = (i32)(0);color:i32 = (i32)(0);is_iphone:i32 = (i32)(0);
	s:stbi__context* = z->s;
	if (stbi__check_png_header(s)== 0) return (i32)(0);
	if ((scan) == (STBI__SCAN_type)) return (i32)(1);
	for (; ; ) {
c:stbi__pngchunk = (stbi__pngchunk)(stbi__get_chunk_header(s));switch (c.type){
case ((('C') << 24) + (('g') << 16) + (('B') << 8) + ('I')):is_iphone = (i32)(1);stbi__skip(s, (i32)(c.length));break;case ((('I') << 24) + (('H') << 16) + (('D') << 8) + ('R')):{
comp:i32 =  new i32();filter:i32 =  new i32();if (first== 0) return (i32)(stbi__err("multiple IHDR"));first = (i32)(0);if (c.length != 13) return (i32)(stbi__err("bad IHDR len"));s->img_x = (u32)(stbi__get32be(s));if ((s->img_x) > (1 << 24)) return (i32)(stbi__err("too large"));s->img_y = (u32)(stbi__get32be(s));if ((s->img_y) > (1 << 24)) return (i32)(stbi__err("too large"));z->depth = (i32)(stbi__get8(s));if (((((z->depth != 1) && (z->depth != 2)) && (z->depth != 4)) && (z->depth != 8)) && (z->depth != 16)) return (i32)(stbi__err("1/2/4/8/16-bit only"));color = (i32)(stbi__get8(s));if ((color) > (6)) return (i32)(stbi__err("bad ctype"));if (((color) == (3)) && ((z->depth) == (16))) return (i32)(stbi__err("bad ctype"));if ((color) == (3)) pal_img_n = (byte)(3); else if ((color & 1) != 0) return (i32)(stbi__err("bad ctype"));comp = (i32)(stbi__get8(s));if ((comp) != 0) return (i32)(stbi__err("bad comp method"));filter = (i32)(stbi__get8(s));if ((filter) != 0) return (i32)(stbi__err("bad filter method"));interlace = (i32)(stbi__get8(s));if ((interlace) > (1)) return (i32)(stbi__err("bad interlace method"));if ((s->img_x== 0) || (s->img_y== 0)) return (i32)(stbi__err("0-pixel image"));if (pal_img_n== 0) {
s->img_n = (i32)(((color & 2) != 0?3:1) + ((color & 4) != 0?1:0));if (((1 << 30) / s->img_x / s->img_n) < (s->img_y)) return (i32)(stbi__err("too large"));if ((scan) == (STBI__SCAN_header)) return (i32)(1);}
 else {
s->img_n = (i32)(1);if (((1 << 30) / s->img_x / 4) < (s->img_y)) return (i32)(stbi__err("too large"));}
break;}
case ((('P') << 24) + (('L') << 16) + (('T') << 8) + ('E')):{
if ((first) != 0) return (i32)(stbi__err("first not IHDR"));if ((c.length) > (256 * 3)) return (i32)(stbi__err("invalid PLTE"));pal_len = (u32)(c.length / 3);if (pal_len * 3 != c.length) return (i32)(stbi__err("invalid PLTE"));for (i = (u32)(0); (i) < (pal_len); ++i) {
palette[i * 4 + 0] = (byte)(stbi__get8(s));palette[i * 4 + 1] = (byte)(stbi__get8(s));palette[i * 4 + 2] = (byte)(stbi__get8(s));palette[i * 4 + 3] = (byte)(255);}break;}
case ((('t') << 24) + (('R') << 16) + (('N') << 8) + ('S')):{
if ((first) != 0) return (i32)(stbi__err("first not IHDR"));if ((z->idata) != null) return (i32)(stbi__err("tRNS after IDAT"));if ((pal_img_n) != 0) {
if ((scan) == (STBI__SCAN_header)) {
s->img_n = (i32)(4);return (i32)(1);}
if ((pal_len) == (0)) return (i32)(stbi__err("tRNS before PLTE"));if ((c.length) > (pal_len)) return (i32)(stbi__err("bad tRNS len"));pal_img_n = (byte)(4);for (i = (u32)(0); (i) < (c.length); ++i) {palette[i * 4 + 3] = (byte)(stbi__get8(s));}}
 else {
if ((s->img_n & 1)== 0) return (i32)(stbi__err("tRNS with alpha"));if (c.length != (u32)(s->img_n) * 2) return (i32)(stbi__err("bad tRNS len"));has_trans = (byte)(1);if ((z->depth) == (16)) {
for (k = (i32)(0); (k) < (s->img_n); ++k) {tc16[k] = ((ushort)(stbi__get16be(s)));}}
 else {
for (k = (i32)(0); (k) < (s->img_n); ++k) {tc[k] = (byte)((byte)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]);}}
}
break;}
case ((('I') << 24) + (('D') << 16) + (('A') << 8) + ('T')):{
if ((first) != 0) return (i32)(stbi__err("first not IHDR"));if (((pal_img_n) != 0) && (pal_len== 0)) return (i32)(stbi__err("no PLTE"));if ((scan) == (STBI__SCAN_header)) {
s->img_n = (i32)(pal_img_n);return (i32)(1);}
if (((i32)(ioff + c.length)) < ((i32)(ioff))) return (i32)(0);if ((ioff + c.length) > (idata_limit)) {
idata_limit_old:u32 = (u32)(idata_limit);p:byte*;if ((idata_limit) == (0)) idata_limit = (u32)((c.length) > (4096)?c.length:4096);while ((ioff + c.length) > (idata_limit)) {idata_limit *= (u32)(2);}p = (byte*)(CRuntime.realloc(z->idata, (ulong)(idata_limit)));if (() != 0) return (i32)(stbi__err("outofmem"));z->idata = p;}
if (stbi__getn(s, z->idata[ioff], (i32)(c.length))== 0) return (i32)(stbi__err("outofdata"));ioff += (u32)(c.length);break;}
case ((('I') << 24) + (('E') << 16) + (('N') << 8) + ('D')):{
raw_len:u32 =  new u32();bpl:u32 =  new u32();if ((first) != 0) return (i32)(stbi__err("first not IHDR"));if (scan != STBI__SCAN_load) return (i32)(1);if (() != 0) return (i32)(stbi__err("no IDAT"));bpl = (u32)((s->img_x * z->depth + 7) / 8);raw_len = (u32)(bpl * s->img_y * s->img_n + s->img_y);z->expanded = (byte*)(stbi_zlib_decode_malloc_guesssize_headerflag((sbyte*)(z->idata), (i32)(ioff), (i32)(raw_len), (i32*)(raw_len), (i32)(!is_iphone)));if (() != 0) return (i32)(0);CRuntime.free(z->idata);if (((((req_comp) == (s->img_n + 1)) && (req_comp != 3)) && (pal_img_n== 0)) || ((has_trans) != 0)) s->img_out_n = (i32)(s->img_n + 1); else s->img_out_n = (i32)(s->img_n);if (stbi__create_png_image(z, z->expanded, (u32)(raw_len), (i32)(s->img_out_n), (i32)(z->depth), (i32)(color), (i32)(interlace))== 0) return (i32)(0);if ((has_trans) != 0) {
if ((z->depth) == (16)) {
if (stbi__compute_transparency16(z, tc16, (i32)(s->img_out_n))== 0) return (i32)(0);}
 else {
if (stbi__compute_transparency(z, tc, (i32)(s->img_out_n))== 0) return (i32)(0);}
}
if ((((is_iphone) != 0) && ((stbi__de_iphone_flag) != 0)) && ((s->img_out_n) > (2))) stbi__de_iphone(z);if ((pal_img_n) != 0) {
s->img_n = (i32)(pal_img_n);s->img_out_n = (i32)(pal_img_n);if ((req_comp) >= (3)) s->img_out_n = (i32)(req_comp);if (stbi__expand_png_palette(z, palette, (i32)(pal_len), (i32)(s->img_out_n))== 0) return (i32)(0);}
 else if ((has_trans) != 0) {
++s->img_n;}
CRuntime.free(z->expanded);return (i32)(1);}
default: if ((first) != 0) return (i32)(stbi__err("first not IHDR"));if ((c.type & (1 << 29)) == (0)) {
invalid_chunk:[sbyte;25] = "XXXX PNG chunk not known";return (i32)(stbi__err(invalid_chunk));}
stbi__skip(s, (i32)(c.length));break;}
stbi__get32be(s);}
}

public static void * stbi__do_png(stbi__png* p, i32* x, i32* y, i32* n, i32 req_comp, stbi__result_info* ri)
{
	result:void *;
	if ((stbi__parse_png_file(p, (i32)(STBI__SCAN_load), (i32)(req_comp))) != 0) {
if ((p->depth) < (8)) ri->bits_per_channel = (i32)(8); else ri->bits_per_channel = (i32)(p->depth);result = p->_out_;if (((req_comp) != 0) && (req_comp != p->s->img_out_n)) {
if ((ri->bits_per_channel) == (8)) result = stbi__convert_format((byte*)(result), (i32)(p->s->img_out_n), (i32)(req_comp), (u32)(p->s->img_x), (u32)(p->s->img_y)); else result = stbi__convert_format16((ushort*)(result), (i32)(p->s->img_out_n), (i32)(req_comp), (u32)(p->s->img_x), (u32)(p->s->img_y));p->s->img_out_n = (i32)(req_comp);if (() != 0) return result;}
x = (i32)(p->s->img_x);y = (i32)(p->s->img_y);if ((n) != null) n = (i32)(p->s->img_n);}

	CRuntime.free(p->_out_);
	CRuntime.free(p->expanded);
	CRuntime.free(p->idata);
	return result;
}

public static void * stbi__png_load(stbi__context* s, i32* x, i32* y, i32* comp, i32 req_comp, stbi__result_info* ri)
{
	p:stbi__png =  new stbi__png();
	p.s = s;
	return stbi__do_png(p, x, y, comp, (i32)(req_comp), ri);
}

public static i32 stbi__png_test(stbi__context* s)
{
	r:i32 =  new i32();
	r = (i32)(stbi__check_png_header(s));
	stbi__rewind(s);
	return (i32)(r);
}

public static i32 stbi__png_info_raw(stbi__png* p, i32* x, i32* y, i32* comp)
{
	if (stbi__parse_png_file(p, (i32)(STBI__SCAN_header), (i32)(0))== 0) {
stbi__rewind(p->s);return (i32)(0);}

	if ((x) != null) x = (i32)(p->s->img_x);
	if ((y) != null) y = (i32)(p->s->img_y);
	if ((comp) != null) comp = (i32)(p->s->img_n);
	return (i32)(1);
}

public static i32 stbi__png_info(stbi__context* s, i32* x, i32* y, i32* comp)
{
	p:stbi__png =  new stbi__png();
	p.s = s;
	return (i32)(stbi__png_info_raw(p, x, y, comp));
}

public static i32 stbi__bmp_test_raw(stbi__context* s)
{
	r:i32 =  new i32();
	sz:i32 =  new i32();
	if (stbi__get8(s) != 'B') return (i32)(0);
	if (stbi__get8(s) != 'M') return (i32)(0);
	stbi__get32le(s);
	stbi__get16le(s);
	stbi__get16le(s);
	stbi__get32le(s);
	sz = (i32)(stbi__get32le(s));
	r = (i32)((((((sz) == (12)) || ((sz) == (40))) || ((sz) == (56))) || ((sz) == (108))) || ((sz) == (124))?1:0);
	return (i32)(r);
}

public static i32 stbi__bmp_test(stbi__context* s)
{
	r:i32 = (i32)(stbi__bmp_test_raw(s));
	stbi__rewind(s);
	return (i32)(r);
}

public static i32 stbi__high_bit(u32 z)
{
	n:i32 = (i32)(0);
	if ((z) == (0)) return (i32)(-1);
	if ((z) >= (0x10000)) {
n += (i32)(16);z >>= 16;}

	if ((z) >= (0x00100)) {
n += (i32)(8);z >>= 8;}

	if ((z) >= (0x00010)) {
n += (i32)(4);z >>= 4;}

	if ((z) >= (0x00004)) {
n += (i32)(2);z >>= 2;}

	if ((z) >= (0x00002)) {
n += (i32)(1);z >>= 1;}

	return (i32)(n);
}

public static i32 stbi__bitcount(u32 a)
{
	a = (u32)((a & 0x55555555) + ((a >> 1) & 0x55555555));
	a = (u32)((a & 0x33333333) + ((a >> 2) & 0x33333333));
	a = (u32)((a + (a >> 4)) & 0x0f0f0f0f);
	a = (u32)(a + (a >> 8));
	a = (u32)(a + (a >> 16));
	return (i32)(a & 0xff);
}

public static i32 stbi__shiftsigned(i32 v, i32 shift, i32 bits)
{
	result:i32 =  new i32();
	z:i32 = (i32)(0);
	if ((shift) < (0)) v <<= -shift; else v >>= shift;
	result = (i32)(v);
	z = (i32)(bits);
	while ((z) < (8)) {
result += (i32)(v >> z);z += (i32)(bits);}
	return (i32)(result);
}

public static void * stbi__bmp_parse_header(stbi__context* s, stbi__bmp_data* info)
{
	hsz:i32 =  new i32();
	stbi__get32le(s);
	stbi__get16le(s);
	stbi__get16le(s);
	info->offset = (i32)(stbi__get32le(s));
	info->hsz = (i32)(hsz = (i32)(stbi__get32le(s)));
	info->mr = (u32)(info->mg = (u32)(info->mb = (u32)(info->ma = (u32)(0))));
	if ((hsz) == (12)) {
s->img_x = (u32)(stbi__get16le(s));s->img_y = (u32)(stbi__get16le(s));}
 else {
s->img_x = (u32)(stbi__get32le(s));s->img_y = (u32)(stbi__get32le(s));}

	info->bpp = (i32)(stbi__get16le(s));
	if (hsz != 12) {
compress:i32 = (i32)(stbi__get32le(s));stbi__get32le(s);stbi__get32le(s);stbi__get32le(s);stbi__get32le(s);stbi__get32le(s);if (((hsz) == (40)) || ((hsz) == (56))) {
if ((hsz) == (56)) {
stbi__get32le(s);stbi__get32le(s);stbi__get32le(s);stbi__get32le(s);}
if (((info->bpp) == (16)) || ((info->bpp) == (32))) {
if ((compress) == (0)) {
if ((info->bpp) == (32)) {
info->mr = (u32)(0xffu << 16);info->mg = (u32)(0xffu << 8);info->mb = (u32)(0xffu << 0);info->ma = (u32)(0xffu << 24);info->all_a = (u32)(0);}
 else {
info->mr = (u32)(31u << 10);info->mg = (u32)(31u << 5);info->mb = (u32)(31u << 0);}
}
 else if ((compress) == (3)) {
info->mr = (u32)(stbi__get32le(s));info->mg = (u32)(stbi__get32le(s));info->mb = (u32)(stbi__get32le(s));if (((info->mr) == (info->mg)) && ((info->mg) == (info->mb))) {
}
}
 else ;}
}
 else {
i:i32 =  new i32();info->mr = (u32)(stbi__get32le(s));info->mg = (u32)(stbi__get32le(s));info->mb = (u32)(stbi__get32le(s));info->ma = (u32)(stbi__get32le(s));stbi__get32le(s);for (i = (i32)(0); (i) < (12); ++i) {stbi__get32le(s);}if ((hsz) == (124)) {
stbi__get32le(s);stbi__get32le(s);stbi__get32le(s);stbi__get32le(s);}
}
}

	return (void *)(1);
}

public static void * stbi__bmp_load(stbi__context* s, i32* x, i32* y, i32* comp, i32 req_comp, stbi__result_info* ri)
{
	_out_:byte*;
	mr:u32 = (u32)(0);mg:u32 = (u32)(0);mb:u32 = (u32)(0);ma:u32 = (u32)(0);all_a:u32 =  new u32();
	pal:[byte;256] = stackalloc byte[256];
	psize:i32 = (i32)(0);i:i32 =  new i32();j:i32 =  new i32();width:i32 =  new i32();
	flip_vertically:i32 =  new i32();pad:i32 =  new i32();target:i32 =  new i32();
	info:stbi__bmp_data =  new stbi__bmp_data();
	info.all_a = (u32)(255);
	flip_vertically = (i32)(((i32)(s->img_y)) > (0)?1:0);
	s->img_y = (u32)(CRuntime.abs((i32)(s->img_y)));
	mr = (u32)(info.mr);
	mg = (u32)(info.mg);
	mb = (u32)(info.mb);
	ma = (u32)(info.ma);
	all_a = (u32)(info.all_a);
	if ((info.hsz) == (12)) {
if ((info.bpp) < (24)) psize = (i32)((info.offset - 14 - 24) / 3);}
 else {
if ((info.bpp) < (16)) psize = (i32)((info.offset - 14 - info.hsz) >> 2);}

	s->img_n = (i32)((ma) != 0?4:3);
	if (((req_comp) != 0) && ((req_comp) >= (3))) target = (i32)(req_comp); else target = (i32)(s->img_n);
	_out_ = (byte*)(stbi__malloc_mad3((i32)(target), (i32)(s->img_x), (i32)(s->img_y), (i32)(0)));
	if ((info.bpp) < (16)) {
z:i32 = (i32)(0);if (((psize) == (0)) || ((psize) > (256))) {
CRuntime.free(_out_);}
for (i = (i32)(0); (i) < (psize); ++i) {
pal[i * 4 +2] = (byte)(stbi__get8(s));pal[i * 4 +1] = (byte)(stbi__get8(s));pal[i * 4 +0] = (byte)(stbi__get8(s));if (info.hsz != 12) stbi__get8(s);pal[i * 4 +3] = (byte)(255);}stbi__skip(s, (i32)(info.offset - 14 - info.hsz - psize * ((info.hsz) == (12)?3:4)));if ((info.bpp) == (4)) width = (i32)((s->img_x + 1) >> 1); else if ((info.bpp) == (8)) width = (i32)(s->img_x); else {
CRuntime.free(_out_);}
pad = (i32)((-width) & 3);for (j = (i32)(0); (j) < ((i32)(s->img_y)); ++j) {
for (i = (i32)(0); (i) < ((i32)(s->img_x)); i += (i32)(2)) {
v:i32 = (i32)(stbi__get8(s));v2:i32 = (i32)(0);if ((info.bpp) == (4)) {
v2 = (i32)(v & 15);v >>= 4;}
_out_[z++] = (byte)(pal[v * 4 +0]);_out_[z++] = (byte)(pal[v * 4 +1]);_out_[z++] = (byte)(pal[v * 4 +2]);if ((target) == (4)) _out_[z++] = (byte)(255);if ((i + 1) == ((i32)(s->img_x))) break;v = (i32)(((info.bpp) == (8))?stbi__get8(s):v2);_out_[z++] = (byte)(pal[v * 4 +0]);_out_[z++] = (byte)(pal[v * 4 +1]);_out_[z++] = (byte)(pal[v * 4 +2]);if ((target) == (4)) _out_[z++] = (byte)(255);}stbi__skip(s, (i32)(pad));}}
 else {
rshift:i32 = (i32)(0);gshift:i32 = (i32)(0);bshift:i32 = (i32)(0);ashift:i32 = (i32)(0);rcount:i32 = (i32)(0);gcount:i32 = (i32)(0);bcount:i32 = (i32)(0);acount:i32 = (i32)(0);z:i32 = (i32)(0);easy:i32 = (i32)(0);stbi__skip(s, (i32)(info.offset - 14 - info.hsz));if ((info.bpp) == (24)) width = (i32)(3 * s->img_x); else if ((info.bpp) == (16)) width = (i32)(2 * s->img_x); else width = (i32)(0);pad = (i32)((-width) & 3);if ((info.bpp) == (24)) {
easy = (i32)(1);}
 else if ((info.bpp) == (32)) {
if (((((mb) == (0xff)) && ((mg) == (0xff00))) && ((mr) == (0x00ff0000))) && ((ma) == (0xff000000))) easy = (i32)(2);}
if (easy== 0) {
if (((mr== 0) || (mg== 0)) || (mb== 0)) {
CRuntime.free(_out_);}
rshift = (i32)(stbi__high_bit((u32)(mr)) - 7);rcount = (i32)(stbi__bitcount((u32)(mr)));gshift = (i32)(stbi__high_bit((u32)(mg)) - 7);gcount = (i32)(stbi__bitcount((u32)(mg)));bshift = (i32)(stbi__high_bit((u32)(mb)) - 7);bcount = (i32)(stbi__bitcount((u32)(mb)));ashift = (i32)(stbi__high_bit((u32)(ma)) - 7);acount = (i32)(stbi__bitcount((u32)(ma)));}
for (j = (i32)(0); (j) < ((i32)(s->img_y)); ++j) {
if ((easy) != 0) {
for (i = (i32)(0); (i) < ((i32)(s->img_x)); ++i) {
a:byte =  new byte();_out_[z + 2] = (byte)(stbi__get8(s));_out_[z + 1] = (byte)(stbi__get8(s));_out_[z + 0] = (byte)(stbi__get8(s));z += (i32)(3);a = (byte)((easy) == (2)?stbi__get8(s):255);all_a |= (u32)(a);if ((target) == (4)) _out_[z++] = (byte)(a);}}
 else {
bpp:i32 = (i32)(info.bpp);for (i = (i32)(0); (i) < ((i32)(s->img_x)); ++i) {
v:u32 = (u32)((bpp) == (16)?(u32)(stbi__get16le(s)):stbi__get32le(s));a:i32 =  new i32();_out_[z++] = ((byte)((stbi__shiftsigned((i32)(v & mr), (i32)(rshift), (i32)(rcount))) & 255));_out_[z++] = ((byte)((stbi__shiftsigned((i32)(v & mg), (i32)(gshift), (i32)(gcount))) & 255));_out_[z++] = ((byte)((stbi__shiftsigned((i32)(v & mb), (i32)(bshift), (i32)(bcount))) & 255));a = (i32)((ma) != 0?stbi__shiftsigned((i32)(v & ma), (i32)(ashift), (i32)(acount)):255);all_a |= (u32)(a);if ((target) == (4)) _out_[z++] = ((byte)((a) & 255));}}
stbi__skip(s, (i32)(pad));}}

	if (((target) == (4)) && ((all_a) == (0))) for (i = (i32)(4 * s->img_x * s->img_y - 1); (i) >= (0); i -= (i32)(4)) {_out_[i] = (byte)(255);}
	if ((flip_vertically) != 0) {
t:byte =  new byte();for (j = (i32)(0); (j) < ((i32)(s->img_y) >> 1); ++j) {
p1:byte* = _out_[j * s->img_x * target];p2:byte* = _out_[(s->img_y - 1 - j) * s->img_x * target];for (i = (i32)(0); (i) < ((i32)(s->img_x) * target); ++i) {
t = (byte)(p1[i]);p1[i] = (byte)(p2[i]);p2[i] = (byte)(t);}}}

	if (((req_comp) != 0) && (req_comp != target)) {
_out_ = stbi__convert_format(_out_, (i32)(target), (i32)(req_comp), (u32)(s->img_x), (u32)(s->img_y));if (() != 0) return _out_;}

	x = (i32)(s->img_x);
	y = (i32)(s->img_y);
	if ((comp) != null) comp = (i32)(s->img_n);
	return _out_;
}

public static i32 stbi__tga_get_comp(i32 bits_per_pixel, i32 is_grey, i32* is_rgb16)
{
	if ((is_rgb16) != null) is_rgb16 = (i32)(0);
	switch (bits_per_pixel){
case 8:return (i32)(STBI_grey);case 15:case 16:if (((bits_per_pixel) == (16)) && ((is_grey) != 0)) return (i32)(STBI_grey_alpha);if ((is_rgb16) != null) is_rgb16 = (i32)(1);return (i32)(STBI_rgb);case 24:case 32:return (i32)(bits_per_pixel / 8);default: return (i32)(0);}

}

public static i32 stbi__tga_info(stbi__context* s, i32* x, i32* y, i32* comp)
{
	tga_w:i32 =  new i32();tga_h:i32 =  new i32();tga_comp:i32 =  new i32();tga_image_type:i32 =  new i32();tga_bits_per_pixel:i32 =  new i32();tga_colormap_bpp:i32 =  new i32();
	sz:i32 =  new i32();tga_colormap_type:i32 =  new i32();
	stbi__get8(s);
	tga_colormap_type = (i32)(stbi__get8(s));
	if ((tga_colormap_type) > (1)) {
stbi__rewind(s);return (i32)(0);}

	tga_image_type = (i32)(stbi__get8(s));
	if ((tga_colormap_type) == (1)) {
if ((tga_image_type != 1) && (tga_image_type != 9)) {
stbi__rewind(s);return (i32)(0);}
stbi__skip(s, (i32)(4));sz = (i32)(stbi__get8(s));if (((((sz != 8) && (sz != 15)) && (sz != 16)) && (sz != 24)) && (sz != 32)) {
stbi__rewind(s);return (i32)(0);}
stbi__skip(s, (i32)(4));tga_colormap_bpp = (i32)(sz);}
 else {
if ((((tga_image_type != 2) && (tga_image_type != 3)) && (tga_image_type != 10)) && (tga_image_type != 11)) {
stbi__rewind(s);return (i32)(0);}
stbi__skip(s, (i32)(9));tga_colormap_bpp = (i32)(0);}

	tga_w = (i32)(stbi__get16le(s));
	if ((tga_w) < (1)) {
stbi__rewind(s);return (i32)(0);}

	tga_h = (i32)(stbi__get16le(s));
	if ((tga_h) < (1)) {
stbi__rewind(s);return (i32)(0);}

	tga_bits_per_pixel = (i32)(stbi__get8(s));
	stbi__get8(s);
	if (tga_colormap_bpp != 0) {
if ((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {
stbi__rewind(s);return (i32)(0);}
}
 else {
}

	if (tga_comp== 0) {
stbi__rewind(s);return (i32)(0);}

	if ((x) != null) x = (i32)(tga_w);
	if ((y) != null) y = (i32)(tga_h);
	if ((comp) != null) comp = (i32)(tga_comp);
	return (i32)(1);
}

public static i32 stbi__tga_test(stbi__context* s)
{
	res:i32 = (i32)(0);
	sz:i32 =  new i32();tga_color_type:i32 =  new i32();
	stbi__get8(s);
	tga_color_type = (i32)(stbi__get8(s));
	if ((tga_color_type) > (1)) goto errorEnd;
	sz = (i32)(stbi__get8(s));
	if ((tga_color_type) == (1)) {
if ((sz != 1) && (sz != 9)) goto errorEnd;stbi__skip(s, (i32)(4));sz = (i32)(stbi__get8(s));if (((((sz != 8) && (sz != 15)) && (sz != 16)) && (sz != 24)) && (sz != 32)) goto errorEnd;stbi__skip(s, (i32)(4));}
 else {
if ((((sz != 2) && (sz != 3)) && (sz != 10)) && (sz != 11)) goto errorEnd;stbi__skip(s, (i32)(9));}

	if ((stbi__get16le(s)) < (1)) goto errorEnd;
	if ((stbi__get16le(s)) < (1)) goto errorEnd;
	sz = (i32)(stbi__get8(s));
	if ((((tga_color_type) == (1)) && (sz != 8)) && (sz != 16)) goto errorEnd;
	if (((((sz != 8) && (sz != 15)) && (sz != 16)) && (sz != 24)) && (sz != 32)) goto errorEnd;
	res = (i32)(1);
	errorEnd:;
stbi__rewind(s);
	return (i32)(res);
}

public static void stbi__tga_read_rgb16(stbi__context* s, byte* _out_)
{
	px:ushort = (ushort)(stbi__get16le(s));
	fiveBitMask:ushort = (ushort)(31);
	r:i32 = (i32)((px >> 10) & fiveBitMask);
	g:i32 = (i32)((px >> 5) & fiveBitMask);
	b:i32 = (i32)(px & fiveBitMask);
	_out_[0] = ((byte)((r * 255) / 31));
	_out_[1] = ((byte)((g * 255) / 31));
	_out_[2] = ((byte)((b * 255) / 31));
}

public static void * stbi__tga_load(stbi__context* s, i32* x, i32* y, i32* comp, i32 req_comp, stbi__result_info* ri)
{
	tga_offset:i32 = (i32)(stbi__get8(s));
	tga_indexed:i32 = (i32)(stbi__get8(s));
	tga_image_type:i32 = (i32)(stbi__get8(s));
	tga_is_RLE:i32 = (i32)(0);
	tga_palette_start:i32 = (i32)(stbi__get16le(s));
	tga_palette_len:i32 = (i32)(stbi__get16le(s));
	tga_palette_bits:i32 = (i32)(stbi__get8(s));
	tga_x_origin:i32 = (i32)(stbi__get16le(s));
	tga_y_origin:i32 = (i32)(stbi__get16le(s));
	tga_width:i32 = (i32)(stbi__get16le(s));
	tga_height:i32 = (i32)(stbi__get16le(s));
	tga_bits_per_pixel:i32 = (i32)(stbi__get8(s));
	tga_comp:i32 =  new i32();tga_rgb16:i32 = (i32)(0);
	tga_inverted:i32 = (i32)(stbi__get8(s));
	tga_data:byte*;
	tga_palette:byte*;
	i:i32 =  new i32();j:i32 =  new i32();
	raw_data:[byte;4] = stackalloc byte[4];
raw_data[0] = (byte)(0);

	RLE_count:i32 = (i32)(0);
	RLE_repeating:i32 = (i32)(0);
	read_next_pixel:i32 = (i32)(1);
	if ((tga_image_type) >= (8)) {
tga_image_type -= (i32)(8);tga_is_RLE = (i32)(1);}

	tga_inverted = (i32)(1 - ((tga_inverted >> 5) & 1));
	if ((tga_indexed) != 0) tga_comp = (i32)(stbi__tga_get_comp((i32)(tga_palette_bits), (i32)(0), tga_rgb16)); else tga_comp = (i32)(stbi__tga_get_comp((i32)(tga_bits_per_pixel), (i32)((tga_image_type) == (3)), tga_rgb16));
	x = (i32)(tga_width);
	y = (i32)(tga_height);
	if ((comp) != null) comp = (i32)(tga_comp);
	tga_data = (byte*)(stbi__malloc_mad3((i32)(tga_width), (i32)(tga_height), (i32)(tga_comp), (i32)(0)));
	stbi__skip(s, (i32)(tga_offset));
	if (((tga_indexed== 0) && (tga_is_RLE== 0)) && (tga_rgb16== 0)) {
for (i = (i32)(0); (i) < (tga_height); ++i) {
row:i32 = (i32)((tga_inverted) != 0?tga_height - i - 1:i);tga_row:byte* = tga_data[row * tga_width * tga_comp];stbi__getn(s, tga_row, (i32)(tga_width * tga_comp));}}
 else {
if ((tga_indexed) != 0) {
stbi__skip(s, (i32)(tga_palette_start));tga_palette = (byte*)(stbi__malloc_mad2((i32)(tga_palette_len), (i32)(tga_comp), (i32)(0)));if (tga_palette== null) {
CRuntime.free(tga_data);}
if ((tga_rgb16) != 0) {
pal_entry:byte* = tga_palette;for (i = (i32)(0); (i) < (tga_palette_len); ++i) {
stbi__tga_read_rgb16(s, pal_entry);pal_entry += tga_comp;}}
 else if (stbi__getn(s, tga_palette, (i32)(tga_palette_len * tga_comp))== 0) {
CRuntime.free(tga_data);CRuntime.free(tga_palette);}
}
for (i = (i32)(0); (i) < (tga_width * tga_height); ++i) {
if ((tga_is_RLE) != 0) {
if ((RLE_count) == (0)) {
RLE_cmd:i32 = (i32)(stbi__get8(s));RLE_count = (i32)(1 + (RLE_cmd & 127));RLE_repeating = (i32)(RLE_cmd >> 7);read_next_pixel = (i32)(1);}
 else if (RLE_repeating== 0) {
read_next_pixel = (i32)(1);}
}
 else {
read_next_pixel = (i32)(1);}
if ((read_next_pixel) != 0) {
if ((tga_indexed) != 0) {
pal_idx:i32 = (i32)(((tga_bits_per_pixel) == (8))?stbi__get8(s):stbi__get16le(s));if ((pal_idx) >= (tga_palette_len)) {
pal_idx = (i32)(0);}
pal_idx *= (i32)(tga_comp);for (j = (i32)(0); (j) < (tga_comp); ++j) {
raw_data[j] = (byte)(tga_palette[pal_idx + j]);}}
 else if ((tga_rgb16) != 0) {
stbi__tga_read_rgb16(s, raw_data);}
 else {
for (j = (i32)(0); (j) < (tga_comp); ++j) {
raw_data[j] = (byte)(stbi__get8(s));}}
read_next_pixel = (i32)(0);}
for (j = (i32)(0); (j) < (tga_comp); ++j) {tga_data[i * tga_comp + j] = (byte)(raw_data[j]);}--RLE_count;}if ((tga_inverted) != 0) {
for (j = (i32)(0); (j * 2) < (tga_height); ++j) {
index1:i32 = (i32)(j * tga_width * tga_comp);index2:i32 = (i32)((tga_height - 1 - j) * tga_width * tga_comp);for (i = (i32)(tga_width * tga_comp); (i) > (0); --i) {
temp:byte = (byte)(tga_data[index1]);tga_data[index1] = (byte)(tga_data[index2]);tga_data[index2] = (byte)(temp);++index1;++index2;}}}
if (() != 0) {
CRuntime.free(tga_palette);}
}

	if (((tga_comp) >= (3)) && (tga_rgb16== 0)) {
tga_pixel:byte* = tga_data;for (i = (i32)(0); (i) < (tga_width * tga_height); ++i) {
temp:byte = (byte)(tga_pixel[0]);tga_pixel[0] = (byte)(tga_pixel[2]);tga_pixel[2] = (byte)(temp);tga_pixel += tga_comp;}}

	if (((req_comp) != 0) && (req_comp != tga_comp)) tga_data = stbi__convert_format(tga_data, (i32)(tga_comp), (i32)(req_comp), (u32)(tga_width), (u32)(tga_height));
	tga_palette_start = (i32)(tga_palette_len = (i32)(tga_palette_bits = (i32)(tga_x_origin = (i32)(tga_y_origin = (i32)(0)))));
	return tga_data;
}

public static i32 stbi__psd_test(stbi__context* s)
{
	r:i32 = (i32)((stbi__get32be(s)) == (0x38425053));
	stbi__rewind(s);
	return (i32)(r);
}

public static i32 stbi__psd_decode_rle(stbi__context* s, byte* p, i32 pixelCount)
{
	count:i32 =  new i32();nleft:i32 =  new i32();len:i32 =  new i32();
	count = (i32)(0);
	while ((nleft = (i32)(pixelCount - count)) > (0)) {
len = (i32)(stbi__get8(s));if ((len) == (128)) {
}
 else if ((len) < (128)) {
len++;if ((len) > (nleft)) return (i32)(0);count += (i32)(len);while ((len) != 0) {
p = (byte)(stbi__get8(s));p += 4;len--;}}
 else if ((len) > (128)) {
val:byte =  new byte();len = (i32)(257 - len);if ((len) > (nleft)) return (i32)(0);val = (byte)(stbi__get8(s));count += (i32)(len);while ((len) != 0) {
p = (byte)(val);p += 4;len--;}}
}
	return (i32)(1);
}

public static void * stbi__psd_load(stbi__context* s, i32* x, i32* y, i32* comp, i32 req_comp, stbi__result_info* ri, i32 bpc)
{
	pixelCount:i32 =  new i32();
	channelCount:i32 =  new i32();compression:i32 =  new i32();
	channel:i32 =  new i32();i:i32 =  new i32();
	bitdepth:i32 =  new i32();
	w:i32 =  new i32();h:i32 =  new i32();
	_out_:byte*;
	stbi__skip(s, (i32)(6));
	channelCount = (i32)(stbi__get16be(s));
	h = (i32)(stbi__get32be(s));
	w = (i32)(stbi__get32be(s));
	bitdepth = (i32)(stbi__get16be(s));
	stbi__skip(s, (i32)(stbi__get32be(s)));
	stbi__skip(s, (i32)(stbi__get32be(s)));
	stbi__skip(s, (i32)(stbi__get32be(s)));
	compression = (i32)(stbi__get16be(s));
	if (((compression== 0) && ((bitdepth) == (16))) && ((bpc) == (16))) {
_out_ = (byte*)(stbi__malloc_mad3((i32)(8), (i32)(w), (i32)(h), (i32)(0)));ri->bits_per_channel = (i32)(16);}
 else _out_ = (byte*)(stbi__malloc((ulong)(4 * w * h)));
	pixelCount = (i32)(w * h);
	if ((compression) != 0) {
stbi__skip(s, (i32)(h * channelCount * 2));for (channel = (i32)(0); (channel) < (4); channel++) {
p:byte*;p = _out_[channel];if ((channel) >= (channelCount)) {
for (i = (i32)(0); (i) < (pixelCount); i++ , p += 4) {p = (byte)((channel) == (3)?255:0);}}
 else {
if (stbi__psd_decode_rle(s, p, (i32)(pixelCount))== 0) {
CRuntime.free(_out_);}
}
}}
 else {
for (channel = (i32)(0); (channel) < (4); channel++) {
if ((channel) >= (channelCount)) {
if (((bitdepth) == (16)) && ((bpc) == (16))) {
q:ushort* = ((ushort*)(_out_))[channel];val:ushort = (ushort)((channel) == (3)?65535:0);for (i = (i32)(0); (i) < (pixelCount); i++ , q += 4) {q = (ushort)(val);}}
 else {
p:byte* = _out_[channel];val:byte = (byte)((channel) == (3)?255:0);for (i = (i32)(0); (i) < (pixelCount); i++ , p += 4) {p = (byte)(val);}}
}
 else {
if ((ri->bits_per_channel) == (16)) {
q:ushort* = ((ushort*)(_out_))[channel];for (i = (i32)(0); (i) < (pixelCount); i++ , q += 4) {q = ((ushort)(stbi__get16be(s)));}}
 else {
p:byte* = _out_[channel];if ((bitdepth) == (16)) {
for (i = (i32)(0); (i) < (pixelCount); i++ , p += 4) {p = ((byte)(stbi__get16be(s) >> 8));}}
 else {
for (i = (i32)(0); (i) < (pixelCount); i++ , p += 4) {p = (byte)(stbi__get8(s));}}
}
}
}}

	if ((channelCount) >= (4)) {
if ((ri->bits_per_channel) == (16)) {
for (i = (i32)(0); (i) < (w * h); ++i) {
pixel:ushort* = (ushort*)(_out_)[4 * i];if ((pixel[3] != 0) && (pixel[3] != 65535)) {
a:f32 = (f32)(pixel[3] / 65535.0f32);ra:f32 = (f32)(1.0f32 / a);inv_a:f32 = (f32)(65535.0f32 * (1 - ra));pixel[0] = ((ushort)(pixel[0] * ra + inv_a));pixel[1] = ((ushort)(pixel[1] * ra + inv_a));pixel[2] = ((ushort)(pixel[2] * ra + inv_a));}
}}
 else {
for (i = (i32)(0); (i) < (w * h); ++i) {
pixel:byte* = _out_[4 * i];if ((pixel[3] != 0) && (pixel[3] != 255)) {
a:f32 = (f32)(pixel[3] / 255.0f32);ra:f32 = (f32)(1.0f32 / a);inv_a:f32 = (f32)(255.0f32 * (1 - ra));pixel[0] = ((byte)(pixel[0] * ra + inv_a));pixel[1] = ((byte)(pixel[1] * ra + inv_a));pixel[2] = ((byte)(pixel[2] * ra + inv_a));}
}}
}

	if (((req_comp) != 0) && (req_comp != 4)) {
if ((ri->bits_per_channel) == (16)) _out_ = (byte*)(stbi__convert_format16((ushort*)(_out_), (i32)(4), (i32)(req_comp), (u32)(w), (u32)(h))); else _out_ = stbi__convert_format(_out_, (i32)(4), (i32)(req_comp), (u32)(w), (u32)(h));if (() != 0) return _out_;}

	if ((comp) != null) comp = (i32)(4);
	y = (i32)(h);
	x = (i32)(w);
	return _out_;
}

public static i32 stbi__gif_test_raw(stbi__context* s)
{
	sz:i32 =  new i32();
	if ((((stbi__get8(s) != 'G') || (stbi__get8(s) != 'I')) || (stbi__get8(s) != 'F')) || (stbi__get8(s) != '8')) return (i32)(0);
	sz = (i32)(stbi__get8(s));
	if ((sz != '9') && (sz != '7')) return (i32)(0);
	if (stbi__get8(s) != 'a') return (i32)(0);
	return (i32)(1);
}

public static i32 stbi__gif_test(stbi__context* s)
{
	r:i32 = (i32)(stbi__gif_test_raw(s));
	stbi__rewind(s);
	return (i32)(r);
}

public static i32 stbi__gif_header(stbi__context* s, stbi__gif* g, i32* comp, i32 is_info)
{
	version:byte =  new byte();
	if ((((stbi__get8(s) != 'G') || (stbi__get8(s) != 'I')) || (stbi__get8(s) != 'F')) || (stbi__get8(s) != '8')) return (i32)(stbi__err("not GIF"));
	version = (byte)(stbi__get8(s));
	if ((version != '7') && (version != '9')) return (i32)(stbi__err("not GIF"));
	if (stbi__get8(s) != 'a') return (i32)(stbi__err("not GIF"));
	stbi__g_failure_reason = "";
	g->w = (i32)(stbi__get16le(s));
	g->h = (i32)(stbi__get16le(s));
	g->flags = (i32)(stbi__get8(s));
	g->bgindex = (i32)(stbi__get8(s));
	g->ratio = (i32)(stbi__get8(s));
	g->transparent = (i32)(-1);
	if (comp != null) comp = (i32)(4);
	if ((is_info) != 0) return (i32)(1);
	if ((g->flags & 0x80) != 0) stbi__gif_parse_colortable(s, g->pal, (i32)(2 << (g->flags & 7)), (i32)(-1));
	return (i32)(1);
}

public static i32 stbi__gif_info_raw(stbi__context* s, i32* x, i32* y, i32* comp)
{
	g:stbi__gif* = (stbi__gif*)(stbi__malloc((ulong)(sizeof(stbi__gif))));
	if (stbi__gif_header(s, g, comp, (i32)(1))== 0) {
stbi__rewind(s);return (i32)(0);}

	if ((x) != null) x = (i32)(g->w);
	if ((y) != null) y = (i32)(g->h);
	
	return (i32)(1);
}

public static void stbi__out_gif_code(stbi__gif* g, ushort code)
{
	p:byte*;c:byte*;
	if ((g->codes[code].prefix) >= (0)) stbi__out_gif_code(g, (ushort)(g->codes[code].prefix));
	if ((g->cur_y) >= (g->max_y)) return;
	p = g->_out_[g->cur_x + g->cur_y];
	c = g->color_table[g->codes[code].suffix * 4];
	if ((c[3]) >= (128)) {
p[0] = (byte)(c[2]);p[1] = (byte)(c[1]);p[2] = (byte)(c[0]);p[3] = (byte)(c[3]);}

	g->cur_x += (i32)(4);
	if ((g->cur_x) >= (g->max_x)) {
g->cur_x = (i32)(g->start_x);g->cur_y += (i32)(g->step);while (((g->cur_y) >= (g->max_y)) && ((g->parse) > (0))) {
g->step = (i32)((1 << g->parse) * g->line_size);g->cur_y = (i32)(g->start_y + (g->step >> 1));--g->parse;}}

}

public static byte* stbi__process_gif_raster(stbi__context* s, stbi__gif* g)
{
	lzw_cs:byte =  new byte();
	len:i32 =  new i32();init_code:i32 =  new i32();
	first:u32 =  new u32();
	codesize:i32 =  new i32();codemask:i32 =  new i32();avail:i32 =  new i32();oldcode:i32 =  new i32();bits:i32 =  new i32();valid_bits:i32 =  new i32();clear:i32 =  new i32();
	p:stbi__gif_lzw*;
	lzw_cs = (byte)(stbi__get8(s));
	clear = (i32)(1 << lzw_cs);
	first = (u32)(1);
	codesize = (i32)(lzw_cs + 1);
	codemask = (i32)((1 << codesize) - 1);
	bits = (i32)(0);
	valid_bits = (i32)(0);
	for (init_code = (i32)(0); (init_code) < (clear); init_code++) {
g->codes[init_code].prefix = (short)(-1);g->codes[init_code].first = ((byte)(init_code));g->codes[init_code].suffix = ((byte)(init_code));}
	avail = (i32)(clear + 2);
	oldcode = (i32)(-1);
	len = (i32)(0);
	for (; ; ) {
if ((valid_bits) < (codesize)) {
if ((len) == (0)) {
len = (i32)(stbi__get8(s));if ((len) == (0)) return g->_out_;}
--len;bits |= (i32)((i32)(stbi__get8(s)) << valid_bits);valid_bits += (i32)(8);}
 else {
code:i32 = (i32)(bits & codemask);bits >>= codesize;valid_bits -= (i32)(codesize);if ((code) == (clear)) {
codesize = (i32)(lzw_cs + 1);codemask = (i32)((1 << codesize) - 1);avail = (i32)(clear + 2);oldcode = (i32)(-1);first = (u32)(0);}
 else if ((code) == (clear + 1)) {
stbi__skip(s, (i32)(len));while ((len = (i32)(stbi__get8(s))) > (0)) {stbi__skip(s, (i32)(len));}return g->_out_;}
 else if (code <= avail) {
if ((oldcode) >= (0)) {
p = g->codes[avail++];p->prefix = ((short)(oldcode));p->first = (byte)(g->codes[oldcode].first);p->suffix = (byte)(((code) == (avail))?p->first:g->codes[code].first);}
 else ;stbi__out_gif_code(g, (ushort)(code));if (((avail & codemask) == (0)) && (avail <= 0x0FFF)) {
codesize++;codemask = (i32)((1 << codesize) - 1);}
oldcode = (i32)(code);}
 else {
}
}
}
}

public static void stbi__fill_gif_background(stbi__gif* g, i32 x0, i32 y0, i32 x1, i32 y1)
{
	x:i32 =  new i32();y:i32 =  new i32();
	c:byte* = g->pal[g->bgindex];
	for (y = (i32)(y0); (y) < (y1); y += (i32)(4 * g->w)) {
for (x = (i32)(x0); (x) < (x1); x += (i32)(4)) {
p:byte* = g->_out_[y + x];p[0] = (byte)(c[2]);p[1] = (byte)(c[1]);p[2] = (byte)(c[0]);p[3] = (byte)(0);}}
}

public static byte* stbi__gif_load_next(stbi__context* s, stbi__gif* g, i32* comp, i32 req_comp)
{
	i:i32 =  new i32();
	prev_out:byte*;
	prev_out = g->_out_;
	g->_out_ = (byte*)(stbi__malloc_mad3((i32)(4), (i32)(g->w), (i32)(g->h), (i32)(0)));
	switch ((g->eflags & 0x1C) >> 2){
case 0:stbi__fill_gif_background(g, (i32)(0), (i32)(0), (i32)(4 * g->w), (i32)(4 * g->w * g->h));break;case 1:if ((prev_out) != null) CRuntime.memcpy(g->_out_, prev_out, (ulong)(4 * g->w * g->h));g->old_out = prev_out;break;case 2:if ((prev_out) != null) CRuntime.memcpy(g->_out_, prev_out, (ulong)(4 * g->w * g->h));stbi__fill_gif_background(g, (i32)(g->start_x), (i32)(g->start_y), (i32)(g->max_x), (i32)(g->max_y));break;case 3:if ((g->old_out) != null) {
for (i = (i32)(g->start_y); (i) < (g->max_y); i += (i32)(4 * g->w)) {CRuntime.memcpy(g->_out_[i + g->start_x], g->old_out[i + g->start_x], (ulong)(g->max_x - g->start_x));}}
break;}

	for (; ; ) {
switch (stbi__get8(s)){
case 0x2C:{
prev_trans:i32 = (i32)(-1);x:i32 =  new i32();y:i32 =  new i32();w:i32 =  new i32();h:i32 =  new i32();o:byte*;x = (i32)(stbi__get16le(s));y = (i32)(stbi__get16le(s));w = (i32)(stbi__get16le(s));h = (i32)(stbi__get16le(s));g->line_size = (i32)(g->w * 4);g->start_x = (i32)(x * 4);g->start_y = (i32)(y * g->line_size);g->max_x = (i32)(g->start_x + w * 4);g->max_y = (i32)(g->start_y + h * g->line_size);g->cur_x = (i32)(g->start_x);g->cur_y = (i32)(g->start_y);g->lflags = (i32)(stbi__get8(s));if ((g->lflags & 0x40) != 0) {
g->step = (i32)(8 * g->line_size);g->parse = (i32)(3);}
 else {
g->step = (i32)(g->line_size);g->parse = (i32)(0);}
if ((g->lflags & 0x80) != 0) {
stbi__gif_parse_colortable(s, g->lpal, (i32)(2 << (g->lflags & 7)), (i32)((g->eflags & 0x01) != 0?g->transparent:-1));g->color_table = (byte*)(g->lpal);}
 else if ((g->flags & 0x80) != 0) {
if (((g->transparent) >= (0)) && ((g->eflags & 0x01)!= 0)) {
prev_trans = (i32)(g->pal[g->transparent][3]);g->pal[g->transparent][3] = (byte)(0);}
g->color_table = (byte*)(g->pal);}
 else ;o = stbi__process_gif_raster(s, g);if (prev_trans != -1) g->pal[g->transparent][3] = ((byte)(prev_trans));return o;}
case 0x21:{
len:i32 =  new i32();if ((stbi__get8(s)) == (0xF9)) {
len = (i32)(stbi__get8(s));if ((len) == (4)) {
g->eflags = (i32)(stbi__get8(s));g->delay = (i32)(stbi__get16le(s));g->transparent = (i32)(stbi__get8(s));}
 else {
stbi__skip(s, (i32)(len));break;}
}
while ((len = (i32)(stbi__get8(s))) != 0) {stbi__skip(s, (i32)(len));}break;}
case 0x3B:return null;default: ;}
}
}

public static void * stbi__gif_load(stbi__context* s, i32* x, i32* y, i32* comp, i32 req_comp, stbi__result_info* ri)
{
	u:byte*;
	g:stbi__gif* = (stbi__gif*)(stbi__malloc((ulong)(sizeof(stbi__gif))));
	CRuntime.memset(g, (i32)(0), (ulong)(sizeof((g))));
	u = stbi__gif_load_next(s, g, comp, (i32)(req_comp));
	if ((u) == ((byte*)(s))) u = null;
	if ((u) != null) {
x = (i32)(g->w);y = (i32)(g->h);if (((req_comp) != 0) && (req_comp != 4)) u = stbi__convert_format(u, (i32)(4), (i32)(req_comp), (u32)(g->w), (u32)(g->h));}
 else if ((g->_out_) != null) CRuntime.free(g->_out_);
	
	return u;
}

public static i32 stbi__gif_info(stbi__context* s, i32* x, i32* y, i32* comp)
{
	return (i32)(stbi__gif_info_raw(s, x, y, comp));
}

public static i32 stbi__bmp_info(stbi__context* s, i32* x, i32* y, i32* comp)
{
	p:void *;
	info:stbi__bmp_data =  new stbi__bmp_data();
	info.all_a = (u32)(255);
	p = stbi__bmp_parse_header(s, info);
	stbi__rewind(s);
	if (() != 0) return (i32)(0);
	if ((x) != null) x = (i32)(s->img_x);
	if ((y) != null) y = (i32)(s->img_y);
	if ((comp) != null) comp = (i32)((info.ma) != 0?4:3);
	return (i32)(1);
}

public static i32 stbi__psd_info(stbi__context* s, i32* x, i32* y, i32* comp)
{
	channelCount:i32 =  new i32();dummy:i32 =  new i32();
	if (x== null) x = dummy;
	if (y== null) y = dummy;
	if (comp== null) comp = dummy;
	if (stbi__get32be(s) != 0x38425053) {
stbi__rewind(s);return (i32)(0);}

	if (stbi__get16be(s) != 1) {
stbi__rewind(s);return (i32)(0);}

	stbi__skip(s, (i32)(6));
	channelCount = (i32)(stbi__get16be(s));
	if (((channelCount) < (0)) || ((channelCount) > (16))) {
stbi__rewind(s);return (i32)(0);}

	y = (i32)(stbi__get32be(s));
	x = (i32)(stbi__get32be(s));
	if (stbi__get16be(s) != 8) {
stbi__rewind(s);return (i32)(0);}

	if (stbi__get16be(s) != 3) {
stbi__rewind(s);return (i32)(0);}

	comp = (i32)(4);
	return (i32)(1);
}

public static i32 stbi__info_main(stbi__context* s, i32* x, i32* y, i32* comp)
{
	if ((stbi__jpeg_info(s, x, y, comp)) != 0) return (i32)(1);
	if ((stbi__png_info(s, x, y, comp)) != 0) return (i32)(1);
	if ((stbi__gif_info(s, x, y, comp)) != 0) return (i32)(1);
	if ((stbi__bmp_info(s, x, y, comp)) != 0) return (i32)(1);
	if ((stbi__psd_info(s, x, y, comp)) != 0) return (i32)(1);
	if ((stbi__tga_info(s, x, y, comp)) != 0) return (i32)(1);
	return (i32)(stbi__err("unknown image type"));
}

public static i32 stbi_info_from_memory(byte* buffer, i32 len, i32* x, i32* y, i32* comp)
{
	s:stbi__context =  new stbi__context();
	stbi__start_mem(s, buffer, (i32)(len));
	return (i32)(stbi__info_main(s, x, y, comp));
}

public static i32 stbi_info_from_callbacks(stbi_io_callbacks* c, void * user, i32* x, i32* y, i32* comp)
{
	s:stbi__context =  new stbi__context();
	stbi__start_callbacks(s, c, user);
	return (i32)(stbi__info_main(s, x, y, comp));
}

