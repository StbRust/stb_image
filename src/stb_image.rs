// Generated by Ur at 11.08.2018 22:43:55

use std;
use c_runtime;

const STBI_default:i32 = 0;
const STBI_grey:i32 = 1;
const STBI_grey_alpha:i32 = 2;
const STBI_rgb:i32 = 3;
const STBI_rgb_alpha:i32 = 4;
const STBI_ORDER_RGB:i32 = 0;
const STBI_ORDER_BGR:i32 = 1;
const STBI__SCAN_load:i32 = 0;
const STBI__SCAN_type:i32 = 1;
const STBI__SCAN_header:i32 = 2;
const STBI__F_none:i32 = 0;
const STBI__F_sub:i32 = 1;
const STBI__F_up:i32 = 2;
const STBI__F_avg:i32 = 3;
const STBI__F_paeth:i32 = 4;
const STBI__F_avg_first:i32 = 5;
const STBI__F_paeth_first:i32 = 6;

const stbi__vertically_flip_on_load:i32 = 0;
const stbi__h2l_gamma_i:f32 = 1.0f32 / 2.2f32;
const stbi__h2l_scale_i:f32 = 1.0f32;
const stbi__bmask:[u32;17] = unsafe {std::mem::uninitialized()};
const stbi__jbias:[i32;16] = unsafe {std::mem::uninitialized()};
const stbi__jpeg_dezigzag:[u8;79] = unsafe {std::mem::uninitialized()};
const stbi__zlength_base:[i32;31] = unsafe {std::mem::uninitialized()};
const stbi__zlength_extra:[i32;31] = unsafe {std::mem::uninitialized()};
const stbi__zdist_base:[i32;32] = unsafe {std::mem::uninitialized()};
const stbi__zdist_extra:[i32;30] = unsafe {std::mem::uninitialized()};
const length_dezigzag:[u8;19] = unsafe {std::mem::uninitialized()};
const stbi__zdefault_length:[u8;288] = unsafe {std::mem::uninitialized()};
const stbi__zdefault_distance:[u8;32] = unsafe {std::mem::uninitialized()};
const png_sig:[u8;8] = unsafe {std::mem::uninitialized()};
const first_row_filter:[i32;5] = unsafe {std::mem::uninitialized()};
const stbi__depth_scale_table:[u8;9] = unsafe {std::mem::uninitialized()};
const stbi__unpremultiply_on_load:i32 = 0;
const stbi__de_iphone_flag:i32 = 0;
struct stbi__context {
img_x: u32,
img_y: u32,
img_n: i32,
img_out_n: i32,
io: stbi_io_callbacks,
io_user_data: *mut u8,
read_from_callbacks: i32,
buflen: i32,
buffer_start: [u8;128],
img_buffer: *mut u8,
img_buffer_end: *mut u8,
img_buffer_original: *mut u8,
img_buffer_original_end: *mut u8,
}

struct stbi__result_info {
bits_per_channel: i32,
num_channels: i32,
channel_order: i32,
}

struct stbi__huffman {
fast: [u8;512],
code: [u16;256],
values: [u8;256],
size: [u8;257],
maxcode: [u32;18],
delta: [i32;17],
}

struct img_comp {
id: i32,
h: i32,
v: i32,
tq: i32,
hd: i32,
ha: i32,
dc_pred: i32,
x: i32,
y: i32,
w2: i32,
h2: i32,
data: *mut u8,
raw_data: *mut u8,
raw_coeff: *mut u8,
linebuf: *mut u8,
coeff: *mut i16,
coeff_w: i32,
coeff_h: i32,
}

struct stbi__zhuffman {
fast: [u16;512],
firstcode: [u16;16],
maxcode: [i32;17],
firstsymbol: [u16;16],
size: [u8;288],
value: [u16;288],
}

struct stbi__zbuf {
zbuffer: *mut u8,
zbuffer_end: *mut u8,
num_bits: i32,
code_buffer: u32,
zout: *mut i8,
zout_start: *mut i8,
zout_end: *mut i8,
z_expandable: i32,
z_length: stbi__zhuffman,
z_distance: stbi__zhuffman,
}

struct stbi__pngchunk {
length: u32,
_type_: u32,
}

struct stbi__png {
s: *mut stbi__context,
idata: *mut u8,
expanded: *mut u8,
_out_: *mut u8,
depth: i32,
}

struct stbi__bmp_data {
bpp: i32,
offset: i32,
hsz: i32,
mr: u32,
mg: u32,
mb: u32,
ma: u32,
all_a: u32,
}

struct stbi__gif_lzw {
prefix: i16,
first: u8,
suffix: u8,
}

struct stbi__gif {
w: i32,
h: i32,
_out_: *mut u8,
old_out: *mut u8,
flags: i32,
bgindex: i32,
ratio: i32,
transparent: i32,
eflags: i32,
delay: i32,
pal: [[u8;4];256],
lpal: [[u8;4];256],
codes: [stbi__gif_lzw;4096],
color_table: *mut u8,
parse: i32,
step: i32,
lflags: i32,
start_x: i32,
start_y: i32,
max_x: i32,
max_y: i32,
cur_x: i32,
cur_y: i32,
line_size: i32,
}

unsafe fn stbi__start_mem(s:&mut stbi__context, buffer:*mut u8, len:i32){
	s.io.read = std::ptr::null_mut();
	s.read_from_callbacks = 0;
	s.img_buffer = buffer;
	s.img_buffer_original = buffer;
	s.img_buffer_end = buffer[len];
	s.img_buffer_original_end = buffer[len];
}

unsafe fn stbi__start_callbacks(s:&mut stbi__context, c:&mut stbi_io_callbacks, user:*mut u8){
	s.io = c;
	s.io_user_data = user;
	s.buflen = std::mem::size_of(s.buffer_start);
	s.read_from_callbacks = 1;
	s.img_buffer_original = s.buffer_start;
	stbi__refill_buffer(s);
	s.img_buffer_original_end = s.img_buffer_end;
}

unsafe fn stbi__rewind(s:&mut stbi__context){
	s.img_buffer = s.img_buffer_original;
	s.img_buffer_end = s.img_buffer_original_end;
}

unsafe fn stbi__malloc(size:u64) -> *mut u8 {
	return c_runtime::malloc(size);
}

unsafe fn stbi__addsizes_valid(a:i32, b:i32) -> i32 {
	if b < 0 {return 0;}
	return a <= 2147483647 - b;
}

unsafe fn stbi__mul2sizes_valid(a:i32, b:i32) -> i32 {
	if a < 0 || b < 0 {return 0;}
	if b == 0 {return 1;}
	return a <= 2147483647 / b;
}

unsafe fn stbi__mad2sizes_valid(a:i32, b:i32, add:i32) -> i32 {
	return (stbi__mul2sizes_valid(a, b)) != 0 && (stbi__addsizes_valid(a * b, add)) != 0;
}

unsafe fn stbi__mad3sizes_valid(a:i32, b:i32, c:i32, add:i32) -> i32 {
	return (stbi__mul2sizes_valid(a, b)) != 0 && (stbi__mul2sizes_valid(a * b, c)) != 0 && (stbi__addsizes_valid(a * b * c, add)) != 0;
}

unsafe fn stbi__mad4sizes_valid(a:i32, b:i32, c:i32, d:i32, add:i32) -> i32 {
	return (stbi__mul2sizes_valid(a, b)) != 0 && (stbi__mul2sizes_valid(a * b, c)) != 0 && (stbi__mul2sizes_valid(a * b * c, d)) != 0 && (stbi__addsizes_valid(a * b * c * d, add)) != 0;
}

unsafe fn stbi__malloc_mad2(a:i32, b:i32, add:i32) -> *mut u8 {
	if stbi__mad2sizes_valid(a, b, add)== 0 {return std::ptr::null_mut();}
	return stbi__malloc(a * b + add);
}

unsafe fn stbi__malloc_mad3(a:i32, b:i32, c:i32, add:i32) -> *mut u8 {
	if stbi__mad3sizes_valid(a, b, c, add)== 0 {return std::ptr::null_mut();}
	return stbi__malloc(a * b * c + add);
}

unsafe fn stbi__malloc_mad4(a:i32, b:i32, c:i32, d:i32, add:i32) -> *mut u8 {
	if stbi__mad4sizes_valid(a, b, c, d, add)== 0 {return std::ptr::null_mut();}
	return stbi__malloc(a * b * c * d + add);
}

unsafe fn stbi_image_free(retval_from_stbi_load:*mut u8){
	c_runtime::free(retval_from_stbi_load);
}

unsafe fn stbi_set_flip_vertically_on_load(flag_true_if_should_flip:i32){
	stbi__vertically_flip_on_load = flag_true_if_should_flip;
}

unsafe fn stbi__load_main(s:&mut stbi__context, x:*mut i32, y:*mut i32, comp:*mut i32, req_comp:i32, ri:&mut stbi__result_info, bpc:i32) -> *mut u8 {
	ri.bits_per_channel = 8;
	ri.channel_order = STBI_ORDER_RGB;
	ri.num_channels = 0;
	if (stbi__jpeg_test(s)) != 0 {return stbi__jpeg_load(s, x, y, comp, req_comp, ri);}
	if (stbi__png_test(s)) != 0 {return stbi__png_load(s, x, y, comp, req_comp, ri);}
	if (stbi__bmp_test(s)) != 0 {return stbi__bmp_load(s, x, y, comp, req_comp, ri);}
	if (stbi__gif_test(s)) != 0 {return stbi__gif_load(s, x, y, comp, req_comp, ri);}
	if (stbi__psd_test(s)) != 0 {return stbi__psd_load(s, x, y, comp, req_comp, ri, bpc);}
	if (stbi__tga_test(s)) != 0 {return stbi__tga_load(s, x, y, comp, req_comp, ri);}
	return if stbi__err("unknown image type"){0} else {0}
}

unsafe fn stbi__convert_16_to_8(orig:*mut u16, w:i32, h:i32, channels:i32) -> *mut u8 {
	let mut i:i32;
	let mut img_len:i32 = w * h * channels;
	let reduced:*mut u8;
	reduced = stbi__malloc(img_len);
	if reduced == std::ptr::null_mut() {return if stbi__err("outofmem"){0} else {0}}
	i = 0;;
while (i < img_len) {
i += 1;
reduced[i] = orig[i] >> 8 & 0xFF;}
	c_runtime::free(orig);
	return reduced;
}

unsafe fn stbi__convert_8_to_16(orig:*mut u8, w:i32, h:i32, channels:i32) -> *mut u16 {
	let mut i:i32;
	let mut img_len:i32 = w * h * channels;
	let enlarged:*mut u16;
	enlarged = stbi__malloc(img_len * 2);
	if enlarged == std::ptr::null_mut() {return if stbi__err("outofmem"){0} else {0}}
	i = 0;;
while (i < img_len) {
i += 1;
enlarged[i] = orig[i] << 8 + orig[i];}
	c_runtime::free(orig);
	return enlarged;
}

unsafe fn stbi__vertical_flip(image:*mut u8, w:i32, h:i32, bytes_per_pixel:i32){
	let mut row:i32;
	let mut bytes_per_row:u64 = w * bytes_per_pixel;
	let mut temp:[u8;2048] = unsafe {std::mem::uninitialized()};
	let bytes:*mut u8 = image;
	row = 0;;
while (row < h >> 1) {row += 1;

let row0:*mut u8 = bytes[row * bytes_per_row];let row1:*mut u8 = bytes[h - row - 1 * bytes_per_row];let mut bytes_left:u64 = bytes_per_row;while ((bytes_left) != 0) {
let mut bytes_copy:u64 = if bytes_left < 2048{bytes_left} else {2048};c_runtime::memcpy(temp, row0, bytes_copy);c_runtime::memcpy(row0, row1, bytes_copy);c_runtime::memcpy(row1, temp, bytes_copy);row0 += bytes_copy;row1 += bytes_copy;bytes_left -= bytes_copy;}}

}

unsafe fn stbi__load_and_postprocess_8bit(s:&mut stbi__context, x:*mut i32, y:*mut i32, comp:*mut i32, req_comp:i32) -> *mut u8 {
	let mut ri:stbi__result_info;
	let result:*mut u8 = stbi__load_main(s, x, y, comp, req_comp, ri, 8);
	if result == std::ptr::null_mut() {return std::ptr::null_mut();}
	if ri.bits_per_channel != 8 {
let mut cmp:i32 = req_comp;if cmp == 0 {cmp = comp;}result = stbi__convert_16_to_8(result, x, y, cmp);ri.bits_per_channel = 8;}
	if (stbi__vertically_flip_on_load) != 0 {
let mut channels:i32 = if req_comp{req_comp} else {comp};stbi__vertical_flip(result, x, y, channels);}
	return result;
}

unsafe fn stbi__load_and_postprocess_16bit(s:&mut stbi__context, x:*mut i32, y:*mut i32, comp:*mut i32, req_comp:i32) -> *mut u16 {
	let mut ri:stbi__result_info;
	let result:*mut u8 = stbi__load_main(s, x, y, comp, req_comp, ri, 16);
	if result == std::ptr::null_mut() {return std::ptr::null_mut();}
	if ri.bits_per_channel != 16 {
let mut cmp:i32 = req_comp;if cmp == 0 {cmp = comp;}result = stbi__convert_8_to_16(result, x, y, cmp);ri.bits_per_channel = 16;}
	if (stbi__vertically_flip_on_load) != 0 {
let mut channels:i32 = if req_comp{req_comp} else {comp};stbi__vertical_flip(result, x, y, channels * 2);}
	return result;
}

unsafe fn stbi_load_16_from_memory(buffer:*mut u8, len:i32, x:*mut i32, y:*mut i32, channels_in_file:*mut i32, desired_channels:i32) -> *mut u16 {
	let mut s:stbi__context;
	stbi__start_mem(s, buffer, len);
	return stbi__load_and_postprocess_16bit(s, x, y, channels_in_file, desired_channels);
}

unsafe fn stbi_load_16_from_callbacks(clbk:&mut stbi_io_callbacks, user:*mut u8, x:*mut i32, y:*mut i32, channels_in_file:*mut i32, desired_channels:i32) -> *mut u16 {
	let mut s:stbi__context;
	stbi__start_callbacks(s, clbk, user);
	return stbi__load_and_postprocess_16bit(s, x, y, channels_in_file, desired_channels);
}

unsafe fn stbi_load_from_memory(buffer:*mut u8, len:i32, x:*mut i32, y:*mut i32, comp:*mut i32, req_comp:i32) -> *mut u8 {
	let mut s:stbi__context;
	stbi__start_mem(s, buffer, len);
	return stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);
}

unsafe fn stbi_load_from_callbacks(clbk:&mut stbi_io_callbacks, user:*mut u8, x:*mut i32, y:*mut i32, comp:*mut i32, req_comp:i32) -> *mut u8 {
	let mut s:stbi__context;
	stbi__start_callbacks(s, clbk, user);
	return stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);
}

unsafe fn stbi_is_hdr_from_memory(buffer:*mut u8, len:i32) -> i32 {
	return 0;
}

unsafe fn stbi_is_hdr_from_callbacks(clbk:&mut stbi_io_callbacks, user:*mut u8) -> i32 {
	return 0;
}

unsafe fn stbi_hdr_to_ldr_gamma(gamma:f32){
	stbi__h2l_gamma_i = 1 / gamma;
}

unsafe fn stbi_hdr_to_ldr_scale(scale:f32){
	stbi__h2l_scale_i = 1 / scale;
}

unsafe fn stbi__refill_buffer(s:&mut stbi__context){
	let mut n:i32 = s.io.read(s.io_user_data, s.buffer_start, s.buflen);
	if n == 0 {
s.read_from_callbacks = 0;s.img_buffer = s.buffer_start;s.img_buffer_end = s.buffer_start[1];s.img_buffer = 0;} else {
s.img_buffer = s.buffer_start;s.img_buffer_end = s.buffer_start[n];}
}

unsafe fn stbi__get8(s:&mut stbi__context) -> u8 {
	if s.img_buffer < s.img_buffer_end {return s.img_buffer += 1;}
	if (s.read_from_callbacks) != 0 {
stbi__refill_buffer(s);return s.img_buffer += 1;}
	return 0;
}

unsafe fn stbi__at_eof(s:&mut stbi__context) -> i32 {
	if (s.io.read) != std::ptr::null_mut() {
if s.io.eof(s.io_user_data)== 0 {return 0;}if s.read_from_callbacks == 0 {return 1;}}
	return s.img_buffer >= s.img_buffer_end;
}

unsafe fn stbi__skip(s:&mut stbi__context, n:i32){
	if n < 0 {
s.img_buffer = s.img_buffer_end;return;}
	if (s.io.read) != std::ptr::null_mut() {
let mut blen:i32 = s.img_buffer_end - s.img_buffer;if blen < n {
s.img_buffer = s.img_buffer_end;s.io.skip(s.io_user_data, n - blen);return;}}
	s.img_buffer += n;
}

unsafe fn stbi__getn(s:&mut stbi__context, buffer:*mut u8, n:i32) -> i32 {
	if (s.io.read) != std::ptr::null_mut() {
let mut blen:i32 = s.img_buffer_end - s.img_buffer;if blen < n {
let mut res:i32;let mut count:i32;c_runtime::memcpy(buffer, s.img_buffer, blen);count = s.io.read(s.io_user_data, buffer[blen], n - blen);res = count == n - blen;s.img_buffer = s.img_buffer_end;return res;}}
	if s.img_buffer[n] <= s.img_buffer_end {
c_runtime::memcpy(buffer, s.img_buffer, n);s.img_buffer += n;return 1;} else {return 0;}
}

unsafe fn stbi__get16be(s:&mut stbi__context) -> i32 {
	let mut z:i32 = stbi__get8(s);
	return z << 8 + stbi__get8(s);
}

unsafe fn stbi__get32be(s:&mut stbi__context) -> u32 {
	let mut z:u32 = stbi__get16be(s);
	return z << 16 + stbi__get16be(s);
}

unsafe fn stbi__get16le(s:&mut stbi__context) -> i32 {
	let mut z:i32 = stbi__get8(s);
	return z + stbi__get8(s) << 8;
}

unsafe fn stbi__get32le(s:&mut stbi__context) -> u32 {
	let mut z:u32 = stbi__get16le(s);
	return z + stbi__get16le(s) << 16;
}

unsafe fn stbi__compute_y(r:i32, g:i32, b:i32) -> u8 {
	return r * 77 + g * 150 + 29 * b >> 8;
}

unsafe fn stbi__convert_format(data:*mut u8, img_n:i32, req_comp:i32, x:u32, y:u32) -> *mut u8 {
	let mut i:i32;let mut j:i32;
	let good:*mut u8;
	if req_comp == img_n {return data;}
	good = stbi__malloc_mad3(req_comp, x, y, 0);
	if good == std::ptr::null_mut() {
c_runtime::free(data);return if stbi__err("outofmem"){0} else {0}}
	j = 0;;
while (j < y) {j += 1;

let src:*mut u8 = data[j * x * img_n];let dest:*mut u8 = good[j * x * req_comp];{
if img_n * 8 + req_comp == 1 * 8 + 2 {i = x - 1;;
while (i >= 0) {i -= 1 ; src += 1; ; dest += 2;;

dest[0] = src[0];dest[1] = 255;}
} else if img_n * 8 + req_comp == 1 * 8 + 3 {i = x - 1;;
while (i >= 0) {i -= 1 ; src += 1; ; dest += 3;;

dest[0] = dest[1] = dest[2] = src[0];;;}
} else if img_n * 8 + req_comp == 1 * 8 + 4 {i = x - 1;;
while (i >= 0) {i -= 1 ; src += 1; ; dest += 4;;

dest[0] = dest[1] = dest[2] = src[0];;;dest[3] = 255;}
} else if img_n * 8 + req_comp == 2 * 8 + 1 {i = x - 1;;
while (i >= 0) {i -= 1 ; src += 2; ; dest += 1;;

dest[0] = src[0];}
} else if img_n * 8 + req_comp == 2 * 8 + 3 {i = x - 1;;
while (i >= 0) {i -= 1 ; src += 2; ; dest += 3;;

dest[0] = dest[1] = dest[2] = src[0];;;}
} else if img_n * 8 + req_comp == 2 * 8 + 4 {i = x - 1;;
while (i >= 0) {i -= 1 ; src += 2; ; dest += 4;;

dest[0] = dest[1] = dest[2] = src[0];;;dest[3] = src[1];}
} else if img_n * 8 + req_comp == 3 * 8 + 4 {i = x - 1;;
while (i >= 0) {i -= 1 ; src += 3; ; dest += 4;;

dest[0] = src[0];dest[1] = src[1];dest[2] = src[2];dest[3] = 255;}
} else if img_n * 8 + req_comp == 3 * 8 + 1 {i = x - 1;;
while (i >= 0) {i -= 1 ; src += 3; ; dest += 1;;

dest[0] = stbi__compute_y(src[0], src[1], src[2]);}
} else if img_n * 8 + req_comp == 3 * 8 + 2 {i = x - 1;;
while (i >= 0) {i -= 1 ; src += 3; ; dest += 2;;

dest[0] = stbi__compute_y(src[0], src[1], src[2]);dest[1] = 255;}
} else if img_n * 8 + req_comp == 4 * 8 + 1 {i = x - 1;;
while (i >= 0) {i -= 1 ; src += 4; ; dest += 1;;

dest[0] = stbi__compute_y(src[0], src[1], src[2]);}
} else if img_n * 8 + req_comp == 4 * 8 + 2 {i = x - 1;;
while (i >= 0) {i -= 1 ; src += 4; ; dest += 2;;

dest[0] = stbi__compute_y(src[0], src[1], src[2]);dest[1] = src[3];}
} else if img_n * 8 + req_comp == 4 * 8 + 3 {i = x - 1;;
while (i >= 0) {i -= 1 ; src += 4; ; dest += 3;;

dest[0] = src[0];dest[1] = src[1];dest[2] = src[2];}
} else { return if stbi__err("0"){0} else {0}}
}}

	c_runtime::free(data);
	return good;
}

unsafe fn stbi__compute_y_16(r:i32, g:i32, b:i32) -> u16 {
	return r * 77 + g * 150 + 29 * b >> 8;
}

unsafe fn stbi__convert_format16(data:*mut u16, img_n:i32, req_comp:i32, x:u32, y:u32) -> *mut u16 {
	let mut i:i32;let mut j:i32;
	let good:*mut u16;
	if req_comp == img_n {return data;}
	good = stbi__malloc(req_comp * x * y * 2);
	if good == std::ptr::null_mut() {
c_runtime::free(data);return if stbi__err("outofmem"){0} else {0}}
	j = 0;;
while (j < y) {j += 1;

let src:*mut u16 = data[j * x * img_n];let dest:*mut u16 = good[j * x * req_comp];{
if img_n * 8 + req_comp == 1 * 8 + 2 {i = x - 1;;
while (i >= 0) {i -= 1 ; src += 1; ; dest += 2;;

dest[0] = src[0];dest[1] = 0xffff;}
} else if img_n * 8 + req_comp == 1 * 8 + 3 {i = x - 1;;
while (i >= 0) {i -= 1 ; src += 1; ; dest += 3;;

dest[0] = dest[1] = dest[2] = src[0];;;}
} else if img_n * 8 + req_comp == 1 * 8 + 4 {i = x - 1;;
while (i >= 0) {i -= 1 ; src += 1; ; dest += 4;;

dest[0] = dest[1] = dest[2] = src[0];;;dest[3] = 0xffff;}
} else if img_n * 8 + req_comp == 2 * 8 + 1 {i = x - 1;;
while (i >= 0) {i -= 1 ; src += 2; ; dest += 1;;

dest[0] = src[0];}
} else if img_n * 8 + req_comp == 2 * 8 + 3 {i = x - 1;;
while (i >= 0) {i -= 1 ; src += 2; ; dest += 3;;

dest[0] = dest[1] = dest[2] = src[0];;;}
} else if img_n * 8 + req_comp == 2 * 8 + 4 {i = x - 1;;
while (i >= 0) {i -= 1 ; src += 2; ; dest += 4;;

dest[0] = dest[1] = dest[2] = src[0];;;dest[3] = src[1];}
} else if img_n * 8 + req_comp == 3 * 8 + 4 {i = x - 1;;
while (i >= 0) {i -= 1 ; src += 3; ; dest += 4;;

dest[0] = src[0];dest[1] = src[1];dest[2] = src[2];dest[3] = 0xffff;}
} else if img_n * 8 + req_comp == 3 * 8 + 1 {i = x - 1;;
while (i >= 0) {i -= 1 ; src += 3; ; dest += 1;;

dest[0] = stbi__compute_y_16(src[0], src[1], src[2]);}
} else if img_n * 8 + req_comp == 3 * 8 + 2 {i = x - 1;;
while (i >= 0) {i -= 1 ; src += 3; ; dest += 2;;

dest[0] = stbi__compute_y_16(src[0], src[1], src[2]);dest[1] = 0xffff;}
} else if img_n * 8 + req_comp == 4 * 8 + 1 {i = x - 1;;
while (i >= 0) {i -= 1 ; src += 4; ; dest += 1;;

dest[0] = stbi__compute_y_16(src[0], src[1], src[2]);}
} else if img_n * 8 + req_comp == 4 * 8 + 2 {i = x - 1;;
while (i >= 0) {i -= 1 ; src += 4; ; dest += 2;;

dest[0] = stbi__compute_y_16(src[0], src[1], src[2]);dest[1] = src[3];}
} else if img_n * 8 + req_comp == 4 * 8 + 3 {i = x - 1;;
while (i >= 0) {i -= 1 ; src += 4; ; dest += 3;;

dest[0] = src[0];dest[1] = src[1];dest[2] = src[2];}
} else { return if stbi__err("0"){0} else {0}}
}}

	c_runtime::free(data);
	return good;
}

unsafe fn stbi__build_huffman(h:&mut stbi__huffman, count:*mut i32) -> i32 {
	let mut i:i32;let mut j:i32;let mut k:i32 = 0;let mut code:i32;
	i = 0;;
while (i < 16) {
i += 1;
j = 0;;
while (j < count[i]) {
j += 1;
h.size[k += 1] = i + 1;}}
	h.size[k] = 0;
	code = 0;
	k = 0;
	j = 1;;
while (j <= 16) {j += 1;

h.delta[j] = k - code;if h.size[k] == j {
while (h.size[k] == j) {h.code[k += 1] = code += 1;}if code - 1 >= 1 << j {return stbi__err("bad code lengths");}}h.maxcode[j] = code << 16 - j;code <<= 1;}

	h.maxcode[j] = 0xffffffff;
	c_runtime::memset(h.fast, 255, 1 << 9);
	i = 0;;
while (i < k) {i += 1;

let mut s:i32 = h.size[i];if s <= 9 {
let mut c:i32 = h.code[i] << 9 - s;let mut m:i32 = 1 << 9 - s;j = 0;;
while (j < m) {j += 1;

h.fast[c + j] = i;}
}}

	return 1;
}

unsafe fn stbi__build_fast_ac(fast_ac:*mut i16, h:&mut stbi__huffman){
	let mut i:i32;
	i = 0;;
while (i < 1 << 9) {i += 1;

let mut fast:u8 = h.fast[i];fast_ac[i] = 0;if fast < 255 {
let mut rs:i32 = h.values[fast];let mut run:i32 = rs >> 4 & 15;let mut magbits:i32 = rs & 15;let mut len:i32 = h.size[fast];if (magbits) != 0 && len + magbits <= 9 {
let mut k:i32 = i << len & 1 << 9 - 1 >> 9 - magbits;let mut m:i32 = 1 << magbits - 1;if k < m {k += !0 << magbits + 1;}if k >= -128 && k <= 127 {fast_ac[i] = k << 8 + run << 4 + len + magbits;}}}}

}

unsafe fn stbi__grow_buffer_unsafe(j:&mut stbi__jpeg){
	while(true) {
let mut b:i32 = if j.nomore{0} else {stbi__get8(j.s)};if b == 0xff {
let mut c:i32 = stbi__get8(j.s);while (c == 0xff) {c = stbi__get8(j.s);}if c != 0 {
j.marker = c;j.nomore = 1;return;}}j.code_buffer |= b << 24 - j.code_bits;j.code_bits += 8;if !(j.code_bits <= 24) {break;}}

}

unsafe fn stbi__jpeg_huff_decode(j:&mut stbi__jpeg, h:&mut stbi__huffman) -> i32 {
	let mut temp:u32;
	let mut c:i32;let mut k:i32;
	if j.code_bits < 16 {stbi__grow_buffer_unsafe(j);}
	c = j.code_buffer >> 32 - 9 & 1 << 9 - 1;
	k = h.fast[c];
	if k < 255 {
let mut s:i32 = h.size[k];if s > j.code_bits {return -1;}j.code_buffer <<= s;j.code_bits -= s;return h.values[k];}
	temp = j.code_buffer >> 16;
	k = 9 + 1;;
while () {
k += 1;
if temp < h.maxcode[k] {}}
	if k == 17 {
j.code_bits -= 16;return -1;}
	if k > j.code_bits {return -1;}
	c = j.code_buffer >> 32 - k & stbi__bmask[k] + h.delta[k];
	j.code_bits -= k;
	j.code_buffer <<= k;
	return h.values[c];
}

unsafe fn stbi__extend_receive(j:&mut stbi__jpeg, n:i32) -> i32 {
	let mut k:u32;
	let mut sgn:i32;
	if j.code_bits < n {stbi__grow_buffer_unsafe(j);}
	sgn = j.code_buffer >> 31;
	k = c_runtime::_lrotl(j.code_buffer, n);
	j.code_buffer = k & !stbi__bmask[n];
	k &= stbi__bmask[n];
	j.code_bits -= n;
	return k + stbi__jbias[n] & !sgn;
}

unsafe fn stbi__jpeg_get_bits(j:&mut stbi__jpeg, n:i32) -> i32 {
	let mut k:u32;
	if j.code_bits < n {stbi__grow_buffer_unsafe(j);}
	k = c_runtime::_lrotl(j.code_buffer, n);
	j.code_buffer = k & !stbi__bmask[n];
	k &= stbi__bmask[n];
	j.code_bits -= n;
	return k;
}

unsafe fn stbi__jpeg_get_bit(j:&mut stbi__jpeg) -> i32 {
	let mut k:u32;
	if j.code_bits < 1 {stbi__grow_buffer_unsafe(j);}
	k = j.code_buffer;
	j.code_buffer <<= 1;
	j.code_bits -= 1;
	return k & 0x80000000;
}

unsafe fn stbi__jpeg_decode_block(j:&mut stbi__jpeg, data:[i16;64], hdc:&mut stbi__huffman, hac:&mut stbi__huffman, fac:*mut i16, b:i32, dequant:*mut u16) -> i32 {
	let mut diff:i32;let mut dc:i32;let mut k:i32;
	let mut t:i32;
	if j.code_bits < 16 {stbi__grow_buffer_unsafe(j);}
	t = stbi__jpeg_huff_decode(j, hdc);
	if t < 0 {return stbi__err("bad huffman code");}
	c_runtime::memset(data, 0, 64 * std::mem::size_of(data[0]));
	diff = if t{stbi__extend_receive(j, t)} else {0};
	dc = j.img_comp[b].dc_pred + diff;
	j.img_comp[b].dc_pred = dc;
	data[0] = dc * dequant[0];
	k = 1;
	while(true) {
let mut zig:u32;let mut c:i32;let mut r:i32;let mut s:i32;if j.code_bits < 16 {stbi__grow_buffer_unsafe(j);}c = j.code_buffer >> 32 - 9 & 1 << 9 - 1;r = fac[c];if (r) != 0 {
k += r >> 4 & 15;s = r & 15;j.code_buffer <<= s;j.code_bits -= s;zig = stbi__jpeg_dezigzag[k += 1];data[zig] = r >> 8 * dequant[zig];} else {
let mut rs:i32 = stbi__jpeg_huff_decode(j, hac);if rs < 0 {return stbi__err("bad huffman code");}s = rs & 15;r = rs >> 4;if s == 0 {
if rs != 0xf0 {}k += 16;} else {
k += r;zig = stbi__jpeg_dezigzag[k += 1];data[zig] = stbi__extend_receive(j, s) * dequant[zig];}}if !(k < 64) {break;}}

	return 1;
}

unsafe fn stbi__jpeg_decode_block_prog_dc(j:&mut stbi__jpeg, data:[i16;64], hdc:&mut stbi__huffman, b:i32) -> i32 {
	let mut diff:i32;let mut dc:i32;
	let mut t:i32;
	if j.spec_end != 0 {return stbi__err("can't merge dc and ac");}
	if j.code_bits < 16 {stbi__grow_buffer_unsafe(j);}
	if j.succ_high == 0 {
c_runtime::memset(data, 0, 64 * std::mem::size_of(data[0]));t = stbi__jpeg_huff_decode(j, hdc);diff = if t{stbi__extend_receive(j, t)} else {0};dc = j.img_comp[b].dc_pred + diff;j.img_comp[b].dc_pred = dc;data[0] = dc << j.succ_low;} else {
if (stbi__jpeg_get_bit(j)) != 0 {data[0] += 1 << j.succ_low;}}
	return 1;
}

unsafe fn stbi__jpeg_decode_block_prog_ac(j:&mut stbi__jpeg, data:[i16;64], hac:&mut stbi__huffman, fac:*mut i16) -> i32 {
	let mut k:i32;
	if j.spec_start == 0 {return stbi__err("can't merge dc and ac");}
	if j.succ_high == 0 {
let mut shift:i32 = j.succ_low;if (j.eob_run) != 0 {
j.eob_run -= 1;return 1;}k = j.spec_start;while(true) {
let mut zig:u32;let mut c:i32;let mut r:i32;let mut s:i32;if j.code_bits < 16 {stbi__grow_buffer_unsafe(j);}c = j.code_buffer >> 32 - 9 & 1 << 9 - 1;r = fac[c];if (r) != 0 {
k += r >> 4 & 15;s = r & 15;j.code_buffer <<= s;j.code_bits -= s;zig = stbi__jpeg_dezigzag[k += 1];data[zig] = r >> 8 << shift;} else {
let mut rs:i32 = stbi__jpeg_huff_decode(j, hac);if rs < 0 {return stbi__err("bad huffman code");}s = rs & 15;r = rs >> 4;if s == 0 {
if r < 15 {
j.eob_run = 1 << r;if (r) != 0 {j.eob_run += stbi__jpeg_get_bits(j, r);}j.eob_run -= 1;}k += 16;} else {
k += r;zig = stbi__jpeg_dezigzag[k += 1];data[zig] = stbi__extend_receive(j, s) << shift;}}if !(k <= j.spec_end) {break;}}
} else {
let mut bit:i16 = 1 << j.succ_low;if (j.eob_run) != 0 {
j.eob_run -= 1;k = j.spec_start;;
while (k <= j.spec_end) {k += 1;

let p:*mut i16 = data[stbi__jpeg_dezigzag[k]];if p != 0 {if (stbi__jpeg_get_bit(j)) != 0 {if p & bit == 0 {
if p > 0 {p += bit;} else {p -= bit;}}}}}
} else {
k = j.spec_start;while(true) {
let mut r:i32;let mut s:i32;let mut rs:i32 = stbi__jpeg_huff_decode(j, hac);if rs < 0 {return stbi__err("bad huffman code");}s = rs & 15;r = rs >> 4;if s == 0 {
if r < 15 {
j.eob_run = 1 << r - 1;if (r) != 0 {j.eob_run += stbi__jpeg_get_bits(j, r);}r = 64;} else {
}} else {
if s != 1 {return stbi__err("bad huffman code");}if (stbi__jpeg_get_bit(j)) != 0 {s = bit;} else {s = -bit;}}while (k <= j.spec_end) {
let p:*mut i16 = data[stbi__jpeg_dezigzag[k += 1]];if p != 0 {
if (stbi__jpeg_get_bit(j)) != 0 {if p & bit == 0 {
if p > 0 {p += bit;} else {p -= bit;}}}} else {
if r == 0 {
p = s;}r -= 1;}}if !(k <= j.spec_end) {break;}}
}}
	return 1;
}

unsafe fn stbi__clamp(x:i32) -> u8 {
	if x > 255 {
if x < 0 {return 0;}if x > 255 {return 255;}}
	return x;
}

unsafe fn stbi__idct_block(_out_:*mut u8, out_stride:i32, data:[i16;64]){
	let mut i:i32;let mut val:[i32;64] = unsafe {std::mem::uninitialized()};let v:*mut i32 = val;
	let o:*mut u8;
	let d:*mut i16 = data;
	i = 0;;
while (i < 8) {i += 1 ; d += 1 ; v += 1;

if d[8] == 0 && d[16] == 0 && d[24] == 0 && d[32] == 0 && d[40] == 0 && d[48] == 0 && d[56] == 0 {
let mut dcterm:i32 = d[0] << 2;v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;;;;;;;;} else {
let mut t0:i32;let mut t1:i32;let mut t2:i32;let mut t3:i32;let mut p1:i32;let mut p2:i32;let mut p3:i32;let mut p4:i32;let mut p5:i32;let mut x0:i32;let mut x1:i32;let mut x2:i32;let mut x3:i32;p2 = d[16];p3 = d[48];p1 = p2 + p3 * 0.5411961f32 * 4096 + 0.5;t2 = p1 + p3 * -1.847759065f32 * 4096 + 0.5;t3 = p1 + p2 * 0.765366865f32 * 4096 + 0.5;p2 = d[0];p3 = d[32];t0 = p2 + p3 << 12;t1 = p2 - p3 << 12;x0 = t0 + t3;x3 = t0 - t3;x1 = t1 + t2;x2 = t1 - t2;t0 = d[56];t1 = d[40];t2 = d[24];t3 = d[8];p3 = t0 + t2;p4 = t1 + t3;p1 = t0 + t3;p2 = t1 + t2;p5 = p3 + p4 * 1.175875602f32 * 4096 + 0.5;t0 = t0 * 0.298631336f32 * 4096 + 0.5;t1 = t1 * 2.053119869f32 * 4096 + 0.5;t2 = t2 * 3.072711026f32 * 4096 + 0.5;t3 = t3 * 1.501321110f32 * 4096 + 0.5;p1 = p5 + p1 * -0.899976223f32 * 4096 + 0.5;p2 = p5 + p2 * -2.562915447f32 * 4096 + 0.5;p3 = p3 * -1.961570560f32 * 4096 + 0.5;p4 = p4 * -0.390180644f32 * 4096 + 0.5;t3 += p1 + p4;t2 += p2 + p3;t1 += p2 + p4;t0 += p1 + p3;x0 += 512;x1 += 512;x2 += 512;x3 += 512;v[0] = x0 + t3 >> 10;v[56] = x0 - t3 >> 10;v[8] = x1 + t2 >> 10;v[48] = x1 - t2 >> 10;v[16] = x2 + t1 >> 10;v[40] = x2 - t1 >> 10;v[24] = x3 + t0 >> 10;v[32] = x3 - t0 >> 10;}}

	i = 0; ; v = val; ; o = _out_;;
while (i < 8) {i += 1 ; v += 8; ; o += out_stride;;

let mut t0:i32;let mut t1:i32;let mut t2:i32;let mut t3:i32;let mut p1:i32;let mut p2:i32;let mut p3:i32;let mut p4:i32;let mut p5:i32;let mut x0:i32;let mut x1:i32;let mut x2:i32;let mut x3:i32;p2 = v[2];p3 = v[6];p1 = p2 + p3 * 0.5411961f32 * 4096 + 0.5;t2 = p1 + p3 * -1.847759065f32 * 4096 + 0.5;t3 = p1 + p2 * 0.765366865f32 * 4096 + 0.5;p2 = v[0];p3 = v[4];t0 = p2 + p3 << 12;t1 = p2 - p3 << 12;x0 = t0 + t3;x3 = t0 - t3;x1 = t1 + t2;x2 = t1 - t2;t0 = v[7];t1 = v[5];t2 = v[3];t3 = v[1];p3 = t0 + t2;p4 = t1 + t3;p1 = t0 + t3;p2 = t1 + t2;p5 = p3 + p4 * 1.175875602f32 * 4096 + 0.5;t0 = t0 * 0.298631336f32 * 4096 + 0.5;t1 = t1 * 2.053119869f32 * 4096 + 0.5;t2 = t2 * 3.072711026f32 * 4096 + 0.5;t3 = t3 * 1.501321110f32 * 4096 + 0.5;p1 = p5 + p1 * -0.899976223f32 * 4096 + 0.5;p2 = p5 + p2 * -2.562915447f32 * 4096 + 0.5;p3 = p3 * -1.961570560f32 * 4096 + 0.5;p4 = p4 * -0.390180644f32 * 4096 + 0.5;t3 += p1 + p4;t2 += p2 + p3;t1 += p2 + p4;t0 += p1 + p3;x0 += 65536 + 128 << 17;x1 += 65536 + 128 << 17;x2 += 65536 + 128 << 17;x3 += 65536 + 128 << 17;o[0] = stbi__clamp(x0 + t3 >> 17);o[7] = stbi__clamp(x0 - t3 >> 17);o[1] = stbi__clamp(x1 + t2 >> 17);o[6] = stbi__clamp(x1 - t2 >> 17);o[2] = stbi__clamp(x2 + t1 >> 17);o[5] = stbi__clamp(x2 - t1 >> 17);o[3] = stbi__clamp(x3 + t0 >> 17);o[4] = stbi__clamp(x3 - t0 >> 17);}

}

unsafe fn stbi__get_marker(j:&mut stbi__jpeg) -> u8 {
	let mut x:u8;
	if j.marker != 0xff {
x = j.marker;j.marker = 0xff;return x;}
	x = stbi__get8(j.s);
	if x != 0xff {return 0xff;}
	while (x == 0xff) {x = stbi__get8(j.s);}
	return x;
}

unsafe fn stbi__jpeg_reset(j:&mut stbi__jpeg){
	j.code_bits = 0;
	j.code_buffer = 0;
	j.nomore = 0;
	j.img_comp[0].dc_pred = j.img_comp[1].dc_pred = j.img_comp[2].dc_pred = j.img_comp[3].dc_pred = 0;;;;
	j.marker = 0xff;
	j.todo = if j.restart_interval{j.restart_interval} else {0x7fffffff};
	j.eob_run = 0;
}

unsafe fn stbi__parse_entropy_coded_data(z:&mut stbi__jpeg) -> i32 {
	stbi__jpeg_reset(z);
	if z.progressive== 0 {
if z.scan_n == 1 {
let mut i:i32;let mut j:i32;let mut data:[i16;64] = unsafe {std::mem::uninitialized()};let mut n:i32 = z.order[0];let mut w:i32 = z.img_comp[n].x + 7 >> 3;let mut h:i32 = z.img_comp[n].y + 7 >> 3;j = 0;;
while (j < h) {j += 1;

i = 0;;
while (i < w) {i += 1;

let mut ha:i32 = z.img_comp[n].ha;if stbi__jpeg_decode_block(z, data, z.huff_dc[z.img_comp[n].hd], z.huff_ac[ha], z.fast_ac[ha], n, z.dequant[z.img_comp[n].tq])== 0 {return 0;}z.idct_block_kernel(z.img_comp[n].data[z.img_comp[n].w2 * j * 8][i * 8], z.img_comp[n].w2, data);if z.todo -= 1 <= 0 {
if z.code_bits < 24 {stbi__grow_buffer_unsafe(z);}if !z.marker >= 0xd0 && z.marker <= 0xd7 {return 1;}stbi__jpeg_reset(z);}}
}
return 1;} else {
let mut i:i32;let mut j:i32;let mut k:i32;let mut x:i32;let mut y:i32;let mut data:[i16;64] = unsafe {std::mem::uninitialized()};j = 0;;
while (j < z.img_mcu_y) {j += 1;

i = 0;;
while (i < z.img_mcu_x) {i += 1;

k = 0;;
while (k < z.scan_n) {k += 1;

let mut n:i32 = z.order[k];y = 0;;
while (y < z.img_comp[n].v) {y += 1;

x = 0;;
while (x < z.img_comp[n].h) {x += 1;

let mut x2:i32 = i * z.img_comp[n].h + x * 8;let mut y2:i32 = j * z.img_comp[n].v + y * 8;let mut ha:i32 = z.img_comp[n].ha;if stbi__jpeg_decode_block(z, data, z.huff_dc[z.img_comp[n].hd], z.huff_ac[ha], z.fast_ac[ha], n, z.dequant[z.img_comp[n].tq])== 0 {return 0;}z.idct_block_kernel(z.img_comp[n].data[z.img_comp[n].w2 * y2][x2], z.img_comp[n].w2, data);}
}
}
if z.todo -= 1 <= 0 {
if z.code_bits < 24 {stbi__grow_buffer_unsafe(z);}if !z.marker >= 0xd0 && z.marker <= 0xd7 {return 1;}stbi__jpeg_reset(z);}}
}
return 1;}} else {
if z.scan_n == 1 {
let mut i:i32;let mut j:i32;let mut n:i32 = z.order[0];let mut w:i32 = z.img_comp[n].x + 7 >> 3;let mut h:i32 = z.img_comp[n].y + 7 >> 3;j = 0;;
while (j < h) {j += 1;

i = 0;;
while (i < w) {i += 1;

let data:*mut i16 = z.img_comp[n].coeff[64 * i + j * z.img_comp[n].coeff_w];if z.spec_start == 0 {
if stbi__jpeg_decode_block_prog_dc(z, data, z.huff_dc[z.img_comp[n].hd], n)== 0 {return 0;}} else {
let mut ha:i32 = z.img_comp[n].ha;if stbi__jpeg_decode_block_prog_ac(z, data, z.huff_ac[ha], z.fast_ac[ha])== 0 {return 0;}}if z.todo -= 1 <= 0 {
if z.code_bits < 24 {stbi__grow_buffer_unsafe(z);}if !z.marker >= 0xd0 && z.marker <= 0xd7 {return 1;}stbi__jpeg_reset(z);}}
}
return 1;} else {
let mut i:i32;let mut j:i32;let mut k:i32;let mut x:i32;let mut y:i32;j = 0;;
while (j < z.img_mcu_y) {j += 1;

i = 0;;
while (i < z.img_mcu_x) {i += 1;

k = 0;;
while (k < z.scan_n) {k += 1;

let mut n:i32 = z.order[k];y = 0;;
while (y < z.img_comp[n].v) {y += 1;

x = 0;;
while (x < z.img_comp[n].h) {x += 1;

let mut x2:i32 = i * z.img_comp[n].h + x;let mut y2:i32 = j * z.img_comp[n].v + y;let data:*mut i16 = z.img_comp[n].coeff[64 * x2 + y2 * z.img_comp[n].coeff_w];if stbi__jpeg_decode_block_prog_dc(z, data, z.huff_dc[z.img_comp[n].hd], n)== 0 {return 0;}}
}
}
if z.todo -= 1 <= 0 {
if z.code_bits < 24 {stbi__grow_buffer_unsafe(z);}if !z.marker >= 0xd0 && z.marker <= 0xd7 {return 1;}stbi__jpeg_reset(z);}}
}
return 1;}}
}

unsafe fn stbi__jpeg_dequantize(data:*mut i16, dequant:*mut u16){
	let mut i:i32;
	i = 0;;
while (i < 64) {
i += 1;
data[i] *= dequant[i];}
}

unsafe fn stbi__jpeg_finish(z:&mut stbi__jpeg){
	if (z.progressive) != 0 {
let mut i:i32;let mut j:i32;let mut n:i32;n = 0;;
while (n < z.s.img_n) {n += 1;

let mut w:i32 = z.img_comp[n].x + 7 >> 3;let mut h:i32 = z.img_comp[n].y + 7 >> 3;j = 0;;
while (j < h) {j += 1;

i = 0;;
while (i < w) {i += 1;

let data:*mut i16 = z.img_comp[n].coeff[64 * i + j * z.img_comp[n].coeff_w];stbi__jpeg_dequantize(data, z.dequant[z.img_comp[n].tq]);z.idct_block_kernel(z.img_comp[n].data[z.img_comp[n].w2 * j * 8][i * 8], z.img_comp[n].w2, data);}
}
}
}
}

unsafe fn stbi__process_marker(z:&mut stbi__jpeg, m:i32) -> i32 {
    let mut L: i32;
    {
        if m == 0xff { return stbi__err("expected marker"); } else if m == 0xDD {
            if stbi__get16be(z.s) != 4 { return stbi__err("bad DRI len"); }
            z.restart_interval = stbi__get16be(z.s);
            return 1;
        } else if m == 0xDB {
            L = stbi__get16be(z.s) - 2;
            while (L > 0) {
                let mut q: i32 = stbi__get8(z.s);
                let mut p: i32 = q >> 4;
                let mut sixteen: i32 = p != 0;
                let mut t: i32 = q & 15;
                let mut i: i32;
                if p != 0 && p != 1 { return stbi__err("bad DQT type"); }
                if t > 3 { return stbi__err("bad DQT table"); }
                i = 0;
                ;
                while (i < 64) {
                    i += 1;
                    z.dequant[t][stbi__jpeg_dezigzag[i]] = if sixteen { stbi__get16be(z.s) } else { stbi__get8(z.s) };
                }
                L -= if sixteen { 129 } else { 65 };
            }
            return L == 0;
        } else if m == 0xC4 {
            L = stbi__get16be(z.s) - 2;
            while (L > 0) {
                let v: *mut u8;
                let mut sizes: [i32; 16] = unsafe { std::mem::uninitialized() };
                let mut i: i32;
                let mut n: i32 = 0;
                let mut q: i32 = stbi__get8(z.s);
                let mut tc: i32 = q >> 4;
                let mut th: i32 = q & 15;
                if tc > 1 || th > 3 { return stbi__err("bad DHT header"); }
                i = 0;
                ;
                while (i < 16) {
                    i += 1;

                    sizes[i] = stbi__get8(z.s);
                    n += sizes[i];
                }
                L -= 17;
                if tc == 0 {
                    if stbi__build_huffman(z.huff_dc[th], sizes) == 0 { return 0; }
                    v = z.huff_dc[th].values;
                } else {
                    if stbi__build_huffman(z.huff_ac[th], sizes) == 0 { return 0; }
                    v = z.huff_ac[th].values;
                }
                i = 0;
                ;
                while (i < n) {
                    i += 1;
                    v[i] = stbi__get8(z.s);
                }
                if tc != 0 { stbi__build_fast_ac(z.fast_ac[th], z.huff_ac[th]); }
                L -= n;
            }
            return L == 0;
        }
    }
    if m >= 0xE0 && m <= 0xEF || m == 0xFE {
        L = stbi__get16be(z.s);
        if L < 2 {
            if m == 0xFE { return stbi__err("bad COM len"); } else { return stbi__err("bad APP len"); }
        }
        L -= 2;
        if m == 0xE0 && L >= 5 {
            let mut tag: [u8; 5] = unsafe { std::mem::uninitialized() };
            let mut ok: i32 = 1;
            let mut i: i32;
            i = 0;
            ;
            while (i < 5) {
                i += 1;
                if stbi__get8(z.s) != tag[i] { ok = 0; }
            }
            L -= 5;
            if (ok) != 0 { z.jfif = 1; }
        } else {
            if m == 0xEE && L >= 12 {
                let mut tag: [u8; 6] = unsafe { std::mem::uninitialized() };
                let mut ok: i32 = 1;
                let mut i: i32;
                i = 0;
                ;
                while (i < 6) {
                    i += 1;
                    if stbi__get8(z.s) != tag[i] { ok = 0; }
                }
                L -= 6;
                if (ok) != 0 {
                    stbi__get8(z.s);
                    stbi__get16be(z.s.as_mut());
                    stbi__get16be(z.s);
                    z.app14_color_transform = stbi__get8(z.s);
                    L -= 6;
                }
            }
        }
        stbi__skip(z.s, L);
        return 1;
    }
    return stbi__err("unknown marker");
}

unsafe fn stbi__process_scan_header(z:&mut stbi__jpeg) -> i32 {
	let mut i:i32;
	let mut Ls:i32 = stbi__get16be(z.s);
	z.scan_n = stbi__get8(z.s);
	if z.scan_n < 1 || z.scan_n > 4 || z.scan_n > z.s.img_n {return stbi__err("bad SOS component count");}
	if Ls != 6 + 2 * z.scan_n {return stbi__err("bad SOS len");}
	i = 0;;
while (i < z.scan_n) {i += 1;

let mut id:i32 = stbi__get8(z.s);let mut which:i32;let mut q:i32 = stbi__get8(z.s);which = 0;;
while (which < z.s.img_n) {
which += 1;
if z.img_comp[which].id == id {}}if which == z.s.img_n {return 0;}z.img_comp[which].hd = q >> 4;if z.img_comp[which].hd > 3 {return stbi__err("bad DC huff");}z.img_comp[which].ha = q & 15;if z.img_comp[which].ha > 3 {return stbi__err("bad AC huff");}z.order[i] = which;}

	{
let mut aa:i32;z.spec_start = stbi__get8(z.s);z.spec_end = stbi__get8(z.s);aa = stbi__get8(z.s);z.succ_high = aa >> 4;z.succ_low = aa & 15;if (z.progressive) != 0 {
if z.spec_start > 63 || z.spec_end > 63 || z.spec_start > z.spec_end || z.succ_high > 13 || z.succ_low > 13 {return stbi__err("bad SOS");}} else {
if z.spec_start != 0 {return stbi__err("bad SOS");}if z.succ_high != 0 || z.succ_low != 0 {return stbi__err("bad SOS");}z.spec_end = 63;}}

	return 1;
}

unsafe fn stbi__free_jpeg_components(z:&mut stbi__jpeg, ncomp:i32, why:i32) -> i32 {
	let mut i:i32;
	i = 0;;
while (i < ncomp) {i += 1;

if (z.img_comp[i].raw_data) != std::ptr::null_mut() {
c_runtime::free(z.img_comp[i].raw_data);z.img_comp[i].raw_data = std::ptr::null_mut();z.img_comp[i].data = std::ptr::null_mut();}if (z.img_comp[i].raw_coeff) != std::ptr::null_mut() {
c_runtime::free(z.img_comp[i].raw_coeff);z.img_comp[i].raw_coeff = std::ptr::null_mut();z.img_comp[i].coeff = std::ptr::null_mut();}if (z.img_comp[i].linebuf) != std::ptr::null_mut() {
c_runtime::free(z.img_comp[i].linebuf);z.img_comp[i].linebuf = std::ptr::null_mut();}}

	return why;
}

unsafe fn stbi__process_frame_header(z:&mut stbi__jpeg, scan:i32) -> i32 {
	let s:&mut stbi__context = z.s;
	let mut Lf:i32;let mut p:i32;let mut i:i32;let mut q:i32;let mut h_max:i32 = 1;let mut v_max:i32 = 1;let mut c:i32;
	Lf = stbi__get16be(s);
	if Lf < 11 {return stbi__err("bad SOF len");}
	p = stbi__get8(s);
	if p != 8 {return stbi__err("only 8-bit");}
	s.img_y = stbi__get16be(s);
	if s.img_y == 0 {return stbi__err("no header height");}
	s.img_x = stbi__get16be(s);
	if s.img_x == 0 {return stbi__err("0 width");}
	c = stbi__get8(s);
	if c != 3 && c != 1 && c != 4 {return stbi__err("bad component count");}
	s.img_n = c;
	i = 0;;
while (i < c) {i += 1;

z.img_comp[i].data = std::ptr::null_mut();z.img_comp[i].linebuf = std::ptr::null_mut();}

	if Lf != 8 + 3 * s.img_n {return stbi__err("bad SOF len");}
	z.rgb = 0;
	i = 0;;
while (i < s.img_n) {i += 1;

let mut rgb:[u8;3] = unsafe {std::mem::uninitialized()};z.img_comp[i].id = stbi__get8(s);if s.img_n == 3 && z.img_comp[i].id == rgb[i] {z.rgb += 1;}q = stbi__get8(s);z.img_comp[i].h = q >> 4;if z.img_comp[i].h== 0 || z.img_comp[i].h > 4 {return stbi__err("bad H");}z.img_comp[i].v = q & 15;if z.img_comp[i].v== 0 || z.img_comp[i].v > 4 {return stbi__err("bad V");}z.img_comp[i].tq = stbi__get8(s);if z.img_comp[i].tq > 3 {return stbi__err("bad TQ");}}

	if scan != STBI__SCAN_load {return 1;}
	if stbi__mad3sizes_valid(s.img_x, s.img_y, s.img_n, 0)== 0 {return stbi__err("too large");}
	i = 0;;
while (i < s.img_n) {i += 1;

if z.img_comp[i].h > h_max {h_max = z.img_comp[i].h;}if z.img_comp[i].v > v_max {v_max = z.img_comp[i].v;}}

	z.img_h_max = h_max;
	z.img_v_max = v_max;
	z.img_mcu_w = h_max * 8;
	z.img_mcu_h = v_max * 8;
	z.img_mcu_x = s.img_x + z.img_mcu_w - 1 / z.img_mcu_w;
	z.img_mcu_y = s.img_y + z.img_mcu_h - 1 / z.img_mcu_h;
	i = 0;;
while (i < s.img_n) {i += 1;

z.img_comp[i].x = s.img_x * z.img_comp[i].h + h_max - 1 / h_max;z.img_comp[i].y = s.img_y * z.img_comp[i].v + v_max - 1 / v_max;z.img_comp[i].w2 = z.img_mcu_x * z.img_comp[i].h * 8;z.img_comp[i].h2 = z.img_mcu_y * z.img_comp[i].v * 8;z.img_comp[i].coeff = std::ptr::null_mut();z.img_comp[i].raw_coeff = std::ptr::null_mut();z.img_comp[i].linebuf = std::ptr::null_mut();z.img_comp[i].raw_data = stbi__malloc_mad2(z.img_comp[i].w2, z.img_comp[i].h2, 15);if z.img_comp[i].raw_data == std::ptr::null_mut() {return stbi__free_jpeg_components(z, i + 1, stbi__err("outofmem"));}z.img_comp[i].data = z.img_comp[i].raw_data + 15 & !15;if (z.progressive) != 0 {
z.img_comp[i].coeff_w = z.img_comp[i].w2 / 8;z.img_comp[i].coeff_h = z.img_comp[i].h2 / 8;z.img_comp[i].raw_coeff = stbi__malloc_mad3(z.img_comp[i].w2, z.img_comp[i].h2, 2, 15);if z.img_comp[i].raw_coeff == std::ptr::null_mut() {return stbi__free_jpeg_components(z, i + 1, stbi__err("outofmem"));}z.img_comp[i].coeff = z.img_comp[i].raw_coeff + 15 & !15;}}

	return 1;
}

unsafe fn stbi__decode_jpeg_header(z:&mut stbi__jpeg, scan:i32) -> i32 {
	let mut m:i32;
	z.jfif = 0;
	z.app14_color_transform = -1;
	z.marker = 0xff;
	m = stbi__get_marker(z);
	if !m == 0xd8 {return stbi__err("no SOI");}
	if scan == STBI__SCAN_type {return 1;}
	m = stbi__get_marker(z);
	while (!m == 0xc0 || m == 0xc1 || m == 0xc2) {
if stbi__process_marker(z, m)== 0 {return 0;}m = stbi__get_marker(z);while (m == 0xff) {
if (stbi__at_eof(z.s)) != 0 {return stbi__err("no SOF");}m = stbi__get_marker(z);}}
	z.progressive = m == 0xc2;
	if stbi__process_frame_header(z, scan)== 0 {return 0;}
	return 1;
}

unsafe fn stbi__decode_jpeg_image(j:&mut stbi__jpeg) -> i32 {
	let mut m:i32;
	m = 0;;
while (m < 4) {m += 1;

j.img_comp[m].raw_data = std::ptr::null_mut();j.img_comp[m].raw_coeff = std::ptr::null_mut();}

	j.restart_interval = 0;
	if stbi__decode_jpeg_header(j, STBI__SCAN_load)== 0 {return 0;}
	m = stbi__get_marker(j);
	while (!m == 0xd9) {
if m == 0xda {
if stbi__process_scan_header(j)== 0 {return 0;}if stbi__parse_entropy_coded_data(j)== 0 {return 0;}if j.marker == 0xff {
while (stbi__at_eof(j.s)== 0) {
let mut x:i32 = stbi__get8(j.s);if x == 255 {
j.marker = stbi__get8(j.s);}}}} else {if m == 0xdc {
let mut Ld:i32 = stbi__get16be(j.s);let mut NL:u32 = stbi__get16be(j.s);if Ld != 4 {stbi__err("bad DNL len");}if NL != j.s.img_y {stbi__err("bad DNL height");}} else {
if stbi__process_marker(j, m)== 0 {return 0;}}}m = stbi__get_marker(j);}
	if (j.progressive) != 0 {stbi__jpeg_finish(j);}
	return 1;
}

unsafe fn resample_row_1(_out_:*mut u8, in_near:*mut u8, in_far:*mut u8, w:i32, hs:i32) -> *mut u8 {
	return in_near;
}

unsafe fn stbi__resample_row_v_2(_out_:*mut u8, in_near:*mut u8, in_far:*mut u8, w:i32, hs:i32) -> *mut u8 {
	let mut i:i32;
	i = 0;;
while (i < w) {
i += 1;
_out_[i] = 3 * in_near[i] + in_far[i] + 2 >> 2;}
	return _out_;
}

unsafe fn stbi__resample_row_h_2(_out_:*mut u8, in_near:*mut u8, in_far:*mut u8, w:i32, hs:i32) -> *mut u8 {
	let mut i:i32;
	let input:*mut u8 = in_near;
	if w == 1 {
_out_[0] = _out_[1] = input[0];;return _out_;}
	_out_[0] = input[0];
	_out_[1] = input[0] * 3 + input[1] + 2 >> 2;
	i = 1;;
while (i < w - 1) {i += 1;

let mut n:i32 = 3 * input[i] + 2;_out_[i * 2 + 0] = n + input[i - 1] >> 2;_out_[i * 2 + 1] = n + input[i + 1] >> 2;}

	_out_[i * 2 + 0] = input[w - 2] * 3 + input[w - 1] + 2 >> 2;
	_out_[i * 2 + 1] = input[w - 1];
	return _out_;
}

unsafe fn stbi__resample_row_hv_2(_out_:*mut u8, in_near:*mut u8, in_far:*mut u8, w:i32, hs:i32) -> *mut u8 {
	let mut i:i32;let mut t0:i32;let mut t1:i32;
	if w == 1 {
_out_[0] = _out_[1] = 3 * in_near[0] + in_far[0] + 2 >> 2;;return _out_;}
	t1 = 3 * in_near[0] + in_far[0];
	_out_[0] = t1 + 2 >> 2;
	i = 1;;
while (i < w) {i += 1;

t0 = t1;t1 = 3 * in_near[i] + in_far[i];_out_[i * 2 - 1] = 3 * t0 + t1 + 8 >> 4;_out_[i * 2] = 3 * t1 + t0 + 8 >> 4;}

	_out_[w * 2 - 1] = t1 + 2 >> 2;
	return _out_;
}

unsafe fn stbi__resample_row_generic(_out_:*mut u8, in_near:*mut u8, in_far:*mut u8, w:i32, hs:i32) -> *mut u8 {
	let mut i:i32;let mut j:i32;
	i = 0;;
while (i < w) {
i += 1;
j = 0;;
while (j < hs) {
j += 1;
_out_[i * hs + j] = in_near[i];}}
	return _out_;
}

unsafe fn stbi__YCbCr_to_RGB_row(_out_:*mut u8, y:*mut u8, pcb:*mut u8, pcr:*mut u8, count:i32, step:i32){
	let mut i:i32;
	i = 0;;
while (i < count) {i += 1;

let mut y_fixed:i32 = y[i] << 20 + 1 << 19;let mut r:i32;let mut g:i32;let mut b:i32;let mut cr:i32 = pcr[i] - 128;let mut cb:i32 = pcb[i] - 128;r = y_fixed + cr * 1.40200f32 * 4096.0f32 + 0.5f32 << 8;g = y_fixed + cr * -0.71414f32 * 4096.0f32 + 0.5f32 << 8 + cb * -0.34414f32 * 4096.0f32 + 0.5f32 << 8 & 0xffff0000;b = y_fixed + cb * 1.77200f32 * 4096.0f32 + 0.5f32 << 8;r >>= 20;g >>= 20;b >>= 20;if r > 255 {
if r < 0 {r = 0;} else {r = 255;}}if g > 255 {
if g < 0 {g = 0;} else {g = 255;}}if b > 255 {
if b < 0 {b = 0;} else {b = 255;}}_out_[0] = r;_out_[1] = g;_out_[2] = b;_out_[3] = 255;_out_ += step;}

}

unsafe fn stbi__setup_jpeg(j:&mut stbi__jpeg){
	j.idct_block_kernel = stbi__idct_block;
	j.YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;
	j.resample_row_hv_2_kernel = stbi__resample_row_hv_2;
}

unsafe fn stbi__cleanup_jpeg(j:&mut stbi__jpeg){
	stbi__free_jpeg_components(j, j.s.img_n, 0);
}

unsafe fn stbi__blinn_8x8(x:u8, y:u8) -> u8 {
	let mut t:u32 = x * y + 128;
	return t + t >> 8 >> 8;
}

unsafe fn load_jpeg_image(z:&mut stbi__jpeg, out_x:*mut i32, out_y:*mut i32, comp:*mut i32, req_comp:i32) -> *mut u8 {
	let mut n:i32;let mut decode_n:i32;let mut is_rgb:i32;
	z.s.img_n = 0;
	if req_comp < 0 || req_comp > 4 {return if stbi__err("bad req_comp"){0} else {0}}
	if stbi__decode_jpeg_image(z)== 0 {
stbi__cleanup_jpeg(z);return std::ptr::null_mut();}
	n = if req_comp{req_comp} else {if z.s.img_n >= 3{3} else {1}};
	is_rgb = z.s.img_n == 3 && z.rgb == 3 || z.app14_color_transform == 0 && z.jfif== 0;
	if z.s.img_n == 3 && n < 3 && is_rgb== 0 {decode_n = 1;} else {decode_n = z.s.img_n;}
	{
let mut k:i32;let mut i:u32;let mut j:u32;let output:*mut u8;let mut coutput:[u8;4] = unsafe {std::mem::uninitialized()};let mut res_comp:[stbi__resample;4] = unsafe {std::mem::uninitialized()};k = 0;;
while (k < decode_n) {k += 1;

let r:&mut stbi__resample = res_comp[k];z.img_comp[k].linebuf = stbi__malloc(z.s.img_x + 3);if z.img_comp[k].linebuf== std::ptr::null_mut() {
stbi__cleanup_jpeg(z);return if stbi__err("outofmem"){0} else {0}}r.hs = z.img_h_max / z.img_comp[k].h;r.vs = z.img_v_max / z.img_comp[k].v;r.ystep = r.vs >> 1;r.w_lores = z.s.img_x + r.hs - 1 / r.hs;r.ypos = 0;r.line0 = r.line1 = z.img_comp[k].data;;if r.hs == 1 && r.vs == 1 {r.resample = resample_row_1;} else {if r.hs == 1 && r.vs == 2 {r.resample = stbi__resample_row_v_2;} else {if r.hs == 2 && r.vs == 1 {r.resample = stbi__resample_row_h_2;} else {if r.hs == 2 && r.vs == 2 {r.resample = z.resample_row_hv_2_kernel;} else {r.resample = stbi__resample_row_generic;}}}}}
output = stbi__malloc_mad3(n, z.s.img_x, z.s.img_y, 1);if output== std::ptr::null_mut() {
stbi__cleanup_jpeg(z);return if stbi__err("outofmem"){0} else {0}}j = 0;;
while (j < z.s.img_y) {j += 1;

let _out_:*mut u8 = output[n * z.s.img_x * j];k = 0;;
while (k < decode_n) {k += 1;

let r:&mut stbi__resample = res_comp[k];let mut y_bot:i32 = r.ystep >= r.vs >> 1;coutput[k] = r.resample(z.img_comp[k].linebuf, if y_bot{r.line1} else {r.line0}, if y_bot{r.line0} else {r.line1}, r.w_lores, r.hs);if r.ystep += 1 >= r.vs {
r.ystep = 0;r.line0 = r.line1;if r.ypos += 1 < z.img_comp[k].y {r.line1 += z.img_comp[k].w2;}}}
if n >= 3 {
let y:*mut u8 = coutput[0];if z.s.img_n == 3 {
if (is_rgb) != 0 {
i = 0;;
while (i < z.s.img_x) {i += 1;

_out_[0] = y[i];_out_[1] = coutput[1][i];_out_[2] = coutput[2][i];_out_[3] = 255;_out_ += n;}
} else {
z.YCbCr_to_RGB_kernel(_out_, y, coutput[1], coutput[2], z.s.img_x, n);}} else {if z.s.img_n == 4 {
if z.app14_color_transform == 0 {
i = 0;;
while (i < z.s.img_x) {i += 1;

let mut m:u8 = coutput[3][i];_out_[0] = stbi__blinn_8x8(coutput[0][i], m);_out_[1] = stbi__blinn_8x8(coutput[1][i], m);_out_[2] = stbi__blinn_8x8(coutput[2][i], m);_out_[3] = 255;_out_ += n;}
} else {if z.app14_color_transform == 2 {
z.YCbCr_to_RGB_kernel(_out_, y, coutput[1], coutput[2], z.s.img_x, n);i = 0;;
while (i < z.s.img_x) {i += 1;

let mut m:u8 = coutput[3][i];_out_[0] = stbi__blinn_8x8(255 - _out_[0], m);_out_[1] = stbi__blinn_8x8(255 - _out_[1], m);_out_[2] = stbi__blinn_8x8(255 - _out_[2], m);_out_ += n;}
} else {
z.YCbCr_to_RGB_kernel(_out_, y, coutput[1], coutput[2], z.s.img_x, n);}}} else {i = 0;;
while (i < z.s.img_x) {i += 1;

_out_[0] = _out_[1] = _out_[2] = y[i];;;_out_[3] = 255;_out_ += n;}}}} else {
if (is_rgb) != 0 {
if n == 1 {i = 0;;
while (i < z.s.img_x) {
i += 1;
_out_ += 1 = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);}} else {
i = 0;;
while (i < z.s.img_x) {i += 1 ; _out_ += 2;;

_out_[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);_out_[1] = 255;}
}} else {if z.s.img_n == 4 && z.app14_color_transform == 0 {
i = 0;;
while (i < z.s.img_x) {i += 1;

let mut m:u8 = coutput[3][i];let mut r:u8 = stbi__blinn_8x8(coutput[0][i], m);let mut g:u8 = stbi__blinn_8x8(coutput[1][i], m);let mut b:u8 = stbi__blinn_8x8(coutput[2][i], m);_out_[0] = stbi__compute_y(r, g, b);_out_[1] = 255;_out_ += n;}
} else {if z.s.img_n == 4 && z.app14_color_transform == 2 {
i = 0;;
while (i < z.s.img_x) {i += 1;

_out_[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);_out_[1] = 255;_out_ += n;}
} else {
let y:*mut u8 = coutput[0];if n == 1 {i = 0;;
while (i < z.s.img_x) {
i += 1;
_out_[i] = y[i];}} else {i = 0;;
while (i < z.s.img_x) {
i += 1;
_out_ += 1 = y[i];;_out_ += 1 = 255;}}}}}}}
stbi__cleanup_jpeg(z);out_x = z.s.img_x;out_y = z.s.img_y;if (comp) != std::ptr::null_mut() {comp = if z.s.img_n >= 3{3} else {1};}return output;}

}

unsafe fn stbi__jpeg_load(s:&mut stbi__context, x:*mut i32, y:*mut i32, comp:*mut i32, req_comp:i32, ri:&mut stbi__result_info) -> *mut u8 {
	let result:*mut u8;
	let j:&mut stbi__jpeg = stbi__malloc(std::mem::size_of::<stbi__jpeg>());
	j.s = s;
	stbi__setup_jpeg(j);
	result = load_jpeg_image(j, x, y, comp, req_comp);
	c_runtime::free(j);
	return result;
}

unsafe fn stbi__jpeg_test(s:&mut stbi__context) -> i32 {
	let mut r:i32;
	let j:&mut stbi__jpeg = stbi__malloc(std::mem::size_of::<stbi__jpeg>());
	j.s = s;
	stbi__setup_jpeg(j);
	r = stbi__decode_jpeg_header(j, STBI__SCAN_type);
	stbi__rewind(s);
	c_runtime::free(j);
	return r;
}

unsafe fn stbi__jpeg_info_raw(j:&mut stbi__jpeg, x:*mut i32, y:*mut i32, comp:*mut i32) -> i32 {
	if stbi__decode_jpeg_header(j, STBI__SCAN_header)== 0 {
stbi__rewind(j.s);return 0;}
	if (x) != std::ptr::null_mut() {x = j.s.img_x;}
	if (y) != std::ptr::null_mut() {y = j.s.img_y;}
	if (comp) != std::ptr::null_mut() {comp = if j.s.img_n >= 3{3} else {1};}
	return 1;
}

unsafe fn stbi__jpeg_info(s:&mut stbi__context, x:*mut i32, y:*mut i32, comp:*mut i32) -> i32 {
	let mut result:i32;
	let j:&mut stbi__jpeg = stbi__malloc(std::mem::size_of::<stbi__jpeg>());
	j.s = s;
	result = stbi__jpeg_info_raw(j, x, y, comp);
	c_runtime::free(j);
	return result;
}

unsafe fn stbi__bitreverse16(n:i32) -> i32 {
	n = n & 0xAAAA >> 1 | n & 0x5555 << 1;
	n = n & 0xCCCC >> 2 | n & 0x3333 << 2;
	n = n & 0xF0F0 >> 4 | n & 0x0F0F << 4;
	n = n & 0xFF00 >> 8 | n & 0x00FF << 8;
	return n;
}

unsafe fn stbi__bit_reverse(v:i32, bits:i32) -> i32 {
	return stbi__bitreverse16(v) >> 16 - bits;
}

unsafe fn stbi__zbuild_huffman(z:&mut stbi__zhuffman, sizelist:*mut u8, num:i32) -> i32 {
	let mut i:i32;let mut k:i32 = 0;
	let mut code:i32;let mut next_code:[i32;16] = unsafe {std::mem::uninitialized()};let mut sizes:[i32;17] = unsafe {std::mem::uninitialized()};
	c_runtime::memset(sizes, 0, std::mem::size_of(sizes));
	c_runtime::memset(z.fast, 0, std::mem::size_of(z.fast));
	i = 0;;
while (i < num) {
i += 1;
sizes[sizelist[i]] += 1;}
	sizes[0] = 0;
	i = 1;;
while (i < 16) {
i += 1;
if sizes[i] > 1 << i {return stbi__err("bad sizes");}}
	code = 0;
	i = 1;;
while (i < 16) {i += 1;

next_code[i] = code;z.firstcode[i] = code;z.firstsymbol[i] = k;code = code + sizes[i];if (sizes[i]) != 0 {if code - 1 >= 1 << i {return stbi__err("bad codelengths");}}z.maxcode[i] = code << 16 - i;code <<= 1;k += sizes[i];}

	z.maxcode[16] = 0x10000;
	i = 0;;
while (i < num) {i += 1;

let mut s:i32 = sizelist[i];if (s) != 0 {
let mut c:i32 = next_code[s] - z.firstcode[s] + z.firstsymbol[s];let mut fastv:u16 = s << 9 | i;z.size[c] = s;z.value[c] = i;if s <= 9 {
let mut j:i32 = stbi__bit_reverse(next_code[s], s);while (j < 1 << 9) {
z.fast[j] = fastv;j += 1 << s;}}next_code[s] += 1;}}

	return 1;
}

unsafe fn stbi__zget8(z:&mut stbi__zbuf) -> u8 {
	if z.zbuffer >= z.zbuffer_end {return 0;}
	return z.zbuffer += 1;
}

unsafe fn stbi__fill_bits(z:&mut stbi__zbuf){
	while(true) {
z.code_buffer |= stbi__zget8(z) << z.num_bits;z.num_bits += 8;if !(z.num_bits <= 24) {break;}}

}

unsafe fn stbi__zreceive(z:&mut stbi__zbuf, n:i32) -> u32 {
	let mut k:u32;
	if z.num_bits < n {stbi__fill_bits(z);}
	k = z.code_buffer & 1 << n - 1;
	z.code_buffer >>= n;
	z.num_bits -= n;
	return k;
}

unsafe fn stbi__zhuffman_decode_slowpath(a:&mut stbi__zbuf, z:&mut stbi__zhuffman) -> i32 {
	let mut b:i32;let mut s:i32;let mut k:i32;
	k = stbi__bit_reverse(a.code_buffer, 16);
	s = 9 + 1;;
while () {
s += 1;
if k < z.maxcode[s] {}}
	if s == 16 {return -1;}
	b = k >> 16 - s - z.firstcode[s] + z.firstsymbol[s];
	a.code_buffer >>= s;
	a.num_bits -= s;
	return z.value[b];
}

unsafe fn stbi__zhuffman_decode(a:&mut stbi__zbuf, z:&mut stbi__zhuffman) -> i32 {
	let mut b:i32;let mut s:i32;
	if a.num_bits < 16 {stbi__fill_bits(a);}
	b = z.fast[a.code_buffer & 1 << 9 - 1];
	if (b) != 0 {
s = b >> 9;a.code_buffer >>= s;a.num_bits -= s;return b & 511;}
	return stbi__zhuffman_decode_slowpath(a, z);
}

unsafe fn stbi__zexpand(z:&mut stbi__zbuf, zout:*mut i8, n:i32) -> i32 {
	let q:*mut i8;
	let mut cur:i32;let mut limit:i32;let mut old_limit:i32;
	z.zout = zout;
	if z.z_expandable== 0 {return stbi__err("output buffer limit");}
	cur = z.zout - z.zout_start;
	limit = old_limit = z.zout_end - z.zout_start;;
	while (cur + n > limit) {limit *= 2;}
	q = c_runtime::realloc(z.zout_start, limit);
	if q == std::ptr::null_mut() {return stbi__err("outofmem");}
	z.zout_start = q;
	z.zout = q[cur];
	z.zout_end = q[limit];
	return 1;
}

unsafe fn stbi__parse_huffman_block(a:&mut stbi__zbuf) -> i32 {
	let zout:*mut i8 = a.zout;
	;
while () {;

let mut z:i32 = stbi__zhuffman_decode(a, a.z_length);if z < 256 {
if z < 0 {return stbi__err("bad huffman code");}if zout >= a.zout_end {
if stbi__zexpand(a, zout, 1)== 0 {return 0;}zout = a.zout;}zout += 1 = z;} else {
let p:*mut u8;let mut len:i32;let mut dist:i32;if z == 256 {
a.zout = zout;return 1;}z -= 257;len = stbi__zlength_base[z];if (stbi__zlength_extra[z]) != 0 {len += stbi__zreceive(a, stbi__zlength_extra[z]);}z = stbi__zhuffman_decode(a, a.z_distance);if z < 0 {return stbi__err("bad huffman code");}dist = stbi__zdist_base[z];if (stbi__zdist_extra[z]) != 0 {dist += stbi__zreceive(a, stbi__zdist_extra[z]);}if zout - a.zout_start < dist {return stbi__err("bad dist");}if zout[len] > a.zout_end {
if stbi__zexpand(a, zout, len)== 0 {return 0;}zout = a.zout;}p = zout - dist;if dist == 1 {
let mut v:u8 = p;if (len) != 0 {
while(true) {zout += 1 = v;if !((len -= 1) != 0) {break;}}}} else {
if (len) != 0 {
while(true) {zout += 1 = p += 1;if !((len -= 1) != 0) {break;}}}}}}

}

unsafe fn stbi__compute_huffman_codes(a:&mut stbi__zbuf) -> i32 {
	let mut z_codelength:stbi__zhuffman;
	let mut lencodes:[u8;455] = unsafe {std::mem::uninitialized()};
	let mut codelength_sizes:[u8;19] = unsafe {std::mem::uninitialized()};
	let mut i:i32;let mut n:i32;
	let mut hlit:i32 = stbi__zreceive(a, 5) + 257;
	let mut hdist:i32 = stbi__zreceive(a, 5) + 1;
	let mut hclen:i32 = stbi__zreceive(a, 4) + 4;
	let mut ntot:i32 = hlit + hdist;
	c_runtime::memset(codelength_sizes, 0, std::mem::size_of(codelength_sizes));
	i = 0;;
while (i < hclen) {i += 1;

let mut s:i32 = stbi__zreceive(a, 3);codelength_sizes[length_dezigzag[i]] = s;}

	if stbi__zbuild_huffman(z_codelength, codelength_sizes, 19)== 0 {return 0;}
	n = 0;
	while (n < ntot) {
let mut c:i32 = stbi__zhuffman_decode(a, z_codelength);if c < 0 || c >= 19 {return stbi__err("bad codelengths");}if c < 16 {lencodes[n += 1] = c;} else {
let mut fill:u8 = 0;if c == 16 {
c = stbi__zreceive(a, 2) + 3;if n == 0 {return stbi__err("bad codelengths");}fill = lencodes[n - 1];} else {if c == 17 {c = stbi__zreceive(a, 3) + 3;} else {
c = stbi__zreceive(a, 7) + 11;}}if ntot - n < c {return stbi__err("bad codelengths");}c_runtime::memset(lencodes[n], fill, c);n += c;}}
	if n != ntot {return stbi__err("bad codelengths");}
	if stbi__zbuild_huffman(a.z_length, lencodes, hlit)== 0 {return 0;}
	if stbi__zbuild_huffman(a.z_distance, lencodes[hlit], hdist)== 0 {return 0;}
	return 1;
}

unsafe fn stbi__parse_uncompressed_block(a:&mut stbi__zbuf) -> i32 {
	let mut header:[u8;4] = unsafe {std::mem::uninitialized()};
	let mut len:i32;let mut nlen:i32;let mut k:i32;
	if (a.num_bits & 7) != 0 {stbi__zreceive(a, a.num_bits & 7);}
	k = 0;
	while (a.num_bits > 0) {
header[k += 1] = a.code_buffer & 255;a.code_buffer >>= 8;a.num_bits -= 8;}
	while (k < 4) {header[k += 1] = stbi__zget8(a);}
	len = header[1] * 256 + header[0];
	nlen = header[3] * 256 + header[2];
	if nlen != len ^ 0xffff {return stbi__err("zlib corrupt");}
	if a.zbuffer[len] > a.zbuffer_end {return stbi__err("read past buffer");}
	if a.zout[len] > a.zout_end {if stbi__zexpand(a, a.zout, len)== 0 {return 0;}}
	c_runtime::memcpy(a.zout, a.zbuffer, len);
	a.zbuffer += len;
	a.zout += len;
	return 1;
}

unsafe fn stbi__parse_zlib_header(a:&mut stbi__zbuf) -> i32 {
	let mut cmf:i32 = stbi__zget8(a);
	let mut cm:i32 = cmf & 15;
	let mut flg:i32 = stbi__zget8(a);
	if cmf * 256 + flg % 31 != 0 {return stbi__err("bad zlib header");}
	if (flg & 32) != 0 {return stbi__err("no preset dict");}
	if cm != 8 {return stbi__err("bad compression");}
	return 1;
}

unsafe fn stbi__parse_zlib(a:&mut stbi__zbuf, parse_header:i32) -> i32 {
	let mut _final_:i32;let mut _type_:i32;
	if (parse_header) != 0 {if stbi__parse_zlib_header(a)== 0 {return 0;}}
	a.num_bits = 0;
	a.code_buffer = 0;
	while(true) {
_final_ = stbi__zreceive(a, 1);_type_ = stbi__zreceive(a, 2);if _type_ == 0 {
if stbi__parse_uncompressed_block(a)== 0 {return 0;}} else {if _type_ == 3 {
return 0;} else {
if _type_ == 1 {
if stbi__zbuild_huffman(a.z_length, stbi__zdefault_length, 288)== 0 {return 0;}if stbi__zbuild_huffman(a.z_distance, stbi__zdefault_distance, 32)== 0 {return 0;}} else {
if stbi__compute_huffman_codes(a)== 0 {return 0;}}if stbi__parse_huffman_block(a)== 0 {return 0;}}}if !(_final_== 0) {break;}}

	return 1;
}

unsafe fn stbi__do_zlib(a:&mut stbi__zbuf, obuf:*mut i8, olen:i32, exp:i32, parse_header:i32) -> i32 {
	a.zout_start = obuf;
	a.zout = obuf;
	a.zout_end = obuf[olen];
	a.z_expandable = exp;
	return stbi__parse_zlib(a, parse_header);
}

unsafe fn stbi_zlib_decode_malloc_guesssize(buffer:*mut i8, len:i32, initial_size:i32, outlen:*mut i32) -> *mut i8 {
	let mut a:stbi__zbuf;
	let p:*mut i8 = stbi__malloc(initial_size);
	if p == std::ptr::null_mut() {return std::ptr::null_mut();}
	a.zbuffer = buffer;
	a.zbuffer_end = buffer[len];
	if (stbi__do_zlib(a, p, initial_size, 1, 1)) != 0 {
if (outlen) != std::ptr::null_mut() {outlen = a.zout - a.zout_start;}return a.zout_start;} else {
c_runtime::free(a.zout_start);return std::ptr::null_mut();}
}

unsafe fn stbi_zlib_decode_malloc(buffer:*mut i8, len:i32, outlen:*mut i32) -> *mut i8 {
	return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);
}

unsafe fn stbi_zlib_decode_malloc_guesssize_headerflag(buffer:*mut i8, len:i32, initial_size:i32, outlen:*mut i32, parse_header:i32) -> *mut i8 {
	let mut a:stbi__zbuf;
	let p:*mut i8 = stbi__malloc(initial_size);
	if p == std::ptr::null_mut() {return std::ptr::null_mut();}
	a.zbuffer = buffer;
	a.zbuffer_end = buffer[len];
	if (stbi__do_zlib(a, p, initial_size, 1, parse_header)) != 0 {
if (outlen) != std::ptr::null_mut() {outlen = a.zout - a.zout_start;}return a.zout_start;} else {
c_runtime::free(a.zout_start);return std::ptr::null_mut();}
}

unsafe fn stbi_zlib_decode_buffer(obuffer:*mut i8, olen:i32, ibuffer:*mut i8, ilen:i32) -> i32 {
	let mut a:stbi__zbuf;
	a.zbuffer = ibuffer;
	a.zbuffer_end = ibuffer[ilen];
	if (stbi__do_zlib(a, obuffer, olen, 0, 1)) != 0 {return a.zout - a.zout_start;} else {return -1;}
}

unsafe fn stbi_zlib_decode_noheader_malloc(buffer:*mut i8, len:i32, outlen:*mut i32) -> *mut i8 {
	let mut a:stbi__zbuf;
	let p:*mut i8 = stbi__malloc(16384);
	if p == std::ptr::null_mut() {return std::ptr::null_mut();}
	a.zbuffer = buffer;
	a.zbuffer_end = buffer[len];
	if (stbi__do_zlib(a, p, 16384, 1, 0)) != 0 {
if (outlen) != std::ptr::null_mut() {outlen = a.zout - a.zout_start;}return a.zout_start;} else {
c_runtime::free(a.zout_start);return std::ptr::null_mut();}
}

unsafe fn stbi_zlib_decode_noheader_buffer(obuffer:*mut i8, olen:i32, ibuffer:*mut i8, ilen:i32) -> i32 {
	let mut a:stbi__zbuf;
	a.zbuffer = ibuffer;
	a.zbuffer_end = ibuffer[ilen];
	if (stbi__do_zlib(a, obuffer, olen, 0, 0)) != 0 {return a.zout - a.zout_start;} else {return -1;}
}

unsafe fn stbi__get_chunk_header(s:&mut stbi__context) -> stbi__pngchunk {
	let mut c:stbi__pngchunk;
	c.length = stbi__get32be(s);
	c._type_ = stbi__get32be(s);
	return c;
}

unsafe fn stbi__check_png_header(s:&mut stbi__context) -> i32 {
	let mut i:i32;
	i = 0;;
while (i < 8) {
i += 1;
if stbi__get8(s) != png_sig[i] {return stbi__err("bad png sig");}}
	return 1;
}

unsafe fn stbi__paeth(a:i32, b:i32, c:i32) -> i32 {
	let mut p:i32 = a + b - c;
	let mut pa:i32 = c_runtime::abs(p - a);
	let mut pb:i32 = c_runtime::abs(p - b);
	let mut pc:i32 = c_runtime::abs(p - c);
	if pa <= pb && pa <= pc {return a;}
	if pb <= pc {return b;}
	return c;
}

unsafe fn stbi__create_png_image_raw(a:&mut stbi__png, raw:*mut u8, raw_len:u32, out_n:i32, x:u32, y:u32, depth:i32, color:i32) -> i32 {
	let mut bytes:i32 = if depth == 16{2} else {1};
	let s:&mut stbi__context = a.s;
	let mut i:u32;let mut j:u32;let mut stride:u32 = x * out_n * bytes;
	let mut img_len:u32;let mut img_width_bytes:u32;
	let mut k:i32;
	let mut img_n:i32 = s.img_n;
	let mut output_bytes:i32 = out_n * bytes;
	let mut filter_bytes:i32 = img_n * bytes;
	let mut width:i32 = x;
	a._out_ = stbi__malloc_mad3(x, y, output_bytes, 0);
	if a._out_== std::ptr::null_mut() {return stbi__err("outofmem");}
	img_width_bytes = img_n * x * depth + 7 >> 3;
	img_len = img_width_bytes + 1 * y;
	if raw_len < img_len {return stbi__err("not enough pixels");}
	j = 0;;
while (j < y) {j += 1;

let cur:*mut u8 = a._out_[stride * j];let prior:*mut u8;let mut filter:i32 = raw += 1;if filter > 4 {return stbi__err("invalid filter");}if depth < 8 {
cur += x * out_n - img_width_bytes;filter_bytes = 1;width = img_width_bytes;}prior = cur - stride;if j == 0 {filter = first_row_filter[filter];}k = 0;;
while (k < filter_bytes) {k += 1;

{
if filter == STBI__F_none {cur[k] = raw[k];} else if filter == STBI__F_sub {cur[k] = raw[k];} else if filter == STBI__F_up {cur[k] = raw[k] + prior[k] & 255;} else if filter == STBI__F_avg {cur[k] = raw[k] + prior[k] >> 1 & 255;} else if filter == STBI__F_paeth {cur[k] = raw[k] + stbi__paeth(0, prior[k], 0) & 255;} else if filter == STBI__F_avg_first {cur[k] = raw[k];} else if filter == STBI__F_paeth_first {cur[k] = raw[k];}
}}
if depth == 8 {
if img_n != out_n {cur[img_n] = 255;}raw += img_n;cur += out_n;prior += out_n;} else {if depth == 16 {
if img_n != out_n {
cur[filter_bytes] = 255;cur[filter_bytes + 1] = 255;}raw += filter_bytes;cur += output_bytes;prior += output_bytes;} else {
raw += 1;cur += 1;prior += 1;}}if depth < 8 || img_n == out_n {
let mut nk:i32 = width - 1 * filter_bytes;{
if filter == STBI__F_none {c_runtime::memcpy(cur, raw, nk);} else if filter == STBI__F_sub {k = 0;;
while (k < nk) {k += 1;

cur[k] = raw[k] + cur[k - filter_bytes] & 255;}
} else if filter == STBI__F_up {k = 0;;
while (k < nk) {k += 1;

cur[k] = raw[k] + prior[k] & 255;}
} else if filter == STBI__F_avg {k = 0;;
while (k < nk) {k += 1;

cur[k] = raw[k] + prior[k] + cur[k - filter_bytes] >> 1 & 255;}
} else if filter == STBI__F_paeth {k = 0;;
while (k < nk) {k += 1;

cur[k] = raw[k] + stbi__paeth(cur[k - filter_bytes], prior[k], prior[k - filter_bytes]) & 255;}
} else if filter == STBI__F_avg_first {k = 0;;
while (k < nk) {k += 1;

cur[k] = raw[k] + cur[k - filter_bytes] >> 1 & 255;}
} else if filter == STBI__F_paeth_first {k = 0;;
while (k < nk) {k += 1;

cur[k] = raw[k] + stbi__paeth(cur[k - filter_bytes], 0, 0) & 255;}
}
}raw += nk;} else {
{
if filter == STBI__F_none {i = x - 1;;
while (i >= 1) {
i -= 1 ; cur[filter_bytes] = 255; ; raw += filter_bytes; ; cur += output_bytes; ; prior += output_bytes;;
k = 0;;
while (k < filter_bytes) {k += 1;

cur[k] = raw[k];}
}} else if filter == STBI__F_sub {i = x - 1;;
while (i >= 1) {
i -= 1 ; cur[filter_bytes] = 255; ; raw += filter_bytes; ; cur += output_bytes; ; prior += output_bytes;;
k = 0;;
while (k < filter_bytes) {k += 1;

cur[k] = raw[k] + cur[k - output_bytes] & 255;}
}} else if filter == STBI__F_up {i = x - 1;;
while (i >= 1) {
i -= 1 ; cur[filter_bytes] = 255; ; raw += filter_bytes; ; cur += output_bytes; ; prior += output_bytes;;
k = 0;;
while (k < filter_bytes) {k += 1;

cur[k] = raw[k] + prior[k] & 255;}
}} else if filter == STBI__F_avg {i = x - 1;;
while (i >= 1) {
i -= 1 ; cur[filter_bytes] = 255; ; raw += filter_bytes; ; cur += output_bytes; ; prior += output_bytes;;
k = 0;;
while (k < filter_bytes) {k += 1;

cur[k] = raw[k] + prior[k] + cur[k - output_bytes] >> 1 & 255;}
}} else if filter == STBI__F_paeth {i = x - 1;;
while (i >= 1) {
i -= 1 ; cur[filter_bytes] = 255; ; raw += filter_bytes; ; cur += output_bytes; ; prior += output_bytes;;
k = 0;;
while (k < filter_bytes) {k += 1;

cur[k] = raw[k] + stbi__paeth(cur[k - output_bytes], prior[k], prior[k - output_bytes]) & 255;}
}} else if filter == STBI__F_avg_first {i = x - 1;;
while (i >= 1) {
i -= 1 ; cur[filter_bytes] = 255; ; raw += filter_bytes; ; cur += output_bytes; ; prior += output_bytes;;
k = 0;;
while (k < filter_bytes) {k += 1;

cur[k] = raw[k] + cur[k - output_bytes] >> 1 & 255;}
}} else if filter == STBI__F_paeth_first {i = x - 1;;
while (i >= 1) {
i -= 1 ; cur[filter_bytes] = 255; ; raw += filter_bytes; ; cur += output_bytes; ; prior += output_bytes;;
k = 0;;
while (k < filter_bytes) {k += 1;

cur[k] = raw[k] + stbi__paeth(cur[k - output_bytes], 0, 0) & 255;}
}}
}if depth == 16 {
cur = a._out_[stride * j];i = 0;;
while (i < x) {i += 1 ; cur += output_bytes;;

cur[filter_bytes + 1] = 255;}
}}}

	if depth < 8 {
j = 0;;
while (j < y) {j += 1;

let cur:*mut u8 = a._out_[stride * j];let _in_:*mut u8 = a._out_[stride * j][x * out_n] - img_width_bytes;let mut scale:u8 = if color == 0{stbi__depth_scale_table[depth]} else {1};if depth == 4 {
k = x * img_n;;
while (k >= 2) {k -= 2; ; _in_ += 1;

cur += 1 = scale * _in_ >> 4;cur += 1 = scale * _in_ & 0x0f;}
if k > 0 {cur += 1 = scale * _in_ >> 4;}} else {if depth == 2 {
k = x * img_n;;
while (k >= 4) {k -= 4; ; _in_ += 1;

cur += 1 = scale * _in_ >> 6;cur += 1 = scale * _in_ >> 4 & 0x03;cur += 1 = scale * _in_ >> 2 & 0x03;cur += 1 = scale * _in_ & 0x03;}
if k > 0 {cur += 1 = scale * _in_ >> 6;}if k > 1 {cur += 1 = scale * _in_ >> 4 & 0x03;}if k > 2 {cur += 1 = scale * _in_ >> 2 & 0x03;}} else {if depth == 1 {
k = x * img_n;;
while (k >= 8) {k -= 8; ; _in_ += 1;

cur += 1 = scale * _in_ >> 7;cur += 1 = scale * _in_ >> 6 & 0x01;cur += 1 = scale * _in_ >> 5 & 0x01;cur += 1 = scale * _in_ >> 4 & 0x01;cur += 1 = scale * _in_ >> 3 & 0x01;cur += 1 = scale * _in_ >> 2 & 0x01;cur += 1 = scale * _in_ >> 1 & 0x01;cur += 1 = scale * _in_ & 0x01;}
if k > 0 {cur += 1 = scale * _in_ >> 7;}if k > 1 {cur += 1 = scale * _in_ >> 6 & 0x01;}if k > 2 {cur += 1 = scale * _in_ >> 5 & 0x01;}if k > 3 {cur += 1 = scale * _in_ >> 4 & 0x01;}if k > 4 {cur += 1 = scale * _in_ >> 3 & 0x01;}if k > 5 {cur += 1 = scale * _in_ >> 2 & 0x01;}if k > 6 {cur += 1 = scale * _in_ >> 1 & 0x01;}}}}if img_n != out_n {
let mut q:i32;cur = a._out_[stride * j];if img_n == 1 {
q = x - 1;;
while (q >= 0) {q -= 1;

cur[q * 2 + 1] = 255;cur[q * 2 + 0] = cur[q];}
} else {
q = x - 1;;
while (q >= 0) {q -= 1;

cur[q * 4 + 3] = 255;cur[q * 4 + 2] = cur[q * 3 + 2];cur[q * 4 + 1] = cur[q * 3 + 1];cur[q * 4 + 0] = cur[q * 3 + 0];}
}}}
} else {if depth == 16 {
let cur:*mut u8 = a._out_;let cur16:*mut u16 = cur;i = 0;;
while (i < x * y * out_n) {i += 1 ; cur16 += 1 ; cur += 2;;

cur16 = cur[0] << 8 | cur[1];}
}}
	return 1;
}

unsafe fn stbi__create_png_image(a:&mut stbi__png, image_data:*mut u8, image_data_len:u32, out_n:i32, depth:i32, color:i32, interlaced:i32) -> i32 {
	let mut bytes:i32 = if depth == 16{2} else {1};
	let mut out_bytes:i32 = out_n * bytes;
	let _final_:*mut u8;
	let mut p:i32;
	if interlaced== 0 {return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a.s.img_x, a.s.img_y, depth, color);}
	_final_ = stbi__malloc_mad3(a.s.img_x, a.s.img_y, out_bytes, 0);
	p = 0;;
while (p < 7) {p += 1;

let mut xorig:[i32;7] = unsafe {std::mem::uninitialized()};let mut yorig:[i32;7] = unsafe {std::mem::uninitialized()};let mut xspc:[i32;7] = unsafe {std::mem::uninitialized()};let mut yspc:[i32;7] = unsafe {std::mem::uninitialized()};let mut i:i32;let mut j:i32;let mut x:i32;let mut y:i32;x = a.s.img_x - xorig[p] + xspc[p] - 1 / xspc[p];y = a.s.img_y - yorig[p] + yspc[p] - 1 / yspc[p];if (x) != 0 && (y) != 0 {
let mut img_len:u32 = a.s.img_n * x * depth + 7 >> 3 + 1 * y;if stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)== 0 {
c_runtime::free(_final_);return 0;}j = 0;;
while (j < y) {j += 1;

i = 0;;
while (i < x) {i += 1;

let mut out_y:i32 = j * yspc[p] + yorig[p];let mut out_x:i32 = i * xspc[p] + xorig[p];c_runtime::memcpy(_final_[out_y * a.s.img_x * out_bytes][out_x * out_bytes], a._out_[j * x + i * out_bytes], out_bytes);}
}
c_runtime::free(a._out_);image_data += img_len;image_data_len -= img_len;}}

	a._out_ = _final_;
	return 1;
}

unsafe fn stbi__compute_transparency(z:&mut stbi__png, tc:[u8;3], out_n:i32) -> i32 {
	let s:&mut stbi__context = z.s;
	let mut i:u32;let mut pixel_count:u32 = s.img_x * s.img_y;
	let p:*mut u8 = z._out_;
	if out_n == 2 {
i = 0;;
while (i < pixel_count) {i += 1;

p[1] = if p[0] == tc[0]{0} else {255};p += 2;}
} else {
i = 0;;
while (i < pixel_count) {i += 1;

if p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2] {p[3] = 0;}p += 4;}
}
	return 1;
}

unsafe fn stbi__compute_transparency16(z:&mut stbi__png, tc:[u16;3], out_n:i32) -> i32 {
	let s:&mut stbi__context = z.s;
	let mut i:u32;let mut pixel_count:u32 = s.img_x * s.img_y;
	let p:*mut u16 = z._out_;
	if out_n == 2 {
i = 0;;
while (i < pixel_count) {i += 1;

p[1] = if p[0] == tc[0]{0} else {65535};p += 2;}
} else {
i = 0;;
while (i < pixel_count) {i += 1;

if p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2] {p[3] = 0;}p += 4;}
}
	return 1;
}

unsafe fn stbi__expand_png_palette(a:&mut stbi__png, palette:*mut u8, len:i32, pal_img_n:i32) -> i32 {
	let mut i:u32;let mut pixel_count:u32 = a.s.img_x * a.s.img_y;
	let p:*mut u8;let temp_out:*mut u8;let orig:*mut u8 = a._out_;
	p = stbi__malloc_mad2(pixel_count, pal_img_n, 0);
	if p == std::ptr::null_mut() {return stbi__err("outofmem");}
	temp_out = p;
	if pal_img_n == 3 {
i = 0;;
while (i < pixel_count) {i += 1;

let mut n:i32 = orig[i] * 4;p[0] = palette[n];p[1] = palette[n + 1];p[2] = palette[n + 2];p += 3;}
} else {
i = 0;;
while (i < pixel_count) {i += 1;

let mut n:i32 = orig[i] * 4;p[0] = palette[n];p[1] = palette[n + 1];p[2] = palette[n + 2];p[3] = palette[n + 3];p += 4;}
}
	c_runtime::free(a._out_);
	a._out_ = temp_out;
	return 1;
}

unsafe fn stbi_set_unpremultiply_on_load(flag_true_if_should_unpremultiply:i32){
	stbi__unpremultiply_on_load = flag_true_if_should_unpremultiply;
}

unsafe fn stbi_convert_iphone_png_to_rgb(flag_true_if_should_convert:i32){
	stbi__de_iphone_flag = flag_true_if_should_convert;
}

unsafe fn stbi__de_iphone(z:&mut stbi__png){
	let s:&mut stbi__context = z.s;
	let mut i:u32;let mut pixel_count:u32 = s.img_x * s.img_y;
	let p:*mut u8 = z._out_;
	if s.img_out_n == 3 {
i = 0;;
while (i < pixel_count) {i += 1;

let mut t:u8 = p[0];p[0] = p[2];p[2] = t;p += 3;}
} else {
if (stbi__unpremultiply_on_load) != 0 {
i = 0;;
while (i < pixel_count) {i += 1;

let mut a:u8 = p[3];let mut t:u8 = p[0];if (a) != 0 {
let mut half:u8 = a / 2;p[0] = p[2] * 255 + half / a;p[1] = p[1] * 255 + half / a;p[2] = t * 255 + half / a;} else {
p[0] = p[2];p[2] = t;}p += 4;}
} else {
i = 0;;
while (i < pixel_count) {i += 1;

let mut t:u8 = p[0];p[0] = p[2];p[2] = t;p += 4;}
}}
}

unsafe fn stbi__parse_png_file(z:&mut stbi__png, scan:i32, req_comp:i32) -> i32 {
	let mut palette:[u8;1024] = unsafe {std::mem::uninitialized()};let mut pal_img_n:u8 = 0;
	let mut has_trans:u8 = 0;let mut tc:[u8;3] = unsafe {std::mem::uninitialized()};
	let mut tc16:[u16;3] = unsafe {std::mem::uninitialized()};
	let mut ioff:u32 = 0;let mut idata_limit:u32 = 0;let mut i:u32;let mut pal_len:u32 = 0;
	let mut first:i32 = 1;let mut k:i32;let mut interlace:i32 = 0;let mut color:i32 = 0;let mut is_iphone:i32 = 0;
	let s:&mut stbi__context = z.s;
	z.expanded = std::ptr::null_mut();
	z.idata = std::ptr::null_mut();
	z._out_ = std::ptr::null_mut();
	if stbi__check_png_header(s)== 0 {return 0;}
	if scan == STBI__SCAN_type {return 1;}
	;
while () {;

let mut c:stbi__pngchunk = stbi__get_chunk_header(s);{
if c._type_ == 'C' << 24 + 'g' << 16 + 'B' << 8 + 'I' {is_iphone = 1;stbi__skip(s, c.length);} else if c._type_ == 'I' << 24 + 'H' << 16 + 'D' << 8 + 'R' {{
let mut comp:i32;let mut filter:i32;if first== 0 {return stbi__err("multiple IHDR");}first = 0;if c.length != 13 {return stbi__err("bad IHDR len");}s.img_x = stbi__get32be(s);if s.img_x > 1 << 24 {return stbi__err("too large");}s.img_y = stbi__get32be(s);if s.img_y > 1 << 24 {return stbi__err("too large");}z.depth = stbi__get8(s);if z.depth != 1 && z.depth != 2 && z.depth != 4 && z.depth != 8 && z.depth != 16 {return stbi__err("1/2/4/8/16-bit only");}color = stbi__get8(s);if color > 6 {return stbi__err("bad ctype");}if color == 3 && z.depth == 16 {return stbi__err("bad ctype");}if color == 3 {pal_img_n = 3;} else {if (color & 1) != 0 {return stbi__err("bad ctype");}}comp = stbi__get8(s);if (comp) != 0 {return stbi__err("bad comp method");}filter = stbi__get8(s);if (filter) != 0 {return stbi__err("bad filter method");}interlace = stbi__get8(s);if interlace > 1 {return stbi__err("bad interlace method");}if s.img_x== 0 || s.img_y== 0 {return stbi__err("0-pixel image");}if pal_img_n== 0 {
s.img_n = if color & 2{3} else {1} + if color & 4{1} else {0};if 1 << 30 / s.img_x / s.img_n < s.img_y {return stbi__err("too large");}if scan == STBI__SCAN_header {return 1;}} else {
s.img_n = 1;if 1 << 30 / s.img_x / 4 < s.img_y {return stbi__err("too large");}}}
} else if c._type_ == 'P' << 24 + 'L' << 16 + 'T' << 8 + 'E' {{
if (first) != 0 {return stbi__err("first not IHDR");}if c.length > 256 * 3 {return stbi__err("invalid PLTE");}pal_len = c.length / 3;if pal_len * 3 != c.length {return stbi__err("invalid PLTE");}i = 0;;
while (i < pal_len) {i += 1;

palette[i * 4 + 0] = stbi__get8(s);palette[i * 4 + 1] = stbi__get8(s);palette[i * 4 + 2] = stbi__get8(s);palette[i * 4 + 3] = 255;}
}
} else if c._type_ == 't' << 24 + 'R' << 16 + 'N' << 8 + 'S' {{
if (first) != 0 {return stbi__err("first not IHDR");}if (z.idata) != std::ptr::null_mut() {return stbi__err("tRNS after IDAT");}if (pal_img_n) != 0 {
if scan == STBI__SCAN_header {
s.img_n = 4;return 1;}if pal_len == 0 {return stbi__err("tRNS before PLTE");}if c.length > pal_len {return stbi__err("bad tRNS len");}pal_img_n = 4;i = 0;;
while (i < c.length) {
i += 1;
palette[i * 4 + 3] = stbi__get8(s);}} else {
if s.img_n & 1== 0 {return stbi__err("tRNS with alpha");}if c.length != s.img_n * 2 {return stbi__err("bad tRNS len");}has_trans = 1;if z.depth == 16 {
k = 0;;
while (k < s.img_n) {
k += 1;
tc16[k] = stbi__get16be(s);}} else {
k = 0;;
while (k < s.img_n) {
k += 1;
tc[k] = stbi__get16be(s) & 255 * stbi__depth_scale_table[z.depth];}}}}
} else if c._type_ == 'I' << 24 + 'D' << 16 + 'A' << 8 + 'T' {{
if (first) != 0 {return stbi__err("first not IHDR");}if (pal_img_n) != 0 && pal_len== 0 {return stbi__err("no PLTE");}if scan == STBI__SCAN_header {
s.img_n = pal_img_n;return 1;}if ioff + c.length < ioff {return 0;}if ioff + c.length > idata_limit {
let mut idata_limit_old:u32 = idata_limit;let p:*mut u8;if idata_limit == 0 {idata_limit = if c.length > 4096{c.length} else {4096};}while (ioff + c.length > idata_limit) {idata_limit *= 2;}p = c_runtime::realloc(z.idata, idata_limit);if p == std::ptr::null_mut() {return stbi__err("outofmem");}z.idata = p;}if stbi__getn(s, z.idata[ioff], c.length)== 0 {return stbi__err("outofdata");}ioff += c.length;}
} else if c._type_ == 'I' << 24 + 'E' << 16 + 'N' << 8 + 'D' {{
let mut raw_len:u32;let mut bpl:u32;if (first) != 0 {return stbi__err("first not IHDR");}if scan != STBI__SCAN_load {return 1;}if z.idata == std::ptr::null_mut() {return stbi__err("no IDAT");}bpl = s.img_x * z.depth + 7 / 8;raw_len = bpl * s.img_y * s.img_n + s.img_y;z.expanded = stbi_zlib_decode_malloc_guesssize_headerflag(z.idata, ioff, raw_len, raw_len, !is_iphone);if z.expanded == std::ptr::null_mut() {return 0;}c_runtime::free(z.idata);z.idata = std::ptr::null_mut();if req_comp == s.img_n + 1 && req_comp != 3 && pal_img_n== 0 || (has_trans) != 0 {s.img_out_n = s.img_n + 1;} else {s.img_out_n = s.img_n;}if stbi__create_png_image(z, z.expanded, raw_len, s.img_out_n, z.depth, color, interlace)== 0 {return 0;}if (has_trans) != 0 {
if z.depth == 16 {
if stbi__compute_transparency16(z, tc16, s.img_out_n)== 0 {return 0;}} else {
if stbi__compute_transparency(z, tc, s.img_out_n)== 0 {return 0;}}}if (is_iphone) != 0 && (stbi__de_iphone_flag) != 0 && s.img_out_n > 2 {stbi__de_iphone(z);}if (pal_img_n) != 0 {
s.img_n = pal_img_n;s.img_out_n = pal_img_n;if req_comp >= 3 {s.img_out_n = req_comp;}if stbi__expand_png_palette(z, palette, pal_len, s.img_out_n)== 0 {return 0;}} else {if (has_trans) != 0 {
s.img_n += 1;}}c_runtime::free(z.expanded);z.expanded = std::ptr::null_mut();return 1;}
} else { if (first) != 0 {return stbi__err("first not IHDR");}if c._type_ & 1 << 29 == 0 {
let mut invalid_chunk:[i8;25] = unsafe {std::mem::uninitialized()};return stbi__err(invalid_chunk);}stbi__skip(s, c.length);}
}stbi__get32be(s);}

}

unsafe fn stbi__do_png(p:&mut stbi__png, x:*mut i32, y:*mut i32, n:*mut i32, req_comp:i32, ri:&mut stbi__result_info) -> *mut u8 {
	let result:*mut u8 = std::ptr::null_mut();
	if req_comp < 0 || req_comp > 4 {return if stbi__err("bad req_comp"){0} else {0}}
	if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) != 0 {
if p.depth < 8 {ri.bits_per_channel = 8;} else {ri.bits_per_channel = p.depth;}result = p._out_;p._out_ = std::ptr::null_mut();if (req_comp) != 0 && req_comp != p.s.img_out_n {
if ri.bits_per_channel == 8 {result = stbi__convert_format(result, p.s.img_out_n, req_comp, p.s.img_x, p.s.img_y);} else {result = stbi__convert_format16(result, p.s.img_out_n, req_comp, p.s.img_x, p.s.img_y);}p.s.img_out_n = req_comp;if result == std::ptr::null_mut() {return result;}}x = p.s.img_x;y = p.s.img_y;if (n) != std::ptr::null_mut() {n = p.s.img_n;}}
	c_runtime::free(p._out_);
	p._out_ = std::ptr::null_mut();
	c_runtime::free(p.expanded);
	p.expanded = std::ptr::null_mut();
	c_runtime::free(p.idata);
	p.idata = std::ptr::null_mut();
	return result;
}

unsafe fn stbi__png_load(s:&mut stbi__context, x:*mut i32, y:*mut i32, comp:*mut i32, req_comp:i32, ri:&mut stbi__result_info) -> *mut u8 {
	let mut p:stbi__png;
	p.s = s;
	return stbi__do_png(p, x, y, comp, req_comp, ri);
}

unsafe fn stbi__png_test(s:&mut stbi__context) -> i32 {
	let mut r:i32;
	r = stbi__check_png_header(s);
	stbi__rewind(s);
	return r;
}

unsafe fn stbi__png_info_raw(p:&mut stbi__png, x:*mut i32, y:*mut i32, comp:*mut i32) -> i32 {
	if stbi__parse_png_file(p, STBI__SCAN_header, 0)== 0 {
stbi__rewind(p.s);return 0;}
	if (x) != std::ptr::null_mut() {x = p.s.img_x;}
	if (y) != std::ptr::null_mut() {y = p.s.img_y;}
	if (comp) != std::ptr::null_mut() {comp = p.s.img_n;}
	return 1;
}

unsafe fn stbi__png_info(s:&mut stbi__context, x:*mut i32, y:*mut i32, comp:*mut i32) -> i32 {
	let mut p:stbi__png;
	p.s = s;
	return stbi__png_info_raw(p, x, y, comp);
}

unsafe fn stbi__bmp_test_raw(s:&mut stbi__context) -> i32 {
	let mut r:i32;
	let mut sz:i32;
	if stbi__get8(s) != 'B' {return 0;}
	if stbi__get8(s) != 'M' {return 0;}
	stbi__get32le(s);
	stbi__get16le(s);
	stbi__get16le(s);
	stbi__get32le(s);
	sz = stbi__get32le(s);
	r = sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124;
	return r;
}

unsafe fn stbi__bmp_test(s:&mut stbi__context) -> i32 {
	let mut r:i32 = stbi__bmp_test_raw(s);
	stbi__rewind(s);
	return r;
}

unsafe fn stbi__high_bit(z:u32) -> i32 {
	let mut n:i32 = 0;
	if z == 0 {return -1;}
	if z >= 0x10000 {
n += 16;z >>= 16;}
	if z >= 0x00100 {
n += 8;z >>= 8;}
	if z >= 0x00010 {
n += 4;z >>= 4;}
	if z >= 0x00004 {
n += 2;z >>= 2;}
	if z >= 0x00002 {
n += 1;z >>= 1;}
	return n;
}

unsafe fn stbi__bitcount(a:u32) -> i32 {
	a = a & 0x55555555 + a >> 1 & 0x55555555;
	a = a & 0x33333333 + a >> 2 & 0x33333333;
	a = a + a >> 4 & 0x0f0f0f0f;
	a = a + a >> 8;
	a = a + a >> 16;
	return a & 0xff;
}

unsafe fn stbi__shiftsigned(v:i32, shift:i32, bits:i32) -> i32 {
	let mut result:i32;
	let mut z:i32 = 0;
	if shift < 0 {v <<= -shift;} else {v >>= shift;}
	result = v;
	z = bits;
	while (z < 8) {
result += v >> z;z += bits;}
	return result;
}

unsafe fn stbi__bmp_parse_header(s:&mut stbi__context, info:&mut stbi__bmp_data) -> *mut u8 {
	let mut hsz:i32;
	if stbi__get8(s) != 'B' || stbi__get8(s) != 'M' {return if stbi__err("not BMP"){0} else {0}}
	stbi__get32le(s);
	stbi__get16le(s);
	stbi__get16le(s);
	info.offset = stbi__get32le(s);
	info.hsz = hsz = stbi__get32le(s);;
	info.mr = info.mg = info.mb = info.ma = 0;;;;
	if hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124 {return if stbi__err("unknown BMP"){0} else {0}}
	if hsz == 12 {
s.img_x = stbi__get16le(s);s.img_y = stbi__get16le(s);} else {
s.img_x = stbi__get32le(s);s.img_y = stbi__get32le(s);}
	if stbi__get16le(s) != 1 {return if stbi__err("bad BMP"){0} else {0}}
	info.bpp = stbi__get16le(s);
	if info.bpp == 1 {return if stbi__err("monochrome"){0} else {0}}
	if hsz != 12 {
let mut compress:i32 = stbi__get32le(s);if compress == 1 || compress == 2 {return if stbi__err("BMP RLE"){0} else {0}}stbi__get32le(s);stbi__get32le(s);stbi__get32le(s);stbi__get32le(s);stbi__get32le(s);if hsz == 40 || hsz == 56 {
if hsz == 56 {
stbi__get32le(s);stbi__get32le(s);stbi__get32le(s);stbi__get32le(s);}if info.bpp == 16 || info.bpp == 32 {
if compress == 0 {
if info.bpp == 32 {
info.mr = 0xff << 16;info.mg = 0xff << 8;info.mb = 0xff << 0;info.ma = 0xff << 24;info.all_a = 0;} else {
info.mr = 31 << 10;info.mg = 31 << 5;info.mb = 31 << 0;}} else {if compress == 3 {
info.mr = stbi__get32le(s);info.mg = stbi__get32le(s);info.mb = stbi__get32le(s);if info.mr == info.mg && info.mg == info.mb {
return if stbi__err("bad BMP"){0} else {0}}} else {return if stbi__err("bad BMP"){0} else {0}}}}} else {
let mut i:i32;if hsz != 108 && hsz != 124 {return if stbi__err("bad BMP"){0} else {0}}info.mr = stbi__get32le(s);info.mg = stbi__get32le(s);info.mb = stbi__get32le(s);info.ma = stbi__get32le(s);stbi__get32le(s);i = 0;;
while (i < 12) {
i += 1;
stbi__get32le(s);}if hsz == 124 {
stbi__get32le(s);stbi__get32le(s);stbi__get32le(s);stbi__get32le(s);}}}
	return 1;
}

unsafe fn stbi__bmp_load(s:&mut stbi__context, x:*mut i32, y:*mut i32, comp:*mut i32, req_comp:i32, ri:&mut stbi__result_info) -> *mut u8 {
	let _out_:*mut u8;
	let mut mr:u32 = 0;let mut mg:u32 = 0;let mut mb:u32 = 0;let mut ma:u32 = 0;let mut all_a:u32;
	let mut pal:[u8;256] = unsafe {std::mem::uninitialized()};
	let mut psize:i32 = 0;let mut i:i32;let mut j:i32;let mut width:i32;
	let mut flip_vertically:i32;let mut pad:i32;let mut target:i32;
	let mut info:stbi__bmp_data;
	info.all_a = 255;
	if stbi__bmp_parse_header(s, info) == std::ptr::null_mut() {return std::ptr::null_mut();}
	flip_vertically = s.img_y > 0;
	s.img_y = c_runtime::abs(s.img_y);
	mr = info.mr;
	mg = info.mg;
	mb = info.mb;
	ma = info.ma;
	all_a = info.all_a;
	if info.hsz == 12 {
if info.bpp < 24 {psize = info.offset - 14 - 24 / 3;}} else {
if info.bpp < 16 {psize = info.offset - 14 - info.hsz >> 2;}}
	s.img_n = if ma{4} else {3};
	if (req_comp) != 0 && req_comp >= 3 {target = req_comp;} else {target = s.img_n;}
	if stbi__mad3sizes_valid(target, s.img_x, s.img_y, 0)== 0 {return if stbi__err("too large"){0} else {0}}
	_out_ = stbi__malloc_mad3(target, s.img_x, s.img_y, 0);
	if _out_== std::ptr::null_mut() {return if stbi__err("outofmem"){0} else {0}}
	if info.bpp < 16 {
let mut z:i32 = 0;if psize == 0 || psize > 256 {
c_runtime::free(_out_);return if stbi__err("invalid"){0} else {0}}i = 0;;
while (i < psize) {i += 1;

pal[i][2] = stbi__get8(s);pal[i][1] = stbi__get8(s);pal[i][0] = stbi__get8(s);if info.hsz != 12 {stbi__get8(s);}pal[i][3] = 255;}
stbi__skip(s, info.offset - 14 - info.hsz - psize * if info.hsz == 12{3} else {4});if info.bpp == 4 {width = s.img_x + 1 >> 1;} else {if info.bpp == 8 {width = s.img_x;} else {
c_runtime::free(_out_);return if stbi__err("bad bpp"){0} else {0}}}pad = -width & 3;j = 0;;
while (j < s.img_y) {j += 1;

i = 0;;
while (i < s.img_x) {i += 2;;

let mut v:i32 = stbi__get8(s);let mut v2:i32 = 0;if info.bpp == 4 {
v2 = v & 15;v >>= 4;}_out_[z += 1] = pal[v][0];_out_[z += 1] = pal[v][1];_out_[z += 1] = pal[v][2];if target == 4 {_out_[z += 1] = 255;}if i + 1 == s.img_x {}v = if info.bpp == 8{stbi__get8(s)} else {v2};_out_[z += 1] = pal[v][0];_out_[z += 1] = pal[v][1];_out_[z += 1] = pal[v][2];if target == 4 {_out_[z += 1] = 255;}}
stbi__skip(s, pad);}
} else {
let mut rshift:i32 = 0;let mut gshift:i32 = 0;let mut bshift:i32 = 0;let mut ashift:i32 = 0;let mut rcount:i32 = 0;let mut gcount:i32 = 0;let mut bcount:i32 = 0;let mut acount:i32 = 0;let mut z:i32 = 0;let mut easy:i32 = 0;stbi__skip(s, info.offset - 14 - info.hsz);if info.bpp == 24 {width = 3 * s.img_x;} else {if info.bpp == 16 {width = 2 * s.img_x;} else {width = 0;}}pad = -width & 3;if info.bpp == 24 {
easy = 1;} else {if info.bpp == 32 {
if mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000 {easy = 2;}}}if easy== 0 {
if mr== 0 || mg== 0 || mb== 0 {
c_runtime::free(_out_);return if stbi__err("bad masks"){0} else {0}}rshift = stbi__high_bit(mr) - 7;rcount = stbi__bitcount(mr);gshift = stbi__high_bit(mg) - 7;gcount = stbi__bitcount(mg);bshift = stbi__high_bit(mb) - 7;bcount = stbi__bitcount(mb);ashift = stbi__high_bit(ma) - 7;acount = stbi__bitcount(ma);}j = 0;;
while (j < s.img_y) {j += 1;

if (easy) != 0 {
i = 0;;
while (i < s.img_x) {i += 1;

let mut a:u8;_out_[z + 2] = stbi__get8(s);_out_[z + 1] = stbi__get8(s);_out_[z + 0] = stbi__get8(s);z += 3;a = if easy == 2{stbi__get8(s)} else {255};all_a |= a;if target == 4 {_out_[z += 1] = a;}}
} else {
let mut bpp:i32 = info.bpp;i = 0;;
while (i < s.img_x) {i += 1;

let mut v:u32 = if bpp == 16{stbi__get16le(s)} else {stbi__get32le(s)};let mut a:i32;_out_[z += 1] = stbi__shiftsigned(v & mr, rshift, rcount) & 255;_out_[z += 1] = stbi__shiftsigned(v & mg, gshift, gcount) & 255;_out_[z += 1] = stbi__shiftsigned(v & mb, bshift, bcount) & 255;a = if ma{stbi__shiftsigned(v & ma, ashift, acount)} else {255};all_a |= a;if target == 4 {_out_[z += 1] = a & 255;}}
}stbi__skip(s, pad);}
}
	if target == 4 && all_a == 0 {i = 4 * s.img_x * s.img_y - 1;;
while (i >= 0) {
i -= 4;;
_out_[i] = 255;}}
	if (flip_vertically) != 0 {
let mut t:u8;j = 0;;
while (j < s.img_y >> 1) {j += 1;

let p1:*mut u8 = _out_[j * s.img_x * target];let p2:*mut u8 = _out_[s.img_y - 1 - j * s.img_x * target];i = 0;;
while (i < s.img_x * target) {i += 1;

t = p1[i];p1[i] = p2[i];p2[i] = t;}
}
}
	if (req_comp) != 0 && req_comp != target {
_out_ = stbi__convert_format(_out_, target, req_comp, s.img_x, s.img_y);if _out_ == std::ptr::null_mut() {return _out_;}}
	x = s.img_x;
	y = s.img_y;
	if (comp) != std::ptr::null_mut() {comp = s.img_n;}
	return _out_;
}

unsafe fn stbi__tga_get_comp(bits_per_pixel:i32, is_grey:i32, is_rgb16:*mut i32) -> i32 {
	if (is_rgb16) != std::ptr::null_mut() {is_rgb16 = 0;}
	{
if bits_per_pixel == 8 {return STBI_grey;} else if bits_per_pixel == 15 {} else if bits_per_pixel == 16 {if bits_per_pixel == 16 && (is_grey) != 0 {return STBI_grey_alpha;}if (is_rgb16) != std::ptr::null_mut() {is_rgb16 = 1;}return STBI_rgb;} else if bits_per_pixel == 24 {} else if bits_per_pixel == 32 {return bits_per_pixel / 8;} else { return 0;}
}
}

unsafe fn stbi__tga_info(s:&mut stbi__context, x:*mut i32, y:*mut i32, comp:*mut i32) -> i32 {
	let mut tga_w:i32;let mut tga_h:i32;let mut tga_comp:i32;let mut tga_image_type:i32;let mut tga_bits_per_pixel:i32;let mut tga_colormap_bpp:i32;
	let mut sz:i32;let mut tga_colormap_type:i32;
	stbi__get8(s);
	tga_colormap_type = stbi__get8(s);
	if tga_colormap_type > 1 {
stbi__rewind(s);return 0;}
	tga_image_type = stbi__get8(s);
	if tga_colormap_type == 1 {
if tga_image_type != 1 && tga_image_type != 9 {
stbi__rewind(s);return 0;}stbi__skip(s, 4);sz = stbi__get8(s);if sz != 8 && sz != 15 && sz != 16 && sz != 24 && sz != 32 {
stbi__rewind(s);return 0;}stbi__skip(s, 4);tga_colormap_bpp = sz;} else {
if tga_image_type != 2 && tga_image_type != 3 && tga_image_type != 10 && tga_image_type != 11 {
stbi__rewind(s);return 0;}stbi__skip(s, 9);tga_colormap_bpp = 0;}
	tga_w = stbi__get16le(s);
	if tga_w < 1 {
stbi__rewind(s);return 0;}
	tga_h = stbi__get16le(s);
	if tga_h < 1 {
stbi__rewind(s);return 0;}
	tga_bits_per_pixel = stbi__get8(s);
	stbi__get8(s);
	if tga_colormap_bpp != 0 {
if tga_bits_per_pixel != 8 && tga_bits_per_pixel != 16 {
stbi__rewind(s);return 0;}tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, std::ptr::null_mut());} else {
tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, tga_image_type == 3 || tga_image_type == 11, std::ptr::null_mut());}
	if tga_comp== 0 {
stbi__rewind(s);return 0;}
	if (x) != std::ptr::null_mut() {x = tga_w;}
	if (y) != std::ptr::null_mut() {y = tga_h;}
	if (comp) != std::ptr::null_mut() {comp = tga_comp;}
	return 1;
}

unsafe fn stbi__tga_read_rgb16(s:&mut stbi__context, _out_:*mut u8){
	let mut px:u16 = stbi__get16le(s);
	let mut fiveBitMask:u16 = 31;
	let mut r:i32 = px >> 10 & fiveBitMask;
	let mut g:i32 = px >> 5 & fiveBitMask;
	let mut b:i32 = px & fiveBitMask;
	_out_[0] = r * 255 / 31;
	_out_[1] = g * 255 / 31;
	_out_[2] = b * 255 / 31;
}

unsafe fn stbi__tga_load(s:&mut stbi__context, x:*mut i32, y:*mut i32, comp:*mut i32, req_comp:i32, ri:&mut stbi__result_info) -> *mut u8 {
	let mut tga_offset:i32 = stbi__get8(s);
	let mut tga_indexed:i32 = stbi__get8(s);
	let mut tga_image_type:i32 = stbi__get8(s);
	let mut tga_is_RLE:i32 = 0;
	let mut tga_palette_start:i32 = stbi__get16le(s);
	let mut tga_palette_len:i32 = stbi__get16le(s);
	let mut tga_palette_bits:i32 = stbi__get8(s);
	let mut tga_x_origin:i32 = stbi__get16le(s);
	let mut tga_y_origin:i32 = stbi__get16le(s);
	let mut tga_width:i32 = stbi__get16le(s);
	let mut tga_height:i32 = stbi__get16le(s);
	let mut tga_bits_per_pixel:i32 = stbi__get8(s);
	let mut tga_comp:i32;let mut tga_rgb16:i32 = 0;
	let mut tga_inverted:i32 = stbi__get8(s);
	let tga_data:*mut u8;
	let tga_palette:*mut u8 = std::ptr::null_mut();
	let mut i:i32;let mut j:i32;
	let mut raw_data:[u8;4] = unsafe {std::mem::uninitialized()};
	let mut RLE_count:i32 = 0;
	let mut RLE_repeating:i32 = 0;
	let mut read_next_pixel:i32 = 1;
	if tga_image_type >= 8 {
tga_image_type -= 8;tga_is_RLE = 1;}
	tga_inverted = 1 - tga_inverted >> 5 & 1;
	if (tga_indexed) != 0 {tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, tga_rgb16);} else {tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, tga_image_type == 3, tga_rgb16);}
	if tga_comp== 0 {return if stbi__err("bad format"){0} else {0}}
	x = tga_width;
	y = tga_height;
	if (comp) != std::ptr::null_mut() {comp = tga_comp;}
	if stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0)== 0 {return if stbi__err("too large"){0} else {0}}
	tga_data = stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);
	if tga_data== std::ptr::null_mut() {return if stbi__err("outofmem"){0} else {0}}
	stbi__skip(s, tga_offset);
	if tga_indexed== 0 && tga_is_RLE== 0 && tga_rgb16== 0 {
i = 0;;
while (i < tga_height) {i += 1;

let mut row:i32 = if tga_inverted{tga_height - i - 1} else {i};let tga_row:*mut u8 = tga_data[row * tga_width * tga_comp];stbi__getn(s, tga_row, tga_width * tga_comp);}
} else {
if (tga_indexed) != 0 {
stbi__skip(s, tga_palette_start);tga_palette = stbi__malloc_mad2(tga_palette_len, tga_comp, 0);if tga_palette== std::ptr::null_mut() {
c_runtime::free(tga_data);return if stbi__err("outofmem"){0} else {0}}if (tga_rgb16) != 0 {
let pal_entry:*mut u8 = tga_palette;i = 0;;
while (i < tga_palette_len) {i += 1;

stbi__tga_read_rgb16(s, pal_entry);pal_entry += tga_comp;}
} else {if stbi__getn(s, tga_palette, tga_palette_len * tga_comp)== 0 {
c_runtime::free(tga_data);c_runtime::free(tga_palette);return if stbi__err("bad palette"){0} else {0}}}}i = 0;;
while (i < tga_width * tga_height) {i += 1;

if (tga_is_RLE) != 0 {
if RLE_count == 0 {
let mut RLE_cmd:i32 = stbi__get8(s);RLE_count = 1 + RLE_cmd & 127;RLE_repeating = RLE_cmd >> 7;read_next_pixel = 1;} else {if RLE_repeating== 0 {
read_next_pixel = 1;}}} else {
read_next_pixel = 1;}if (read_next_pixel) != 0 {
if (tga_indexed) != 0 {
let mut pal_idx:i32 = if tga_bits_per_pixel == 8{stbi__get8(s)} else {stbi__get16le(s)};if pal_idx >= tga_palette_len {
pal_idx = 0;}pal_idx *= tga_comp;j = 0;;
while (j < tga_comp) {j += 1;

raw_data[j] = tga_palette[pal_idx + j];}
} else {if (tga_rgb16) != 0 {
stbi__tga_read_rgb16(s, raw_data);} else {
j = 0;;
while (j < tga_comp) {j += 1;

raw_data[j] = stbi__get8(s);}
}}read_next_pixel = 0;}j = 0;;
while (j < tga_comp) {
j += 1;
tga_data[i * tga_comp + j] = raw_data[j];}RLE_count -= 1;}
if (tga_inverted) != 0 {
j = 0;;
while (j * 2 < tga_height) {j += 1;

let mut index1:i32 = j * tga_width * tga_comp;let mut index2:i32 = tga_height - 1 - j * tga_width * tga_comp;i = tga_width * tga_comp;;
while (i > 0) {i -= 1;

let mut temp:u8 = tga_data[index1];tga_data[index1] = tga_data[index2];tga_data[index2] = temp;index1 += 1;index2 += 1;}
}
}if tga_palette != std::ptr::null_mut() {
c_runtime::free(tga_palette);}}
	if tga_comp >= 3 && tga_rgb16== 0 {
let tga_pixel:*mut u8 = tga_data;i = 0;;
while (i < tga_width * tga_height) {i += 1;

let mut temp:u8 = tga_pixel[0];tga_pixel[0] = tga_pixel[2];tga_pixel[2] = temp;tga_pixel += tga_comp;}
}
	if (req_comp) != 0 && req_comp != tga_comp {tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);}
	tga_palette_start = tga_palette_len = tga_palette_bits = tga_x_origin = tga_y_origin = 0;;;;;
	return tga_data;
}

unsafe fn stbi__psd_test(s:&mut stbi__context) -> i32 {
	let mut r:i32 = stbi__get32be(s) == 0x38425053;
	stbi__rewind(s);
	return r;
}

unsafe fn stbi__psd_decode_rle(s:&mut stbi__context, p:*mut u8, pixelCount:i32) -> i32 {
	let mut count:i32;let mut nleft:i32;let mut len:i32;
	count = 0;
	while (pixelCount - count > 0) {
nleft = pixelCount - count;len = stbi__get8(s);if len == 128 {
} else {if len < 128 {
len += 1;if len > nleft {return 0;}count += len;while ((len) != 0) {
p = stbi__get8(s);p += 4;len -= 1;}} else {if len > 128 {
let mut val:u8;len = 257 - len;if len > nleft {return 0;}val = stbi__get8(s);count += len;while ((len) != 0) {
p = val;p += 4;len -= 1;}}}}}
	return 1;
}

unsafe fn stbi__psd_load(s:&mut stbi__context, x:*mut i32, y:*mut i32, comp:*mut i32, req_comp:i32, ri:&mut stbi__result_info, bpc:i32) -> *mut u8 {
	let mut pixelCount:i32;
	let mut channelCount:i32;let mut compression:i32;
	let mut channel:i32;let mut i:i32;
	let mut bitdepth:i32;
	let mut w:i32;let mut h:i32;
	let _out_:*mut u8;
	if stbi__get32be(s) != 0x38425053 {return if stbi__err("not PSD"){0} else {0}}
	if stbi__get16be(s) != 1 {return if stbi__err("wrong version"){0} else {0}}
	stbi__skip(s, 6);
	channelCount = stbi__get16be(s);
	if channelCount < 0 || channelCount > 16 {return if stbi__err("wrong channel count"){0} else {0}}
	h = stbi__get32be(s);
	w = stbi__get32be(s);
	bitdepth = stbi__get16be(s);
	if bitdepth != 8 && bitdepth != 16 {return if stbi__err("unsupported bit depth"){0} else {0}}
	if stbi__get16be(s) != 3 {return if stbi__err("wrong color format"){0} else {0}}
	stbi__skip(s, stbi__get32be(s));
	stbi__skip(s, stbi__get32be(s));
	stbi__skip(s, stbi__get32be(s));
	compression = stbi__get16be(s);
	if compression > 1 {return if stbi__err("bad compression"){0} else {0}}
	if stbi__mad3sizes_valid(4, w, h, 0)== 0 {return if stbi__err("too large"){0} else {0}}
	if compression== 0 && bitdepth == 16 && bpc == 16 {
_out_ = stbi__malloc_mad3(8, w, h, 0);ri.bits_per_channel = 16;} else {_out_ = stbi__malloc(4 * w * h);}
	if _out_== std::ptr::null_mut() {return if stbi__err("outofmem"){0} else {0}}
	pixelCount = w * h;
	if (compression) != 0 {
stbi__skip(s, h * channelCount * 2);channel = 0;;
while (channel < 4) {channel += 1;

let p:*mut u8;p = _out_[channel];if channel >= channelCount {
i = 0;;
while (i < pixelCount) {
i += 1 ; p += 4;;
p = if channel == 3{255} else {0};}} else {
if stbi__psd_decode_rle(s, p, pixelCount)== 0 {
c_runtime::free(_out_);return if stbi__err("corrupt"){0} else {0}}}}
} else {
channel = 0;;
while (channel < 4) {channel += 1;

if channel >= channelCount {
if bitdepth == 16 && bpc == 16 {
let q:*mut u16 = _out_[channel];let mut val:u16 = if channel == 3{65535} else {0};i = 0;;
while (i < pixelCount) {
i += 1 ; q += 4;;
q = val;}} else {
let p:*mut u8 = _out_[channel];let mut val:u8 = if channel == 3{255} else {0};i = 0;;
while (i < pixelCount) {
i += 1 ; p += 4;;
p = val;}}} else {
if ri.bits_per_channel == 16 {
let q:*mut u16 = _out_[channel];i = 0;;
while (i < pixelCount) {
i += 1 ; q += 4;;
q = stbi__get16be(s);}} else {
let p:*mut u8 = _out_[channel];if bitdepth == 16 {
i = 0;;
while (i < pixelCount) {
i += 1 ; p += 4;;
p = stbi__get16be(s) >> 8;}} else {
i = 0;;
while (i < pixelCount) {
i += 1 ; p += 4;;
p = stbi__get8(s);}}}}}
}
	if channelCount >= 4 {
if ri.bits_per_channel == 16 {
i = 0;;
while (i < w * h) {i += 1;

let pixel:*mut u16 = _out_[4 * i];if pixel[3] != 0 && pixel[3] != 65535 {
let mut a:f32 = pixel[3] / 65535.0f32;let mut ra:f32 = 1.0f32 / a;let mut inv_a:f32 = 65535.0f32 * 1 - ra;pixel[0] = pixel[0] * ra + inv_a;pixel[1] = pixel[1] * ra + inv_a;pixel[2] = pixel[2] * ra + inv_a;}}
} else {
i = 0;;
while (i < w * h) {i += 1;

let pixel:*mut u8 = _out_[4 * i];if pixel[3] != 0 && pixel[3] != 255 {
let mut a:f32 = pixel[3] / 255.0f32;let mut ra:f32 = 1.0f32 / a;let mut inv_a:f32 = 255.0f32 * 1 - ra;pixel[0] = pixel[0] * ra + inv_a;pixel[1] = pixel[1] * ra + inv_a;pixel[2] = pixel[2] * ra + inv_a;}}
}}
	if (req_comp) != 0 && req_comp != 4 {
if ri.bits_per_channel == 16 {_out_ = stbi__convert_format16(_out_, 4, req_comp, w, h);} else {_out_ = stbi__convert_format(_out_, 4, req_comp, w, h);}if _out_ == std::ptr::null_mut() {return _out_;}}
	if (comp) != std::ptr::null_mut() {comp = 4;}
	y = h;
	x = w;
	return _out_;
}

unsafe fn stbi__gif_test_raw(s:&mut stbi__context) -> i32 {
	let mut sz:i32;
	if stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8' {return 0;}
	sz = stbi__get8(s);
	if sz != '9' && sz != '7' {return 0;}
	if stbi__get8(s) != 'a' {return 0;}
	return 1;
}

unsafe fn stbi__gif_test(s:&mut stbi__context) -> i32 {
	let mut r:i32 = stbi__gif_test_raw(s);
	stbi__rewind(s);
	return r;
}

unsafe fn stbi__gif_parse_colortable(s:&mut stbi__context, pal:[[u8;4];256], num_entries:i32, transp:i32){
	let mut i:i32;
	i = 0;;
while (i < num_entries) {i += 1;

pal[i][2] = stbi__get8(s);pal[i][1] = stbi__get8(s);pal[i][0] = stbi__get8(s);pal[i][3] = if transp == i{0} else {255};}

}

unsafe fn stbi__gif_header(s:&mut stbi__context, g:&mut stbi__gif, comp:*mut i32, is_info:i32) -> i32 {
	let mut version:u8;
	if stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8' {return stbi__err("not GIF");}
	version = stbi__get8(s);
	if version != '7' && version != '9' {return stbi__err("not GIF");}
	if stbi__get8(s) != 'a' {return stbi__err("not GIF");}
	stbi__g_failure_reason = "";
	g.w = stbi__get16le(s);
	g.h = stbi__get16le(s);
	g.flags = stbi__get8(s);
	g.bgindex = stbi__get8(s);
	g.ratio = stbi__get8(s);
	g.transparent = -1;
	if comp != std::ptr::null_mut() {comp = 4;}
	if (is_info) != 0 {return 1;}
	if (g.flags & 0x80) != 0 {stbi__gif_parse_colortable(s, g.pal, 2 << g.flags & 7, -1);}
	return 1;
}

unsafe fn stbi__gif_info_raw(s:&mut stbi__context, x:*mut i32, y:*mut i32, comp:*mut i32) -> i32 {
	let g:&mut stbi__gif = stbi__malloc(std::mem::size_of::<stbi__gif>());
	if stbi__gif_header(s, g, comp, 1)== 0 {
c_runtime::free(g);stbi__rewind(s);return 0;}
	if (x) != std::ptr::null_mut() {x = g.w;}
	if (y) != std::ptr::null_mut() {y = g.h;}
	c_runtime::free(g);
	return 1;
}

unsafe fn stbi__out_gif_code(g:&mut stbi__gif, code:u16){
	let p:*mut u8;let c:*mut u8;
	if g.codes[code].prefix >= 0 {stbi__out_gif_code(g, g.codes[code].prefix);}
	if g.cur_y >= g.max_y {return;}
	p = g._out_[g.cur_x + g.cur_y];
	c = g.color_table[g.codes[code].suffix * 4];
	if c[3] >= 128 {
p[0] = c[2];p[1] = c[1];p[2] = c[0];p[3] = c[3];}
	g.cur_x += 4;
	if g.cur_x >= g.max_x {
g.cur_x = g.start_x;g.cur_y += g.step;while (g.cur_y >= g.max_y && g.parse > 0) {
g.step = 1 << g.parse * g.line_size;g.cur_y = g.start_y + g.step >> 1;g.parse -= 1;}}
}

unsafe fn stbi__process_gif_raster(s:&mut stbi__context, g:&mut stbi__gif) -> *mut u8 {
	let mut lzw_cs:u8;
	let mut len:i32;let mut init_code:i32;
	let mut first:u32;
	let mut codesize:i32;let mut codemask:i32;let mut avail:i32;let mut oldcode:i32;let mut bits:i32;let mut valid_bits:i32;let mut clear:i32;
	let p:&mut stbi__gif_lzw;
	lzw_cs = stbi__get8(s);
	if lzw_cs > 12 {return std::ptr::null_mut();}
	clear = 1 << lzw_cs;
	first = 1;
	codesize = lzw_cs + 1;
	codemask = 1 << codesize - 1;
	bits = 0;
	valid_bits = 0;
	init_code = 0;;
while (init_code < clear) {init_code += 1;

g.codes[init_code].prefix = -1;g.codes[init_code].first = init_code;g.codes[init_code].suffix = init_code;}

	avail = clear + 2;
	oldcode = -1;
	len = 0;
	;
while () {;

if valid_bits < codesize {
if len == 0 {
len = stbi__get8(s);if len == 0 {return g._out_;}}len -= 1;bits |= stbi__get8(s) << valid_bits;valid_bits += 8;} else {
let mut code:i32 = bits & codemask;bits >>= codesize;valid_bits -= codesize;if code == clear {
codesize = lzw_cs + 1;codemask = 1 << codesize - 1;avail = clear + 2;oldcode = -1;first = 0;} else {if code == clear + 1 {
stbi__skip(s, len);len = stbi__get8(s);while (len > 0) {
stbi__skip(s, len);len = stbi__get8(s);}return g._out_;} else {if code <= avail {
if (first) != 0 {return if stbi__err("no clear code"){0} else {0}}if oldcode >= 0 {
p = g.codes[avail += 1];if avail > 4096 {return if stbi__err("too many codes"){0} else {0}}p.prefix = oldcode;p.first = g.codes[oldcode].first;p.suffix = if code == avail{p.first} else {g.codes[code].first};} else {if code == avail {return if stbi__err("illegal code in raster"){0} else {0}}}stbi__out_gif_code(g, code);if avail & codemask == 0 && avail <= 0x0FFF {
codesize += 1;codemask = 1 << codesize - 1;}oldcode = code;} else {
return if stbi__err("illegal code in raster"){0} else {0}}}}}}

}

unsafe fn stbi__fill_gif_background(g:&mut stbi__gif, x0:i32, y0:i32, x1:i32, y1:i32){
	let mut x:i32;let mut y:i32;
	let c:*mut u8 = g.pal[g.bgindex];
	y = y0;;
while (y < y1) {y += 4 * g.w;;

x = x0;;
while (x < x1) {x += 4;;

let p:*mut u8 = g._out_[y + x];p[0] = c[2];p[1] = c[1];p[2] = c[0];p[3] = 0;}
}

}

unsafe fn stbi__gif_load_next(s:&mut stbi__context, g:&mut stbi__gif, comp:*mut i32, req_comp:i32) -> *mut u8 {
	let mut i:i32;
	let prev_out:*mut u8 = std::ptr::null_mut();
	if g._out_ == std::ptr::null_mut() && stbi__gif_header(s, g, comp, 0)== 0 {return std::ptr::null_mut();}
	if stbi__mad3sizes_valid(g.w, g.h, 4, 0)== 0 {return if stbi__err("too large"){0} else {0}}
	prev_out = g._out_;
	g._out_ = stbi__malloc_mad3(4, g.w, g.h, 0);
	if g._out_ == std::ptr::null_mut() {return if stbi__err("outofmem"){0} else {0}}
	{
if g.eflags & 0x1C >> 2 == 0 {stbi__fill_gif_background(g, 0, 0, 4 * g.w, 4 * g.w * g.h);} else if g.eflags & 0x1C >> 2 == 1 {if (prev_out) != std::ptr::null_mut() {c_runtime::memcpy(g._out_, prev_out, 4 * g.w * g.h);}g.old_out = prev_out;} else if g.eflags & 0x1C >> 2 == 2 {if (prev_out) != std::ptr::null_mut() {c_runtime::memcpy(g._out_, prev_out, 4 * g.w * g.h);}stbi__fill_gif_background(g, g.start_x, g.start_y, g.max_x, g.max_y);} else if g.eflags & 0x1C >> 2 == 3 {if (g.old_out) != std::ptr::null_mut() {
i = g.start_y;;
while (i < g.max_y) {
i += 4 * g.w;;
c_runtime::memcpy(g._out_[i + g.start_x], g.old_out[i + g.start_x], g.max_x - g.start_x);}}}
}
	;
while () {;

{
if stbi__get8(s) == 0x2C {{
let mut prev_trans:i32 = -1;let mut x:i32;let mut y:i32;let mut w:i32;let mut h:i32;let o:*mut u8;x = stbi__get16le(s);y = stbi__get16le(s);w = stbi__get16le(s);h = stbi__get16le(s);if x + w > g.w || y + h > g.h {return if stbi__err("bad Image Descriptor"){0} else {0}}g.line_size = g.w * 4;g.start_x = x * 4;g.start_y = y * g.line_size;g.max_x = g.start_x + w * 4;g.max_y = g.start_y + h * g.line_size;g.cur_x = g.start_x;g.cur_y = g.start_y;g.lflags = stbi__get8(s);if (g.lflags & 0x40) != 0 {
g.step = 8 * g.line_size;g.parse = 3;} else {
g.step = g.line_size;g.parse = 0;}if (g.lflags & 0x80) != 0 {
stbi__gif_parse_colortable(s, g.lpal, 2 << g.lflags & 7, if g.eflags & 0x01{g.transparent} else {-1});g.color_table = g.lpal;} else {if (g.flags & 0x80) != 0 {
if g.transparent >= 0 && (g.eflags & 0x01)!= 0 {
prev_trans = g.pal[g.transparent][3];g.pal[g.transparent][3] = 0;}g.color_table = g.pal;} else {return if stbi__err("missing color table"){0} else {0}}}o = stbi__process_gif_raster(s, g);if o == std::ptr::null_mut() {return std::ptr::null_mut();}if prev_trans != -1 {g.pal[g.transparent][3] = prev_trans;}return o;}
} else if stbi__get8(s) == 0x21 {{
let mut len:i32;if stbi__get8(s) == 0xF9 {
len = stbi__get8(s);if len == 4 {
g.eflags = stbi__get8(s);g.delay = stbi__get16le(s);g.transparent = stbi__get8(s);} else {
stbi__skip(s, len);}}len = stbi__get8(s);while (len != 0) {
stbi__skip(s, len);len = stbi__get8(s);}}
} else if stbi__get8(s) == 0x3B {return s;} else { return if stbi__err("unknown code"){0} else {0}}
}}

}

unsafe fn stbi__gif_load(s:&mut stbi__context, x:*mut i32, y:*mut i32, comp:*mut i32, req_comp:i32, ri:&mut stbi__result_info) -> *mut u8 {
	let u:*mut u8 = std::ptr::null_mut();
	let g:&mut stbi__gif = stbi__malloc(std::mem::size_of::<stbi__gif>());
	c_runtime::memset(g, 0, std::mem::size_of(g));
	u = stbi__gif_load_next(s, g, comp, req_comp);
	if u == s {u = std::ptr::null_mut();}
	if (u) != std::ptr::null_mut() {
x = g.w;y = g.h;if (req_comp) != 0 && req_comp != 4 {u = stbi__convert_format(u, 4, req_comp, g.w, g.h);}} else {if (g._out_) != std::ptr::null_mut() {c_runtime::free(g._out_);}}
	c_runtime::free(g);
	return u;
}

unsafe fn stbi__gif_info(s:&mut stbi__context, x:*mut i32, y:*mut i32, comp:*mut i32) -> i32 {
	return stbi__gif_info_raw(s, x, y, comp);
}

unsafe fn stbi__bmp_info(s:&mut stbi__context, x:*mut i32, y:*mut i32, comp:*mut i32) -> i32 {
	let p:*mut u8;
	let mut info:stbi__bmp_data;
	info.all_a = 255;
	p = stbi__bmp_parse_header(s, info);
	stbi__rewind(s);
	if p == std::ptr::null_mut() {return 0;}
	if (x) != std::ptr::null_mut() {x = s.img_x;}
	if (y) != std::ptr::null_mut() {y = s.img_y;}
	if (comp) != std::ptr::null_mut() {comp = if info.ma{4} else {3};}
	return 1;
}

unsafe fn stbi__psd_info(s:&mut stbi__context, x:*mut i32, y:*mut i32, comp:*mut i32) -> i32 {
	let mut channelCount:i32;let mut dummy:i32;
	if x== std::ptr::null_mut() {x = dummy;}
	if y== std::ptr::null_mut() {y = dummy;}
	if comp== std::ptr::null_mut() {comp = dummy;}
	if stbi__get32be(s) != 0x38425053 {
stbi__rewind(s);return 0;}
	if stbi__get16be(s) != 1 {
stbi__rewind(s);return 0;}
	stbi__skip(s, 6);
	channelCount = stbi__get16be(s);
	if channelCount < 0 || channelCount > 16 {
stbi__rewind(s);return 0;}
	y = stbi__get32be(s);
	x = stbi__get32be(s);
	if stbi__get16be(s) != 8 {
stbi__rewind(s);return 0;}
	if stbi__get16be(s) != 3 {
stbi__rewind(s);return 0;}
	comp = 4;
	return 1;
}

unsafe fn stbi__info_main(s:&mut stbi__context, x:*mut i32, y:*mut i32, comp:*mut i32) -> i32 {
	if (stbi__jpeg_info(s, x, y, comp)) != 0 {return 1;}
	if (stbi__png_info(s, x, y, comp)) != 0 {return 1;}
	if (stbi__gif_info(s, x, y, comp)) != 0 {return 1;}
	if (stbi__bmp_info(s, x, y, comp)) != 0 {return 1;}
	if (stbi__psd_info(s, x, y, comp)) != 0 {return 1;}
	if (stbi__tga_info(s, x, y, comp)) != 0 {return 1;}
	return stbi__err("unknown image type");
}

unsafe fn stbi_info_from_memory(buffer:*mut u8, len:i32, x:*mut i32, y:*mut i32, comp:*mut i32) -> i32 {
	let mut s:stbi__context;
	stbi__start_mem(s, buffer, len);
	return stbi__info_main(s, x, y, comp);
}

unsafe fn stbi_info_from_callbacks(c:&mut stbi_io_callbacks, user:*mut u8, x:*mut i32, y:*mut i32, comp:*mut i32) -> i32 {
	let mut s:stbi__context;
	stbi__start_callbacks(s, c, user);
	return stbi__info_main(s, x, y, comp);
}

static stbi__g_failure_reason: &'static str = "";

pub struct stbi_io_callbacks {

}

struct stbi__resample {
resample: fn(*mut u8, *mut u8, *mut u8, i32, i32) -> *mut u8,
line0: *mut u8,
line1: *mut u8,
hs: i32,
vs: i32,
w_lores: i32,
ystep: i32,
ypos: i32,
}

struct stbi__jpeg {
    s: *mut stbi__context,
    huff_dc: [stbi__huffman; 4],
    huff_ac: [stbi__huffman; 4],
    dequant: [[u16; 64]; 4],
    fast_ac: [[i16; 512]; 4],
    img_h_max: i32,
    img_v_max: i32,
    img_mcu_x: i32,
    img_mcu_y: i32,
    img_mcu_w: i32,
    img_mcu_h: i32,
    img_comp: [img_comp; 4],
    code_buffer: u32,
    code_bits: i32,
    marker: u8,
    nomore: i32,
    progressive: i32,
    spec_start: i32,
    spec_end: i32,
    succ_high: i32,
    succ_low: i32,
    eob_run: i32,
    jfif: i32,
    app14_color_transform: i32,
    rgb: i32,
    scan_n: i32,
    order: [i32; 4],
    restart_interval: i32,
    todo: i32,
    /*    idct_block_kernel: &mut IntPtr,
    YCbCr_to_RGB_kernel: &mut IntPtr,
    resample_row_hv_2_kernel: &mut IntPtr,*/
}

unsafe fn stbi__tga_test(s: *mut stbi__context) -> i32 {
/*    let res: i32 = (i32)(0);
    let sz: i32;
    let tga_color_type: i32;
    stbi__get8(s);
    tga_color_type = (i32)(stbi__get8(s));
    if tga_color_type > 1 { goto errorEnd; }
    sz = (i32)(stbi__get8(s));
    if tga_color_type == 1 {
        if sz != 1 && sz != 9 { goto errorEnd; }
        stbi__skip(s, 4);
        sz = (i32)(stbi__get8(s));
        if sz != 8 && sz != 15 && sz != 16 && sz != 24 && sz != 32 { goto errorEnd; }
        stbi__skip(s, 4);
    } else {
        if sz != 2 && sz != 3 && sz != 10 && sz != 11 { goto errorEnd; }
        stbi__skip(s, 9);
    }
    if stbi__get16le(s) < 1 { goto errorEnd; }
    if stbi__get16le(s) < 1 { goto errorEnd; }
    sz = (i32)(stbi__get8(s));
    if tga_color_type == 1 && sz != 8 && sz != 16 { goto errorEnd; }
    if sz != 8 && sz != 15 && sz != 16 && sz != 24 && sz != 32 { goto errorEnd; }
    res = (i32)(1);
    errorEnd: ;
    stbi__rewind(s);
    return (i32)(res);*/
}

pub fn stbi__err(s: &str) -> i32 {
    stbi__g_failure_reason = s;
    return 0;
}
